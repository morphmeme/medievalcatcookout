(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;
},{"../DataTypes/Map":8}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = require("../DataTypes/State/StateMachine");
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;
},{"../DataTypes/State/StateMachine":19}],3:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;
},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;
},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;
},{"./EdgeNode":4}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;
},{"./Graph":5}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;
},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;
},{"./Vec2":21}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;
},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;
},{"../Vec2":21}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;
},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;
},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;
},{"../../Utils/MathUtils":97,"../Physics/Hit":11,"../Vec2":21,"./Circle":15,"./Shape":16}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;
},{"../Vec2":21,"./AABB":14,"./Shape":16}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;
},{"../Vec2":21,"./AABB":14}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;
},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../../Events/Emitter");
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;
},{"../../Events/Emitter":24}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../Stack");
const Map_1 = require("../Map");
const Receiver_1 = require("../../Events/Receiver");
const Emitter_1 = require("../../Events/Emitter");
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options = {}) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;
},{"../../Events/Emitter":24,"../../Events/Receiver":28,"../Map":8,"../Stack":17}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;
},{"../../ResourceManager/ResourceManager":78,"../Vec2":21}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);
},{"../Utils/MathUtils":97}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;
},{"../DataTypes/Map":8,"../DataTypes/Vec2":21,"../Utils/Color":94}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;
},{"../Utils/Color":94}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;
},{"./EventQueue":25,"./GameEvent":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;
},{"../DataTypes/Map":8,"../DataTypes/Queue":12,"./GameEventType":27}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;
},{"../DataTypes/Map":8}],27:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;
},{"../DataTypes/Queue":12,"./EventQueue":25}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not the mouse was newly pressed Input frame
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed() {
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed() {
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;
},{"../DataTypes/Map":8,"../DataTypes/Vec2":21,"../Events/EventQueue":25,"../Events/GameEventType":27,"../Events/Receiver":28}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;
},{"../DataTypes/Vec2":21,"../Events/EventQueue":25,"../Events/GameEvent":26,"../Events/GameEventType":27}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;
},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;
},{"../Debug/Debug":22,"../Debug/Stats":23,"./GameLoop":34}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;
},{"../DataTypes/Vec2":21,"../Debug/Debug":22,"../Debug/Stats":23,"../Events/EventQueue":25,"../Input/Input":29,"../Input/InputHandler":30,"../Playback/Recorder":58,"../Registry/RegistryManager":61,"../Rendering/CanvasRenderer":66,"../Rendering/WebGLRenderer":71,"../ResourceManager/ResourceManager":78,"../Scene/SceneManager":89,"../SceneGraph/Viewport":81,"../Sound/AudioManager":91,"../Utils/Color":94,"./EnvironmentInitializer":31,"./FixedUpdateGameLoop":32,"./GameOptions":35}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;
},{"../DataTypes/Functions/NullFunc":3}],35:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;
},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;
},{"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":21,"../Debug/Debug":22,"../Utils/Color":94,"./GameNode":37}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":7,"../DataTypes/Shapes/AABB":14,"../DataTypes/Shapes/Circle":15,"../DataTypes/Vec2":21,"../Debug/Debug":22,"../Events/Emitter":24,"../Events/Receiver":28,"../Rendering/Animations/TweenController":64,"../Utils/Color":94}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
}
exports.default = Graphic;
},{"../Utils/Color":94,"./CanvasNode":36}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;
},{"../Graphic":38}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;
},{"../Graphic":38}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;
},{"../../Utils/Color":94,"../Graphic":38}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;
},{"../../DataTypes/Vec2":21,"../../Rendering/Animations/AnimationManager":62,"./Sprite":44}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;
},{"../../DataTypes/Vec2":21,"../../ResourceManager/ResourceManager":78,"../CanvasNode":36}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
    */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;
},{"../DataTypes/Vec2":21,"./CanvasNode":36}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;
},{"../../DataTypes/Vec2":21,"../../Debug/Debug":22,"../../Utils/Color":94,"../Tilemap":45}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;
},{"../DataTypes/Vec2":21,"../Input/Input":29,"../Utils/Color":94,"./CanvasNode":36}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;
},{"../../Utils/Color":94,"./Label":49}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":21,"../../Utils/Color":94,"../UIElement":47}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;
},{"../../DataTypes/Vec2":21,"../../Input/Input":29,"../../Utils/Color":94,"../../Utils/MathUtils":97,"../UIElement":47}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;
},{"../../Input/Input":29,"../../Utils/Color":94,"./Label":49}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;
},{"../DataTypes/Map":8}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;
},{"../DataTypes/Vec2":21}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        pathStack.push(this.graph.positions[end]);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;
},{"../DataTypes/Stack":17,"../Utils/GraphUtils":96,"./NavigationPath":54}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        console.log("Deregistering physics object");
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if ((this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if ((this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":10,"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":21,"../Nodes/Tilemaps/OrthogonalTilemap":46,"./PhysicsManager":57}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";
},{"../DataTypes/Map":8,"../Events/Emitter":24,"../Events/Receiver":28}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}
},{"../DataTypes/Queue":12,"../Events/EventQueue":25,"../Events/GameEventType":27,"../Events/Receiver":28}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
class Registry extends Map_1.default {
}
exports.default = Registry;
},{"../../DataTypes/Map":8}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":73,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":74,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":76,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":77,"../../ResourceManager/ResourceManager":78,"./Registry":59}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();
},{"../DataTypes/Map":8,"./Registries/ShaderRegistry":60}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;
},{"../../DataTypes/Map":8,"../../Events/Emitter":24,"./AnimationTypes":63}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;
},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
            if (tween.onEndCallback) {
                tween.onEndCallback();
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;
},{"../../DataTypes/Map":8,"../../Events/Emitter":24,"../../Utils/EaseFunctions":95,"../../Utils/MathUtils":97,"./AnimationTypes":63,"./TweenManager":65}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;
},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;
},{"../DataTypes/Vec2":21,"../Debug/Debug":22,"../Nodes/Graphic":38,"../Nodes/Graphics/Line":40,"../Nodes/Graphics/Point":41,"../Nodes/Graphics/Rect":42,"../Nodes/Sprites/AnimatedSprite":43,"../Nodes/Sprites/Sprite":44,"../Nodes/Tilemaps/OrthogonalTilemap":46,"../Nodes/UIElement":47,"../Nodes/UIElements/Button":48,"../Nodes/UIElements/Label":49,"../Nodes/UIElements/Slider":50,"../Nodes/UIElements/TextInput":51,"./CanvasRendering/GraphicRenderer":67,"./CanvasRendering/TilemapRenderer":68,"./CanvasRendering/UIElementRenderer":69,"./RenderingManager":70}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":78}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;
},{"../../DataTypes/Vec2":21,"../../ResourceManager/ResourceManager":78}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;
},{"../../DataTypes/Vec2":21,"../../ResourceManager/ResourceManager":78,"../../Utils/MathUtils":97}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;
},{"../ResourceManager/ResourceManager":78}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;
},{"../DataTypes/Vec2":21,"../Nodes/Graphic":38,"../Nodes/Graphics/Point":41,"../Nodes/Graphics/Rect":42,"../Nodes/Sprites/AnimatedSprite":43,"../Nodes/Sprites/Sprite":44,"../Nodes/UIElement":47,"../Nodes/UIElements/Label":49,"../Registry/Registries/ShaderRegistry":60,"../Registry/RegistryManager":61,"../ResourceManager/ResourceManager":78,"../Scene/Layers/ParallaxLayer":86,"./RenderingManager":70}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;
},{"../../ResourceManager/ResourceManager":78}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":21,"../../../ResourceManager/ResourceManager":78,"./QuadShaderType":75}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;
},{"../../../Utils/RenderingUtils":98,"../ShaderType":72}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;
},{"../../../DataTypes/Mat4x4":9,"../ShaderType":72}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":21,"../../../ResourceManager/ResourceManager":78,"./QuadShaderType":75}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":21,"../../../Nodes/Sprites/AnimatedSprite":43,"../../../ResourceManager/ResourceManager":78,"./QuadShaderType":75}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}
},{"../DataTypes/Map":8,"../DataTypes/Queue":12,"../DataTypes/Rendering/WebGLProgramType":13,"../Sound/AudioManager":91,"../Utils/StringUtils":99}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;
},{"../DataTypes/Vec2":21}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;
},{"../Debug/Stats":23,"./SceneGraph":79}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;
},{"../DataTypes/Queue":12,"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":21,"../Input/Input":29,"../Scene/Layers/ParallaxLayer":86,"../Scene/Layers/UILayer":87,"../Utils/MathUtils":97}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;
},{"../../DataTypes/Vec2":21,"../../Nodes/Graphics/GraphicTypes":39,"../../Nodes/Graphics/Line":40,"../../Nodes/Graphics/Point":41,"../../Nodes/Graphics/Rect":42,"../../Nodes/Sprites/AnimatedSprite":43,"../../Nodes/Sprites/Sprite":44,"../../Nodes/UIElements/Button":48,"../../Nodes/UIElements/Label":49,"../../Nodes/UIElements/Slider":50,"../../Nodes/UIElements/TextInput":51,"../../Nodes/UIElements/UIElementTypes":52,"../../ResourceManager/ResourceManager":78}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;
},{"./CanvasNodeFactory":82,"./TilemapFactory":84}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":6,"../../DataTypes/Tilesets/Tileset":20,"../../DataTypes/Vec2":21,"../../Nodes/Tilemaps/OrthogonalTilemap":46,"../../Pathfinding/Navmesh":55,"../../ResourceManager/ResourceManager":78}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;
},{"../Utils/MathUtils":97}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;
},{"../Layer":85}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;
},{"../../DataTypes/Vec2":21,"./ParallaxLayer":86}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;
},{"../AI/AIManager":1,"../DataTypes/Map":8,"../DataTypes/Vec2":21,"../Debug/Debug":22,"../Events/Emitter":24,"../Events/Receiver":28,"../Nodes/CanvasNode":36,"../Pathfinding/NavigationManager":53,"../Physics/BasicPhysicsManager":56,"../Rendering/Animations/TweenManager":65,"../ResourceManager/ResourceManager":78,"../SceneGraph/SceneGraphArray":80,"../Timing/TimerManager":93,"./Factories/FactoryManager":83,"./Layer":85,"./Layers/ParallaxLayer":86,"./Layers/UILayer":87,"./SceneOptions":90}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;
},{"../ResourceManager/ResourceManager":78}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;
},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":8,"../Events/GameEventType":27,"../Events/Receiver":28,"../ResourceManager/ResourceManager":78}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = require("../Utils/MathUtils");
const TimerManager_1 = require("./TimerManager");
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));
},{"../Utils/MathUtils":97,"./TimerManager":93}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;
},{}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;
},{"./MathUtils":97}],95:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;
},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;
},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;
},{"./MathUtils":97}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;
},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnemyStates = void 0;
const StateMachineAI_1 = require("../../Wolfie2D/AI/StateMachineAI");
const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const hw3_constants_1 = require("../hw3_constants");
const Alert_1 = require("./EnemyStates/Alert");
const Attack_1 = require("./EnemyStates/Attack");
const Guard_1 = require("./EnemyStates/Guard");
const Patrol_1 = require("./EnemyStates/Patrol");
class EnemyAI extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        /** The default movement speed of this AI */
        this.speed = 20;
        // State machine defers updates and event handling to its children
        // Check super classes for details
    }
    initializeAI(owner, options) {
        this.owner = owner;
        if (options.defaultMode === "guard") {
            // Guard mode
            this.addState(EnemyStates.DEFAULT, new Guard_1.default(this, owner, options.guardPosition));
        }
        else {
            // Patrol mode
            this.addState(EnemyStates.DEFAULT, new Patrol_1.default(this, owner, options.patrolRoute));
        }
        this.addState(EnemyStates.ALERT, new Alert_1.default(this, owner));
        this.addState(EnemyStates.ATTACKING, new Attack_1.default(this, owner));
        this.health = options.health;
        this.weapon = options.weapon;
        this.player = options.player;
        // Subscribe to events
        this.receiver.subscribe(hw3_constants_1.hw3_Events.SHOT_FIRED);
        console.log("Subscribed to event");
        // Initialize to the default state
        this.initialize(EnemyStates.DEFAULT);
        this.getPlayerPosition();
    }
    activate(options) {
    }
    damage(damage) {
        console.log("Took damage");
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            this.owner.visible = false;
            this.owner.disablePhysics();
            if (Math.random() < 0.2) {
                // Spawn a healthpack
                this.emitter.fireEvent("healthpack", { position: this.owner.position });
            }
            this.owner.destroy();
        }
    }
    getPlayerPosition() {
        let pos = this.player.position;
        // Get the new player location
        let start = this.owner.position.clone();
        let delta = pos.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, pos.x);
        let maxX = Math.max(start.x, pos.x);
        let minY = Math.min(start.y, pos.y);
        let maxY = Math.max(start.y, pos.y);
        // Get the wall tilemap
        let walls = this.owner.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(pos)) {
                        // We hit a wall, we can't see the player
                        return null;
                    }
                }
            }
        }
        return pos;
    }
}
exports.default = EnemyAI;
var EnemyStates;
(function (EnemyStates) {
    EnemyStates["DEFAULT"] = "default";
    EnemyStates["ALERT"] = "alert";
    EnemyStates["ATTACKING"] = "attacking";
    EnemyStates["PREVIOUS"] = "previous";
})(EnemyStates = exports.EnemyStates || (exports.EnemyStates = {}));
},{"../../Wolfie2D/AI/StateMachineAI":2,"../../Wolfie2D/DataTypes/Shapes/AABB":14,"../../Wolfie2D/DataTypes/Vec2":21,"../hw3_constants":121,"./EnemyStates/Alert":101,"./EnemyStates/Attack":102,"./EnemyStates/Guard":104,"./EnemyStates/Patrol":105}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const hw3_constants_1 = require("../../hw3_constants");
const EnemyAI_1 = require("../EnemyAI");
const EnemyState_1 = require("./EnemyState");
/** When an enemy hears a gunshot, it will rush to the location of the gunshot */
class Alert extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        this.alertTimer = new Timer_1.default(10000);
    }
    // Receives options.target
    onEnter(options) {
        this.path = this.owner.getScene().getNavigationManager().getPath(hw3_constants_1.hw3_Names.NAVMESH, this.owner.position, options.target);
        this.alertTimer.start();
    }
    handleInput(event) {
    }
    /**
     * While in the alert state, an enemy should move towards the target position received in onEnter.
     *
     * Your job is to make sure that for the duration of the alert state, the enemy moves towards this
     * target position.
     */
    update(deltaT) {
        if (this.alertTimer.isStopped()) {
            // The timer is up, return to the default state
            this.finished(EnemyAI_1.EnemyStates.DEFAULT);
            return;
        }
        if (!this.path.isDone()) {
            this.owner.moveOnPath(this.parent.speed * deltaT, this.path);
            this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.path.getMoveDirection(this.owner));
        }
        if (this.parent.getPlayerPosition() !== null) {
            this.finished(EnemyAI_1.EnemyStates.ATTACKING);
        }
    }
    onExit() {
        return {};
    }
}
exports.default = Alert;
},{"../../../Wolfie2D/DataTypes/Vec2":21,"../../../Wolfie2D/Timing/Timer":92,"../../hw3_constants":121,"../EnemyAI":100,"./EnemyState":103}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const EnemyAI_1 = require("../EnemyAI");
const EnemyState_1 = require("./EnemyState");
class Attack extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        // Regularly update the player location
        this.pollTimer = new Timer_1.default(100);
        this.exitTimer = new Timer_1.default(1000);
    }
    onEnter(options) {
        this.lastPlayerPos = this.parent.getPlayerPosition();
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (this.pollTimer.isStopped()) {
            // Restart the timer
            this.pollTimer.start();
            this.playerPos = this.parent.getPlayerPosition();
            if (this.playerPos !== null) {
                // If we see a new player position, update the last position
                this.lastPlayerPos = this.playerPos;
            }
        }
        if (this.playerPos !== null) {
            // Player is visible, restart the exitTimer
            this.exitTimer.start();
            // Fire at player
            let dir = this.playerPos.clone().sub(this.owner.position).normalize();
            dir.rotateCCW(Math.PI / 4 * Math.random() - Math.PI / 8);
            if (this.parent.weapon.use(this.owner, "enemy", dir)) {
                // If we fired, face that direction
                this.owner.rotation = Vec2_1.default.UP.angleToCCW(dir);
            }
        }
        if (this.exitTimer.isStopped()) {
            // We haven't seen the player in a while, go check out where we last saw them, if possible
            if (this.lastPlayerPos !== null) {
                this.retObj = { target: this.lastPlayerPos };
                this.finished(EnemyAI_1.EnemyStates.ALERT);
            }
            else {
                this.finished(EnemyAI_1.EnemyStates.DEFAULT);
            }
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Attack;
},{"../../../Wolfie2D/DataTypes/Vec2":21,"../../../Wolfie2D/Timing/Timer":92,"../EnemyAI":100,"./EnemyState":103}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("../../../Wolfie2D/DataTypes/State/State");
class EnemyState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
}
exports.default = EnemyState;
},{"../../../Wolfie2D/DataTypes/State/State":18}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const hw3_constants_1 = require("../../hw3_constants");
const EnemyAI_1 = require("../EnemyAI");
const EnemyState_1 = require("./EnemyState");
class Guard extends EnemyState_1.default {
    constructor(parent, owner, guardPosition) {
        super(parent, owner);
        this.guardPosition = guardPosition;
    }
    onEnter(options) {
        // Go to the guard position if not already there
        if (!(this.owner.position.distanceSqTo(this.guardPosition) < 8 * 8)) {
            // We need a new route
            this.awayFromGuardPosition = true;
            this.owner.pathfinding = true;
            this.route = this.owner.getScene().getNavigationManager().getPath(hw3_constants_1.hw3_Names.NAVMESH, this.owner.position, this.guardPosition);
        }
        else {
            this.awayFromGuardPosition = false;
            this.owner.pathfinding = false;
        }
    }
    handleInput(event) {
        if (event.type === hw3_constants_1.hw3_Events.SHOT_FIRED) {
            // Shot was fired. Go check it out if it was close to us
            if (this.owner.position.distanceTo(event.data.get("position")) < event.data.get("volume")) {
                this.retObj = { target: event.data.get("position") };
                this.finished(EnemyAI_1.EnemyStates.ALERT);
            }
        }
    }
    update(deltaT) {
        if (this.awayFromGuardPosition) {
            // Navigate back home
            if (this.route.isDone()) {
                this.awayFromGuardPosition = false;
                this.owner.pathfinding = false;
            }
            else {
                this.owner.moveOnPath(this.parent.speed * deltaT, this.route);
                this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.route.getMoveDirection(this.owner));
            }
        }
        if (this.parent.getPlayerPosition() !== null) {
            this.finished(EnemyAI_1.EnemyStates.ATTACKING);
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Guard;
},{"../../../Wolfie2D/DataTypes/Vec2":21,"../../hw3_constants":121,"../EnemyAI":100,"./EnemyState":103}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const hw3_constants_1 = require("../../hw3_constants");
const EnemyAI_1 = require("../EnemyAI");
const EnemyState_1 = require("./EnemyState");
class Patrol extends EnemyState_1.default {
    constructor(parent, owner, patrolRoute) {
        super(parent, owner);
        this.patrolRoute = patrolRoute;
        this.routeIndex = 0;
    }
    onEnter(options) {
        this.currentPath = this.getNextPath();
    }
    handleInput(event) {
        if (event.type === hw3_constants_1.hw3_Events.SHOT_FIRED) {
            // Shot was fired. Go check it out if it was close to us
            if (this.owner.position.distanceTo(event.data.get("position")) < event.data.get("volume")) {
                // Shot was close enough to hear, go to the alert state
                this.retObj = { target: event.data.get("position") };
                this.finished(EnemyAI_1.EnemyStates.ALERT);
            }
        }
    }
    /**
     * An enemy in the patrol state should move along its route.
     * The route is given to this state in its constructor.
     *
     * You must add in routing so that the enemy will move along its patrol route while in this state.
     * The patrol route (in this case) is a series of positions in the world the enemy should move between.
     *
     * You can also modify the onEnter method if you wish to.
     *
     * For inspiration, check out the Guard state, or look at the NavigationPath class or the GameNode class
     */
    update(deltaT) {
        if (!this.currentPath.isDone()) {
            this.owner.moveOnPath(this.parent.speed * deltaT, this.currentPath);
            this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.currentPath.getMoveDirection(this.owner));
        }
        else {
            this.currentPath = this.getNextPath();
        }
        // If the enemy sees the player, start attacking
        if (this.parent.getPlayerPosition() !== null) {
            this.finished(EnemyAI_1.EnemyStates.ATTACKING);
        }
    }
    onExit() {
        return this.retObj;
    }
    getNextPath() {
        let path = this.owner.getScene().getNavigationManager().getPath(hw3_constants_1.hw3_Names.NAVMESH, this.owner.position, this.patrolRoute[this.routeIndex]);
        this.routeIndex = (this.routeIndex + 1) % this.patrolRoute.length;
        return path;
    }
}
exports.default = Patrol;
},{"../../../Wolfie2D/DataTypes/Vec2":21,"../../hw3_constants":121,"../EnemyAI":100,"./EnemyState":103}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../../Wolfie2D/Input/Input");
const Healthpack_1 = require("../GameSystems/items/Healthpack");
class PlayerController {
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.direction = Vec2_1.default.ZERO;
        this.lookDirection = Vec2_1.default.ZERO;
        this.speed = options.speed;
        this.health = 5;
        this.items = options.items;
        this.inventory = options.inventory;
    }
    activate(options) { }
    handleEvent(event) { }
    update(deltaT) {
        // Get the movement direction
        if (Input_1.default.isPressed("forward")) {
            this.direction.y = -1;
            this.direction.x = 0;
        }
        else if (Input_1.default.isPressed("backward")) {
            this.direction.y = 1;
            this.direction.x = 0;
        }
        else if (Input_1.default.isPressed("left")) {
            this.direction.x = -1;
            this.direction.y = 0;
        }
        else if (Input_1.default.isPressed("right")) {
            this.direction.x = 1;
            this.direction.y = 0;
        }
        if (!this.direction.isZero()) {
            // Move the player
            this.owner.move(this.direction.normalized().scale(this.speed * deltaT));
            this.owner.animation.playIfNotAlready("WALK", true);
        }
        else {
            // Player is idle
            this.owner.animation.playIfNotAlready("IDLE", true);
        }
        // Get the unit vector in the look direction
        this.lookDirection = this.owner.position.dirTo(Input_1.default.getGlobalMousePosition());
        // Shoot a bullet
        if (Input_1.default.isMouseJustPressed()) {
            // Get the current item
            let item = this.inventory.getItem();
            // If there is an item in the current slot, use it
            if (item) {
                item.use(this.owner, "player", this.lookDirection);
                if (item instanceof Healthpack_1.default) {
                    // Destroy the used healthpack
                    this.inventory.removeItem();
                    item.sprite.visible = false;
                }
            }
        }
        // Rotate the player
        this.owner.rotation = Vec2_1.default.UP.angleToCCW(this.lookDirection);
        // Inventory
        // Check for slot change
        if (Input_1.default.isJustPressed("slot1")) {
            this.inventory.changeSlot(0);
        }
        else if (Input_1.default.isJustPressed("slot2")) {
            this.inventory.changeSlot(1);
        }
        if (Input_1.default.isJustPressed("pickup")) {
            // Check if there is an item to pick up
            for (let item of this.items) {
                if (this.owner.collisionShape.overlaps(item.sprite.boundary)) {
                    // We overlap it, try to pick it up
                    this.inventory.addItem(item);
                    break;
                }
            }
        }
        if (Input_1.default.isJustPressed("drop")) {
            // Check if we can drop our current item
            let item = this.inventory.removeItem();
            if (item) {
                // Move the item from the ui to the gameworld
                item.moveSprite(this.owner.position, "primary");
                // Add the item to the list of items
                this.items.push(item);
            }
        }
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            console.log("Game Over");
        }
    }
}
exports.default = PlayerController;
},{"../../Wolfie2D/DataTypes/Vec2":21,"../../Wolfie2D/Input/Input":29,"../GameSystems/items/Healthpack":109}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BattleManager {
    handleInteraction(attackerType, weapon) {
        if (attackerType === "player") {
            // Check for collisions with enemies
            for (let enemy of this.enemies) {
                if (weapon.hits(enemy.owner)) {
                    enemy.damage(weapon.type.damage);
                }
            }
        }
        else {
            // Check for collision with player
            if (weapon.hits(this.player.owner)) {
                this.player.damage(weapon.type.damage);
            }
        }
    }
    setPlayer(player) {
        this.player = player;
    }
    setEnemies(enemies) {
        this.enemies = enemies;
    }
}
exports.default = BattleManager;
},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Color_1 = require("../../Wolfie2D/Utils/Color");
class InventoryManager {
    constructor(scene, size, inventorySlot, position, padding) {
        this.items = new Array(size);
        this.inventorySlots = new Array(size);
        this.padding = padding;
        this.position = position;
        this.currentSlot = 0;
        // Add layers
        this.slotLayer = "slots";
        scene.addUILayer(this.slotLayer).setDepth(100);
        this.itemLayer = "items";
        scene.addUILayer(this.itemLayer).setDepth(101);
        // Create the inventory slots
        for (let i = 0; i < size; i++) {
            this.inventorySlots[i] = scene.add.sprite(inventorySlot, this.slotLayer);
        }
        this.slotSize = this.inventorySlots[0].size.clone();
        // Position the inventory slots
        for (let i = 0; i < size; i++) {
            this.inventorySlots[i].position.set(position.x + i * (this.slotSize.x + this.padding), position.y);
        }
        // Add a rect for the selected slot
        this.selectedSlot = scene.add.graphic(GraphicTypes_1.GraphicType.RECT, "slots", { position: this.position.clone(), size: this.slotSize.clone().inc(-2) });
        this.selectedSlot.color = Color_1.default.WHITE;
        this.selectedSlot.color.a = 0.2;
    }
    getItem() {
        return this.items[this.currentSlot];
    }
    /**
     * Changes the currently selected slot
     */
    changeSlot(slot) {
        this.currentSlot = slot;
        this.selectedSlot.position.copy(this.inventorySlots[slot].position);
    }
    /**
     * Gets the currently selected slot
     */
    getSlot() {
        return this.currentSlot;
    }
    /**
     * Adds an item to the currently selected slot
     */
    addItem(item) {
        if (!this.items[this.currentSlot]) {
            // Add the item to the inventory
            this.items[this.currentSlot] = item;
            // Update the gui
            item.moveSprite(new Vec2_1.default(this.position.x + this.currentSlot * (this.slotSize.x + this.padding), this.position.y), this.itemLayer);
            return true;
        }
        // Failed to add item, something was already in the slot
        return false;
    }
    /**
     * Removes and returns an item from the the currently selected slot, if possible
     */
    removeItem() {
        let item = this.items[this.currentSlot];
        this.items[this.currentSlot] = null;
        if (item) {
            return item;
        }
        else {
            return null;
        }
    }
}
exports.default = InventoryManager;
},{"../../Wolfie2D/DataTypes/Vec2":21,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":39,"../../Wolfie2D/Utils/Color":94}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Item_1 = require("./Item");
class Healthpack extends Item_1.default {
    use(user) {
        user._ai.health += 1;
    }
}
exports.default = Healthpack;
},{"./Item":110}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Item {
    constructor(sprite) {
        this.sprite = sprite;
    }
    moveSprite(position, layer) {
        // Change the layer if needed
        if (layer) {
            let currentLayer = this.sprite.getLayer();
            currentLayer.removeNode(this.sprite);
            let newLayer = this.sprite.getScene().getLayer(layer);
            newLayer.addNode(this.sprite);
            this.sprite.setLayer(newLayer);
        }
        // Move the sprite
        this.sprite.position.copy(position);
    }
}
exports.default = Item;
},{}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../../../Wolfie2D/Events/Emitter");
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const hw3_constants_1 = require("../../hw3_constants");
const Item_1 = require("./Item");
class Weapon extends Item_1.default {
    constructor(sprite, type, battleManager) {
        super(sprite);
        // Set the weapon type
        this.type = type;
        // Keep a reference to the sprite of this weapon
        this.sprite = sprite;
        // Rely on the weapon type to create any necessary assets
        this.assets = this.type.createRequiredAssets(this.sprite.getScene());
        // Create an event emitter
        this.emitter = new Emitter_1.default();
        // Save a reference to the battler manager
        this.battleManager = battleManager;
        // Create the cooldown timer
        this.cooldownTimer = new Timer_1.default(type.cooldown);
    }
    // @override
    /**
     * Uses this weapon in the specified direction.
     * This only works if the cooldown timer has ended
     */
    use(user, userType, direction) {
        // If the cooldown timer is still running, we can't use the weapon
        if (!this.cooldownTimer.isStopped()) {
            return false;
        }
        // Do a type specific weapon animation
        this.type.doAnimation(user, direction, ...this.assets);
        // Apply damage
        this.battleManager.handleInteraction(userType, this);
        // Send out an event to alert enemies
        this.emitter.fireEvent(hw3_constants_1.hw3_Events.SHOT_FIRED, { position: user.position.clone(), volume: this.type.useVolume });
        // Reset the cooldown timer
        this.cooldownTimer.start();
        return true;
    }
    /**
     * A check for whether or not this weapon hit a node
     */
    hits(node) {
        return this.type.hits(node, ...this.assets);
    }
}
exports.default = Weapon;
},{"../../../Wolfie2D/Events/Emitter":24,"../../../Wolfie2D/Timing/Timer":92,"../../hw3_constants":121,"./Item":110}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = require("../../../../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
const GraphicTypes_1 = require("../../../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Color_1 = require("../../../../Wolfie2D/Utils/Color");
const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
const WeaponType_1 = require("./WeaponType");
class LaserGun extends WeaponType_1.default {
    initialize(options) {
        this.damage = options.damage;
        this.cooldown = options.cooldown;
        this.color = Color_1.default.fromStringHex(options.color);
        this.displayName = options.displayName;
        this.spriteKey = options.spriteKey;
        this.useVolume = options.useVolume;
    }
    doAnimation(shooter, direction, line) {
        let start = shooter.position.clone();
        let end = shooter.position.clone().add(direction.scaled(900));
        let delta = end.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, end.x);
        let maxX = Math.max(start.x, end.x);
        let minY = Math.min(start.y, end.y);
        let maxY = Math.max(start.y, end.y);
        // Get the wall tilemap
        let walls = shooter.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(end)) {
                        console.log("Found hit");
                        end = hit.pos;
                    }
                }
            }
        }
        line.start = start;
        line.end = end;
        line.tweens.play("fade");
    }
    createRequiredAssets(scene) {
        let line = scene.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: new Vec2_1.default(-1, 1), end: new Vec2_1.default(-1, -1) });
        line.color = this.color;
        line.tweens.add("fade", {
            startDelay: 0,
            duration: 300,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 1,
                    end: 0,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ]
        });
        return [line];
    }
    hits(node, line) {
        if (!node) {
            return false;
        }
        return node.collisionShape.getBoundingRect().intersectSegment(line.start, line.end.clone().sub(line.start)) !== null;
    }
}
exports.default = LaserGun;
},{"../../../../Wolfie2D/DataTypes/Shapes/AABB":14,"../../../../Wolfie2D/DataTypes/Vec2":21,"../../../../Wolfie2D/Nodes/GameNode":37,"../../../../Wolfie2D/Nodes/Graphics/GraphicTypes":39,"../../../../Wolfie2D/Utils/Color":94,"../../../../Wolfie2D/Utils/EaseFunctions":95,"./WeaponType":115}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = require("../../../../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("../../../../Wolfie2D/DataTypes/Vec2");
const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
const GraphicTypes_1 = require("../../../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const Color_1 = require("../../../../Wolfie2D/Utils/Color");
const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
const WeaponType_1 = require("./WeaponType");
class SemiAutoGun extends WeaponType_1.default {
    initialize(options) {
        this.damage = options.damage;
        this.cooldown = options.cooldown;
        this.color = Color_1.default.fromStringHex(options.color);
        this.displayName = options.displayName;
        this.spriteKey = options.spriteKey;
        this.useVolume = options.useVolume;
    }
    doAnimation(shooter, direction, line) {
        let start = shooter.position.clone();
        let end = shooter.position.clone().add(direction.scaled(900));
        let delta = end.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, end.x);
        let maxX = Math.max(start.x, end.x);
        let minY = Math.min(start.y, end.y);
        let maxY = Math.max(start.y, end.y);
        // Get the wall tilemap
        let walls = shooter.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(end)) {
                        console.log("Found hit");
                        end = hit.pos;
                    }
                }
            }
        }
        line.start = start;
        line.end = end;
        line.tweens.play("fade");
    }
    createRequiredAssets(scene) {
        let line = scene.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: new Vec2_1.default(-1, 1), end: new Vec2_1.default(-1, -1) });
        line.color = this.color;
        line.tweens.add("fade", {
            startDelay: 0,
            duration: 300,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 1,
                    end: 0,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ],
            onEndCallback: () => {
                line.start = new Vec2_1.default(-1, 1);
                line.end = new Vec2_1.default(-1, -1);
            }
        });
        return [line];
    }
    hits(node, line) {
        return node.collisionShape.getBoundingRect().intersectSegment(line.start, line.end.clone().sub(line.start)) !== null;
    }
}
exports.default = SemiAutoGun;
},{"../../../../Wolfie2D/DataTypes/Shapes/AABB":14,"../../../../Wolfie2D/DataTypes/Vec2":21,"../../../../Wolfie2D/Nodes/GameNode":37,"../../../../Wolfie2D/Nodes/Graphics/GraphicTypes":39,"../../../../Wolfie2D/Utils/Color":94,"../../../../Wolfie2D/Utils/EaseFunctions":95,"./WeaponType":115}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WeaponType_1 = require("./WeaponType");
class Slice extends WeaponType_1.default {
    initialize(options) {
        this.damage = options.damage;
        this.cooldown = options.cooldown;
        this.displayName = options.displayName;
        this.spriteKey = options.spriteKey;
        this.useVolume = options.useVolume;
    }
    doAnimation(attacker, direction, sliceSprite) {
        // Rotate this with the game node
        sliceSprite.rotation = attacker.rotation;
        // Move the slice out from the player
        sliceSprite.position = attacker.position.clone().add(direction.scaled(16));
        // Play the slice animation w/o loop, but queue the normal animation
        sliceSprite.animation.play("SLICE");
        sliceSprite.animation.queue("NORMAL", true);
    }
    createRequiredAssets(scene) {
        let slice = scene.add.animatedSprite("slice", "primary");
        slice.animation.play("NORMAL", true);
        return [slice];
    }
    hits(node, sliceSprite) {
        return sliceSprite.boundary.overlaps(node.collisionShape);
    }
}
exports.default = Slice;
},{"./WeaponType":115}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class WeaponType {
}
exports.default = WeaponType;
},{}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
const ResourceManager_1 = require("../../Wolfie2D/ResourceManager/ResourceManager");
const LaserGun_1 = require("../GameSystems/items/WeaponTypes/LaserGun");
const SemiAutoGun_1 = require("../GameSystems/items/WeaponTypes/SemiAutoGun");
const Slice_1 = require("../GameSystems/items/WeaponTypes/Slice");
class WeaponTemplateRegistry extends Registry_1.default {
    preload() {
        const rm = ResourceManager_1.default.getInstance();
        // Load sprites
        rm.image("pistol", "hw3_assets/sprites/pistol.png");
        rm.image("knife", "hw3_assets/sprites/knife.png");
        rm.image("lasergun", "hw3_assets/sprites/lasergun.png");
        // Load spritesheets
        rm.spritesheet("slice", "hw3_assets/spritesheets/slice.json");
        // Register default types
        this.registerItem("slice", Slice_1.default);
        this.registerItem("semiAutoGun", SemiAutoGun_1.default);
        this.registerItem("laserGun", LaserGun_1.default);
    }
    // We don't need this for this assignment
    registerAndPreloadItem(key) { }
    registerItem(key, constr) {
        this.add(key, constr);
    }
}
exports.default = WeaponTemplateRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":59,"../../Wolfie2D/ResourceManager/ResourceManager":78,"../GameSystems/items/WeaponTypes/LaserGun":112,"../GameSystems/items/WeaponTypes/SemiAutoGun":113,"../GameSystems/items/WeaponTypes/Slice":114}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
class WeaponTypeRegistry extends Registry_1.default {
    preload() { }
    // We don't need this for this assignment
    registerAndPreloadItem(key) { }
    registerItem(key, type) {
        this.add(key, type);
    }
}
exports.default = WeaponTypeRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":59}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Color_1 = require("../../Wolfie2D/Utils/Color");
class GameOver extends Scene_1.default {
    startScene() {
        const center = this.viewport.getCenter();
        this.addUILayer("primary");
        const gameOver = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "primary", { position: new Vec2_1.default(center.x, center.y), text: "Game Over" });
        gameOver.textColor = Color_1.default.WHITE;
    }
}
exports.default = GameOver;
},{"../../Wolfie2D/DataTypes/Vec2":21,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":88,"../../Wolfie2D/Utils/Color":94}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const hw3_scene_1 = require("./hw3_scene");
class MainMenu extends Scene_1.default {
    loadScene() { }
    startScene() {
        const center = this.viewport.getCenter();
        // The main menu
        this.mainMenu = this.addUILayer("mainMenu");
        // Add play button, and give it an event to emit on press
        const play = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y - 100), text: "Play" });
        play.size.set(200, 50);
        play.borderWidth = 2;
        play.borderColor = Color_1.default.WHITE;
        play.backgroundColor = Color_1.default.TRANSPARENT;
        play.onClickEventId = "play";
        // Add control button
        const controls = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y), text: "Controls" });
        controls.size.set(200, 50);
        controls.borderWidth = 2;
        controls.borderColor = Color_1.default.WHITE;
        controls.backgroundColor = Color_1.default.TRANSPARENT;
        controls.onClickEventId = "controls";
        // Add event button
        const about = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x, center.y + 100), text: "About" });
        about.size.set(200, 50);
        about.borderWidth = 2;
        about.borderColor = Color_1.default.WHITE;
        about.backgroundColor = Color_1.default.TRANSPARENT;
        about.onClickEventId = "about";
        /* ########## CONTROLS SCREEN ########## */
        this.controls = this.addUILayer("controls");
        this.controls.setHidden(true);
        const controlsHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y - 250), text: "Controls" });
        controlsHeader.textColor = Color_1.default.WHITE;
        const controlsText1 = "WASD to move";
        const controlsText2 = "Q to drop an item";
        const controlsText3 = "E to pick up an item";
        const controlsText4 = "Click to use current item";
        const controlsText5 = "1&2 to change items";
        const controlsLine1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y - 100), text: controlsText1 });
        const controlsLine2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y - 50), text: controlsText2 });
        const controlsLine3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y), text: controlsText3 });
        const controlsLine4 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y + 50), text: controlsText4 });
        const controlsLine5 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "controls", { position: new Vec2_1.default(center.x, center.y + 100), text: controlsText5 });
        controlsLine1.textColor = Color_1.default.WHITE;
        controlsLine2.textColor = Color_1.default.WHITE;
        controlsLine3.textColor = Color_1.default.WHITE;
        controlsLine4.textColor = Color_1.default.WHITE;
        controlsLine5.textColor = Color_1.default.WHITE;
        const controlsBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "controls", { position: new Vec2_1.default(center.x, center.y + 250), text: "Back" });
        controlsBack.size.set(200, 50);
        controlsBack.borderWidth = 2;
        controlsBack.borderColor = Color_1.default.WHITE;
        controlsBack.backgroundColor = Color_1.default.TRANSPARENT;
        controlsBack.onClickEventId = "menu";
        /* ########## ABOUT SCREEN ########## */
        this.about = this.addUILayer("about");
        this.about.setHidden(true);
        const aboutHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1.default(center.x, center.y - 250), text: "About" });
        aboutHeader.textColor = Color_1.default.WHITE;
        const text1 = "This game was created by Alex Feng, Joe Weaver, and Richard McKenna";
        const text2 = "using the Wolfie2D game engine, a TypeScript game engine created by";
        const text3 = "Joe Weaver and Richard McKenna.";
        const line1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1.default(center.x, center.y - 50), text: text1 });
        const line2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1.default(center.x, center.y), text: text2 });
        const line3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1.default(center.x, center.y + 50), text: text3 });
        line1.textColor = Color_1.default.WHITE;
        line2.textColor = Color_1.default.WHITE;
        line3.textColor = Color_1.default.WHITE;
        const aboutBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "about", { position: new Vec2_1.default(center.x, center.y + 250), text: "Back" });
        aboutBack.size.set(200, 50);
        aboutBack.borderWidth = 2;
        aboutBack.borderColor = Color_1.default.WHITE;
        aboutBack.backgroundColor = Color_1.default.TRANSPARENT;
        aboutBack.onClickEventId = "menu";
        // Subscribe to the button events
        this.receiver.subscribe("play");
        this.receiver.subscribe("about");
        this.receiver.subscribe("menu");
        this.receiver.subscribe("controls");
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === "play") {
                let sceneOptions = {
                    physics: {
                        groupNames: ["ground", "player", "enemy"],
                        collisions: [
                            [0, 1, 1],
                            [1, 0, 0],
                            [1, 0, 0],
                        ]
                    }
                };
                this.sceneManager.changeToScene(hw3_scene_1.default, {}, sceneOptions);
            }
            if (event.type === "controls") {
                this.controls.setHidden(false);
                this.mainMenu.setHidden(true);
            }
            if (event.type === "about") {
                this.about.setHidden(false);
                this.mainMenu.setHidden(true);
            }
            if (event.type === "menu") {
                this.mainMenu.setHidden(false);
                this.about.setHidden(true);
                this.controls.setHidden(true);
            }
        }
    }
}
exports.default = MainMenu;
},{"../../Wolfie2D/DataTypes/Vec2":21,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":88,"../../Wolfie2D/Utils/Color":94,"./hw3_scene":120}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerController_1 = require("../AI/PlayerController");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const PositionGraph_1 = require("../../Wolfie2D/DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Wolfie2D/Pathfinding/Navmesh");
const hw3_constants_1 = require("../hw3_constants");
const EnemyAI_1 = require("../AI/EnemyAI");
const RegistryManager_1 = require("../../Wolfie2D/Registry/RegistryManager");
const Weapon_1 = require("../GameSystems/items/Weapon");
const Healthpack_1 = require("../GameSystems/items/Healthpack");
const InventoryManager_1 = require("../GameSystems/InventoryManager");
const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
const BattleManager_1 = require("../GameSystems/BattleManager");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const Input_1 = require("../../Wolfie2D/Input/Input");
const GameOver_1 = require("./GameOver");
class hw3_scene extends Scene_1.default {
    loadScene() {
        // Load the player and enemy spritesheets
        this.load.spritesheet("player", "hw3_assets/spritesheets/player.json");
        this.load.spritesheet("enemy", "hw3_assets/spritesheets/enemy.json");
        this.load.spritesheet("slice", "hw3_assets/spritesheets/slice.json");
        // Load the tilemap
        // HOMEWORK 3 - TODO
        // Change this file to be your own tilemap
        this.load.tilemap("level", "hw3_assets/tilemaps/alex-feng-hw3.json");
        // Load the scene info
        this.load.object("weaponData", "hw3_assets/data/weaponData.json");
        // Load the nav mesh
        this.load.object("navmesh", "hw3_assets/data/navmesh.json");
        // Load in the enemy info
        this.load.object("enemyData", "hw3_assets/data/enemy.json");
        // Load in item info
        this.load.object("itemData", "hw3_assets/data/items.json");
        // Load the healthpack sprite
        this.load.image("healthpack", "hw3_assets/sprites/healthpack.png");
        this.load.image("inventorySlot", "hw3_assets/sprites/inventory.png");
        this.load.image("knife", "hw3_assets/sprites/knife.png");
        this.load.image("lasergun", "hw3_assets/sprites/lasergun.png");
        this.load.image("pistol", "hw3_assets/sprites/pistol.png");
    }
    startScene() {
        // Add in the tilemap
        let tilemapLayers = this.add.tilemap("level");
        // Get the wall layer
        // HOMEWORK 3 - TODO
        /*
            Modify this line if needed.
            
            This line is just getting the wall layer of your tilemap to use for some calculations.
            Make sure it is still doing so.

            What the line is saying is to get the first level from the bottom (tilemapLayers[1]),
            which in my case was the Walls layer.
        */
        this.walls = tilemapLayers[1].getItems()[0];
        // Set the viewport bounds to the tilemap
        let tilemapSize = this.walls.size;
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.addLayer("primary", 10);
        // Create the battle manager
        this.battleManager = new BattleManager_1.default();
        this.initializeWeapons();
        // Initialize the items array - this represents items that are in the game world
        this.items = new Array();
        // Create the player
        this.initializePlayer();
        // Make the viewport follow the player
        this.viewport.follow(this.player);
        // Zoom in to a reasonable level
        this.viewport.enableZoom();
        this.viewport.setZoomLevel(4);
        // Create the navmesh
        this.createNavmesh();
        // Initialize all enemies
        this.initializeEnemies();
        // Send the player and enemies to the battle manager
        this.battleManager.setPlayer(this.player._ai);
        this.battleManager.setEnemies(this.enemies.map(enemy => enemy._ai));
        // Subscribe to relevant events
        this.receiver.subscribe("healthpack");
        // Spawn items into the world
        this.spawnItems();
        // Add a UI for health
        this.addUILayer("health");
        this.healthDisplay = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "health", { position: new Vec2_1.default(200, 16), text: "Health: " + this.player._ai.health });
        this.healthDisplay.textColor = Color_1.default.WHITE;
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.isType("healthpack")) {
                this.createHealthpack(event.data.get("position"));
            }
        }
        let health = this.player._ai.health;
        if (health === 0) {
            this.sceneManager.changeToScene(GameOver_1.default);
        }
        // Update health gui
        this.healthDisplay.text = "Health: " + health;
        // Debug mode graph
        if (Input_1.default.isKeyJustPressed("g")) {
            this.getLayer("graph").setHidden(!this.getLayer("graph").isHidden());
        }
    }
    // HOMEWORK 3 - TODO
    /**
     * This function spawns in all of the items in "items.json"
     *
     * You shouldn't have to put any new code here, however, you will have to modify items.json.
     *
     * Make sure you are spawning in 5 pistols and 5 laser guns somewhere (accessible) in your world.
     *
     * You'll notice that right now, some healthpacks are also spawning in. These also drop from guards.
     * Feel free to spawn some healthpacks if you want, or you can just let the player suffer >:)
     */
    spawnItems() {
        // Get the item data
        let itemData = this.load.getObject("itemData");
        for (let item of itemData.items) {
            if (item.type === "healthpack") {
                // Create a healthpack
                this.createHealthpack(new Vec2_1.default(item.position[0], item.position[1]));
            }
            else {
                let weapon = this.createWeapon(item.weaponType);
                weapon.moveSprite(new Vec2_1.default(item.position[0], item.position[1]));
                this.items.push(weapon);
            }
        }
    }
    /**
     *
     * Creates and returns a new weapon
     * @param type The weaponType of the weapon, as a string
     */
    createWeapon(type) {
        let weaponType = RegistryManager_1.default.getRegistry("weaponTypes").get(type);
        let sprite = this.add.sprite(weaponType.spriteKey, "primary");
        return new Weapon_1.default(sprite, weaponType, this.battleManager);
    }
    /**
     * Creates a healthpack at a certain position in the world
     * @param position
     */
    createHealthpack(position) {
        let sprite = this.add.sprite("healthpack", "primary");
        let healthpack = new Healthpack_1.default(sprite);
        healthpack.moveSprite(position);
        this.items.push(healthpack);
    }
    // HOMEWORK 3 - TODO
    /**
     * You'll want to have a new weapon type available in your program - a laser gun.
     * Carefully look through the code for how the other weapon types (knife and pistol)
     * are created. They're based of the templates Slice and SemiAutoGun. You should use
     * the SemiAutoGun template for your laser gun.
     *
     * The laser gun should have a green beam, and should be considerably more powerful than
     * a pistol. You can decide just how powerful it is.
     *
     * Look in weaponData.json for some insight on what to do here.
     *
     * Loads in all weapons from file
     */
    initializeWeapons() {
        let weaponData = this.load.getObject("weaponData");
        for (let i = 0; i < weaponData.numWeapons; i++) {
            let weapon = weaponData.weapons[i];
            // Get the constructor of the prototype
            let constr = RegistryManager_1.default.getRegistry("weaponTemplates").get(weapon.weaponType);
            // Create a weapon type
            let weaponType = new constr();
            // Initialize the weapon type
            weaponType.initialize(weapon);
            // Register the weapon type
            RegistryManager_1.default.getRegistry("weaponTypes").registerItem(weapon.name, weaponType);
        }
    }
    initializePlayer() {
        // Create the inventory
        let inventory = new InventoryManager_1.default(this, 2, "inventorySlot", new Vec2_1.default(16, 16), 4);
        let startingWeapon = this.createWeapon("knife");
        inventory.addItem(startingWeapon);
        // Create the player
        this.player = this.add.animatedSprite("player", "primary");
        this.player.position.set(2 * 16, 62 * 16);
        this.player.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(5, 5)));
        this.player.addAI(PlayerController_1.default, {
            speed: 100,
            inventory: inventory,
            items: this.items
        });
        this.player.animation.play("IDLE");
        this.player.setGroup("player");
    }
    // HOMEWORK 3 - TODO
    /**
     * This function creates the navmesh for the game world.
     *
     * It reads in information in the navmesh.json file.
     * The format of the navmesh.json file is as follows
     *
     * {
     *  // An array of positions on the tilemap. You can see the position of your mouse in [row, col]
     *  // while editing a map in Tiled, and can just multiply those values by the tile size, 16x16
     *      "nodes": [[100, 200], [50, 400], ...]
     *
     *  // An array of edges between nodes. The numbers here correspond to indices in the "nodes" array above.
     *  // Note that edges are not directed here. An edge [0, 1] foes in both directions.
     *      "edges": [[0, 1], [2, 4], ...]
     * }
     *
     * Your job here is to make a new graph to serve as the navmesh. Your graph should be designed
     * for your tilemap, and no edges should go through walls.
     */
    createNavmesh() {
        // Add a layer to display the graph
        let gLayer = this.addLayer("graph");
        gLayer.setHidden(true);
        let navmeshData = this.load.getObject("navmesh");
        // Create the graph
        this.graph = new PositionGraph_1.default();
        // Add all nodes to our graph
        for (let node of navmeshData.nodes) {
            this.graph.addPositionedNode(new Vec2_1.default(node[0], node[1]));
            this.add.graphic(GraphicTypes_1.GraphicType.POINT, "graph", { position: new Vec2_1.default(node[0], node[1]) });
        }
        // Add all edges to our graph
        for (let edge of navmeshData.edges) {
            this.graph.addEdge(edge[0], edge[1]);
            this.add.graphic(GraphicTypes_1.GraphicType.LINE, "graph", { start: this.graph.getNodePosition(edge[0]), end: this.graph.getNodePosition(edge[1]) });
        }
        // Set this graph as a navigable entity
        let navmesh = new Navmesh_1.default(this.graph);
        this.navManager.addNavigableEntity(hw3_constants_1.hw3_Names.NAVMESH, navmesh);
    }
    // HOMEWORK 3 - TODO
    /**
     * This function creates all enemies from the enemy.json file.
     * You shouldn't have to modify any code here, but you should edit enemy.json to
     * make sure more enemies are spawned into the world.
     *
     * Patrolling enemies are given patrol routes corresponding to the navmesh. The numbers in their route correspond
     * to indices in the navmesh.
     */
    initializeEnemies() {
        // Get the enemy data
        const enemyData = this.load.getObject("enemyData");
        // Create an enemies array
        this.enemies = new Array(enemyData.numEnemies);
        // Initialize the enemies
        for (let i = 0; i < enemyData.numEnemies; i++) {
            let data = enemyData.enemies[i];
            // Create an enemy
            this.enemies[i] = this.add.animatedSprite("enemy", "primary");
            this.enemies[i].position.set(data.position[0], data.position[1]);
            this.enemies[i].animation.play("IDLE");
            // Activate physics
            this.enemies[i].addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(5, 5)));
            if (data.route) {
                data.route = data.route.map((index) => this.graph.getNodePosition(index));
            }
            if (data.guardPosition) {
                data.guardPosition = new Vec2_1.default(data.guardPosition[0], data.guardPosition[1]);
            }
            let enemyOptions = {
                defaultMode: data.mode,
                patrolRoute: data.route,
                guardPosition: data.guardPosition,
                health: data.health,
                player: this.player,
                weapon: this.createWeapon("weak_pistol")
            };
            this.enemies[i].addAI(EnemyAI_1.default, enemyOptions);
            this.enemies[i].setGroup("enemy");
        }
    }
}
exports.default = hw3_scene;
},{"../../Wolfie2D/DataTypes/Graphs/PositionGraph":6,"../../Wolfie2D/DataTypes/Shapes/AABB":14,"../../Wolfie2D/DataTypes/Vec2":21,"../../Wolfie2D/Input/Input":29,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":39,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Pathfinding/Navmesh":55,"../../Wolfie2D/Registry/RegistryManager":61,"../../Wolfie2D/Scene/Scene":88,"../../Wolfie2D/Utils/Color":94,"../AI/EnemyAI":100,"../AI/PlayerController":106,"../GameSystems/BattleManager":107,"../GameSystems/InventoryManager":108,"../GameSystems/items/Healthpack":109,"../GameSystems/items/Weapon":111,"../hw3_constants":121,"./GameOver":118}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hw3_Events = exports.hw3_Names = void 0;
var hw3_Names;
(function (hw3_Names) {
    hw3_Names["NAVMESH"] = "navmesh";
})(hw3_Names = exports.hw3_Names || (exports.hw3_Names = {}));
var hw3_Events;
(function (hw3_Events) {
    hw3_Events["SHOT_FIRED"] = "SHOT_FIRED";
})(hw3_Events = exports.hw3_Events || (exports.hw3_Events = {}));
},{}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const RegistryManager_1 = require("./Wolfie2D/Registry/RegistryManager");
const WeaponRegistry_1 = require("./hw3/Registry/WeaponRegistry");
const WeaponTypeRegistry_1 = require("./hw3/Registry/WeaponTypeRegistry");
const MainMenu_1 = require("./hw3/Scenes/MainMenu");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1200, y: 800 },
        clearColor: { r: 0.1, g: 0.1, b: 0.1 },
        inputs: [
            { name: "forward", keys: ["w"] },
            { name: "backward", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "pickup", keys: ["e"] },
            { name: "drop", keys: ["q"] },
            { name: "slot1", keys: ["1"] },
            { name: "slot2", keys: ["2"] }
        ],
        useWebGL: false,
        showDebug: false // Whether to show debug messages. You can change this to true if you want
    };
    // Set up custom registries
    let weaponTemplateRegistry = new WeaponRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTemplates", weaponTemplateRegistry);
    let weaponTypeRegistry = new WeaponTypeRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTypes", weaponTypeRegistry);
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(MainMenu_1.default, {});
})();
function runTests() { }
;
},{"./Wolfie2D/Loop/Game":33,"./Wolfie2D/Registry/RegistryManager":61,"./hw3/Registry/WeaponRegistry":116,"./hw3/Registry/WeaponTypeRegistry":117,"./hw3/Scenes/MainMenu":119}]},{},[122])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmMudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvbi50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXMudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGgudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaC50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9QaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QbGF5YmFjay9SZWNvcmRlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uVHlwZXMudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1F1YWRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9DYW52YXNOb2RlRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL1RpbGVtYXBGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvU291bmQvQXVkaW9NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXJNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0NvbG9yLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvR3JhcGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvUmVuZGVyaW5nVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvU3RyaW5nVXRpbHMudHMiLCJzcmMvaHczL0FJL0VuZW15QUkudHMiLCJzcmMvaHczL0FJL0VuZW15U3RhdGVzL0FsZXJ0LnRzIiwic3JjL2h3My9BSS9FbmVteVN0YXRlcy9BdHRhY2sudHMiLCJzcmMvaHczL0FJL0VuZW15U3RhdGVzL0VuZW15U3RhdGUudHMiLCJzcmMvaHczL0FJL0VuZW15U3RhdGVzL0d1YXJkLnRzIiwic3JjL2h3My9BSS9FbmVteVN0YXRlcy9QYXRyb2wudHMiLCJzcmMvaHczL0FJL1BsYXllckNvbnRyb2xsZXIudHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL0JhdHRsZU1hbmFnZXIudHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL0ludmVudG9yeU1hbmFnZXIudHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL2l0ZW1zL0hlYWx0aHBhY2sudHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL2l0ZW1zL0l0ZW0udHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvbi50cyIsInNyYy9odzMvR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvTGFzZXJHdW4udHMiLCJzcmMvaHczL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NlbWlBdXRvR3VuLnRzIiwic3JjL2h3My9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25UeXBlcy9TbGljZS50cyIsInNyYy9odzMvR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvV2VhcG9uVHlwZS50cyIsInNyYy9odzMvUmVnaXN0cnkvV2VhcG9uUmVnaXN0cnkudHMiLCJzcmMvaHczL1JlZ2lzdHJ5L1dlYXBvblR5cGVSZWdpc3RyeS50cyIsInNyYy9odzMvU2NlbmVzL0dhbWVPdmVyLnRzIiwic3JjL2h3My9TY2VuZXMvTWFpbk1lbnUudHMiLCJzcmMvaHczL1NjZW5lcy9odzNfc2NlbmUudHMiLCJzcmMvaHczL2h3M19jb25zdGFudHMudHMiLCJzcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDR0EsMENBQW1DO0FBRW5DOzs7R0FHRztBQUNILE1BQXFCLFNBQVM7SUFNN0I7UUFDQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsS0FBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FB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ZSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLHNCQUFzQixDQUFDLENBQUM7SUFFN0UsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLDRCQUFrQixFQUFFLENBQUM7SUFDbEQseUJBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUVyRSwyQ0FBMkM7SUFDM0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFL0IsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsRUFBRSxDQUFDO0FBRUwsU0FBUyxRQUFRLEtBQUcsQ0FBQztBQUFBLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgQWN0b3IgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuXG4vKipcbiAqIEEgbWFuYWdlciBjbGFzcyBmb3IgYWxsIG9mIHRoZSBBSSBpbiBhIHNjZW5lLlxuICogS2VlcHMgYSBsaXN0IG9mIHJlZ2lzdGVyZWQgYWN0b3JzIGFuZCBoYW5kbGVzIEFJIGdlbmVyYXRpb24gZm9yIGFjdG9ycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUlNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cdC8qKiBUaGUgYXJyYXkgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgKi9cblx0YWN0b3JzOiBBcnJheTxBY3Rvcj47XG5cdC8qKiBNYXBzIEFJIG5hbWVzIHRvIHRoZWlyIGNvbnN0cnVjdG9ycyAqL1xuXHRyZWdpc3RlcmVkQUk6IE1hcDxBSUNvbnN0cnVjdG9yPjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMuYWN0b3JzID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIGFjdG9yIHdpdGggdGhlIEFJTWFuYWdlclxuXHQgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIHJlZ2lzdGVyXG5cdCAqL1xuXHRyZWdpc3RlckFjdG9yKGFjdG9yOiBBY3Rvcik6IHZvaWQge1xuXHRcdHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xuXHR9XG5cblx0cmVtb3ZlQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XG5cdFx0bGV0IGluZGV4ID0gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3Rvcik7XG5cblx0XHRpZihpbmRleCAhPT0gLTEpe1xuXHRcdFx0dGhpcy5hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIEFJIHdpdGggdGhlIEFJTWFuYWdlciBmb3IgdXNlIGxhdGVyIG9uXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byByZWdpc3RlclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIEFJXG5cdCAqL1xuXHRyZWdpc3RlckFJKG5hbWU6IHN0cmluZywgY29uc3RyOiBuZXcgPFQgZXh0ZW5kcyBBST4oKSA9PiBUICk6IHZvaWQge1xuXHRcdHRoaXMucmVnaXN0ZXJlZEFJLmFkZChuYW1lLCBjb25zdHIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhbiBBSSBpbnN0YW5jZSBmcm9tIGl0cyBuYW1lXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byBhZGRcblx0ICogQHJldHVybnMgQSBuZXcgQUkgaW5zdGFuY2Vcblx0ICovXG5cdGdlbmVyYXRlQUkobmFtZTogc3RyaW5nKTogQUkge1xuXHRcdGlmKHRoaXMucmVnaXN0ZXJlZEFJLmhhcyhuYW1lKSl7XG5cdFx0XHRyZXR1cm4gbmV3ICh0aGlzLnJlZ2lzdGVyZWRBSS5nZXQobmFtZSkpKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IGBDYW5ub3QgY3JlYXRlIEFJIHdpdGggbmFtZSAke25hbWV9LCBubyBBSSB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkYDtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBSdW4gdGhlIGFpIGZvciBldmVyeSBhY3RpdmUgYWN0b3Jcblx0XHR0aGlzLmFjdG9ycy5mb3JFYWNoKGFjdG9yID0+IHsgaWYoYWN0b3IuYWlBY3RpdmUpIGFjdG9yLmFpLnVwZGF0ZShkZWx0YVQpIH0pO1xuXHR9XG59XG5cbnR5cGUgQUlDb25zdHJ1Y3RvciA9IG5ldyA8VCBleHRlbmRzIEFJPigpID0+IFQ7IiwiaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG4vKipcbiAqIEEgdmVyc2lvbiBvZiBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXSB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gd29yayBhcyBhbiBBSSBjb250cm9sbGVyIGZvciBhIEByZWZlcmVuY2VbR2FtZU5vZGVdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZUFJIGV4dGVuZHMgU3RhdGVNYWNoaW5lIGltcGxlbWVudHMgQUkge1xuXHQvKipcdFRoZSBHYW1lTm9kZSB0aGF0IHVzZXMgdGhpcyBTdGF0ZU1hY2hpbmUgZm9yIGl0cyBBSSAqL1xuXHRwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRpbml0aWFsaXplQUkob3duZXI6IEdhbWVOb2RlLCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlc3Ryb3koKXtcblx0XHQvLyBHZXQgcmlkIG9mIG91ciByZWZlcmVuY2UgdG8gdGhlIG93bmVyXG5cdFx0ZGVsZXRlIHRoaXMub3duZXI7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cbn0iLCIvLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgcGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIE5vIE9wZXJhdGlvbi4gRG9lcyBub3RoaW5nXG4gKi9cbmNvbnN0IE51bGxGdW5jID0gKCkgPT4ge307XG5cbmV4cG9ydCBkZWZhdWx0IE51bGxGdW5jOyIsIi8qKlxuICogQSBsaW5rZWQtbGlzdCBmb3IgdGhlIGVkZ2VzIGluIGEgQHJlZmVyZW5jZVtHcmFwaF0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcbiAgICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xuICAgIHk6IG51bWJlcjtcbiAgICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXG5cdHdlaWdodDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV4dCBFZGdlTm9kZSBpbiB0aGUgbGlua2VkLWxpc3QgKi9cbiAgICBuZXh0OiBFZGdlTm9kZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRWRnZU5vZGVcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRoaXMgZWRnZSBjb25uZWN0cyB0b1xuICAgICAqIEBwYXJhbSB3ZWlnaHQgVGhlIHdlaWdodCBvZiB0aGlzIGVkZ2VcbiAgICAgKi9cblx0Y29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKXtcblx0XHR0aGlzLnkgPSBpbmRleDtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ID8gd2VpZ2h0IDogMTtcblx0fVxufSIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xuXG5leHBvcnQgY29uc3QgTUFYX1YgPSAxMDA7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBncmFwaCBkYXRhIHN0cnVjdHVyZSB1c2luZyBlZGdlIGxpc3RzLiBJbnNwaXJlZCBieSBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcblx0LyoqIEFuIGFycmF5IG9mIGVkZ2VzIGF0IHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZGVncmVlOiBBcnJheTxudW1iZXI+O1xuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cblx0bnVtVmVydGljZXM6IG51bWJlcjtcblx0LyoqIFRoZSBudW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoICovXG5cdG51bUVkZ2VzOiBudW1iZXI7XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cblx0ZGlyZWN0ZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHRoaXMuZGlyZWN0ZWQgPSBkaXJlY3RlZDtcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLm51bVZlcnRpY2VzID0gMDtcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcblxuXHRcdHRoaXMuZWRnZXMgPSBuZXcgQXJyYXkoTUFYX1YpO1xuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXG5cdCovXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcblx0XHR0aGlzLm51bVZlcnRpY2VzKys7XG5cdFx0cmV0dXJuIHRoaXMubnVtVmVydGljZXM7XG5cdH1cblxuXHQvKiogQWRkcyBhbiBlZGdlIGJldHdlZW4gbm9kZSB4IGFuZCB5LCB3aXRoIGFuIG9wdGlvbmFsIHdlaWdodFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB5IFRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB3ZWlnaHQgVGhlIG9wdGlvbmFsIHdlaWdodCBvZiB0aGUgbmV3IGVkZ2Vcblx0Ki9cblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKTogdm9pZCB7XG5cdFx0bGV0IGVkZ2UgPSBuZXcgRWRnZU5vZGUoeSwgd2VpZ2h0KTtcblxuXG5cblx0XHRpZih0aGlzLmVkZ2VzW3hdKXtcblx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeF07XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZWRnZXNbeF0gPSBlZGdlO1xuXG5cdFx0aWYoIXRoaXMuZGlyZWN0ZWQpe1xuXHRcdFx0ZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xuXG5cdFx0XHRpZih0aGlzLmVkZ2VzW3ldKXtcblx0XHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t5XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5lZGdlc1t5XSA9IGVkZ2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5udW1FZGdlcyArPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhbiBlZGdlIGV4aXN0cyBiZXR3ZWVuIHR3byBub2Rlcy5cblx0ICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXG5cdCAqIEBwYXJhbSB4IFRoZSBmaXJzdCBub2RlXG5cdCAqIEBwYXJhbSB5IFRoZSBzZWNvbmQgbm9kZVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGVkZ2VFeGlzdHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XG5cblx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcblx0XHRcdGlmKGVkZ2UueSA9PT0geSl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZWRnZSBsaXN0IGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcblx0ICovXG5cdGdldEVkZ2VzKHg6IG51bWJlcik6IEVkZ2VOb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5lZGdlc1t4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkZWdyZWUgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICovXG5cdGdldERlZ3JlZSh4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmRlZ3JlZVt4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY29udmVydCB0byBhIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlOiBcIk5vZGUgeFwiXG5cdCAqL1xuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcblx0ICogQHJldHVybnMgVGhlIGdyYXBoIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdGxldCByZXR2YWwgPSBcIlwiO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmVydGljZXM7IGkrKyl7XG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cdFx0XHRsZXQgZWRnZVN0ciA9IFwiXCI7XG5cdFx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcblx0XHRcdFx0ZWRnZVN0ciArPSBlZGdlLnkudG9TdHJpbmcoKTtcblx0XHRcdFx0aWYodGhpcy53ZWlnaHRlZCl7XG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiAoXCIgKyBlZGdlLndlaWdodCArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGVkZ2UubmV4dCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiwgXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG59IiwiaW1wb3J0IEdyYXBoLCB7IE1BWF9WIH0gZnJvbSBcIi4vR3JhcGhcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiBHcmFwaCB0aGF0IGhhcyBub2RlcyB3aXRoIHBvc2l0aW9ucyBpbiAyRCBzcGFjZS5cbiAqIFRoaXMgaXMgYSB3ZWlnaHRlZCBncmFwaCAodGhvdWdoIG5vdCBpbmhlcmVudGx5IGRpcmVjdGQpXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25HcmFwaCBleHRlbmRzIEdyYXBoIGltcGxlbWVudHMgRGVidWdSZW5kZXJhYmxlIHtcblx0LyoqIEFuIGFycmF5IG9mIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGluIHRoaXMgZ3JhcGggKi9cblx0cG9zaXRpb25zOiBBcnJheTxWZWMyPjtcblxuXHQvKipcblx0ICogQ3JlYXRlZXMgYSBuZXcgUG9zaXRpb25HcmFwaFxuXHQgKiBAcGFyYW0gZGlyZWN0ZWQgV2hldGhlciBvciBub3QgdGhpcyBncmFwaCBpcyBkaXJlY3RlZFxuXHQgKi9cblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XG5cdFx0c3VwZXIoZGlyZWN0ZWQpO1xuXHRcdHRoaXMucG9zaXRpb25zID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcblx0ICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSB0byBhZGRcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBub2RlXG5cdCAqL1xuXHRhZGRQb3NpdGlvbmVkTm9kZShwb3NpdGlvbjogVmVjMik6IG51bWJlciB7XG5cdFx0dGhpcy5wb3NpdGlvbnNbdGhpcy5udW1WZXJ0aWNlc10gPSBwb3NpdGlvbjtcblx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYSBub2RlLlxuXHQgKiBBdXRvbWF0aWNhbGx5IGFkanVzdHMgdGhlIHdlaWdodHMgb2YgdGhlIGdyYXBoIHRpZWQgdG8gdGhpcyBub2RlLlxuXHQgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBub2RlXG5cdCAqL1xuXHRzZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlciwgcG9zaXRpb246IFZlYzIpOiB2b2lkIHtcblx0XHR0aGlzLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcblxuXHRcdC8vIFJlY2FsY3VsYXRlIGFsbCB3ZWlnaHRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZGV4XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtRWRnZXM7IGkrKyl7XG5cblx0XHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblxuXHRcdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XG5cdFx0XHRcdC8vIElmIHRoaXMgbm9kZSBpcyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZWRnZSwgcmVjYWxjdWxhdGUgd2VpZ2h0XG5cdFx0XHRcdGlmKGkgPT09IGluZGV4IHx8IGVkZ2UueSA9PT0gaW5kZXgpe1xuXHRcdFx0XHRcdGVkZ2Uud2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbaV0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1tlZGdlLnldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEByZXR1cm5zIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuXHQgKi9cblx0Z2V0Tm9kZVBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5wb3NpdGlvbnNbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gZWRnZSB0byB0aGlzIGdyYXBoIGJldHdlZW4gbm9kZSB4IGFuZCB5LlxuXHQgKiBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZXMgdGhlIHdlaWdodCBvZiB0aGUgZWRnZSBhcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbm9kZXMuXG5cdCAqIEBwYXJhbSB4IFRoZSBiZWdpbm5pbmcgb2YgdGhlIGVkZ2Vcblx0ICogQHBhcmFtIHkgVGhlIGVuZCBvZiB0aGUgZWRnZVxuXHQgKi9cblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xuXHRcdGlmKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pe1xuXHRcdFx0dGhyb3cgXCJDYW4ndCBhZGQgZWRnZSB0byB1bi1wb3NpdGlvbmVkIG5vZGUhXCI7XG5cdFx0fVxuXG5cdFx0Ly8gV2VpZ2h0IGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlc1xuXHRcdGxldCB3ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1t4XS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW3ldKTtcblxuXHRcdHN1cGVyLmFkZEVkZ2UoeCwgeSwgd2VpZ2h0KTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleCArIFwiIC0gXCIgKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0udG9TdHJpbmcoKTtcblx0fVxuXG5cdGRlYnVnUmVuZGVyID0gKCk6IHZvaWQgPT4ge1xuXHRcdC8vIGZvcihsZXQgcG9pbnQgb2YgdGhpcy5wb3NpdGlvbnMpe1xuXHRcdC8vIFx0Y3R4LmZpbGxSZWN0KChwb2ludC54IC0gb3JpZ2luLnggLSA0KSp6b29tLCAocG9pbnQueSAtIG9yaWdpbi55IC0gNCkqem9vbSwgOCwgOCk7XG5cdFx0Ly8gfVxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xuXG4vKiogQW4gb2JqZWN0IHRoYXQgaXMgYSByZWdpb24sIHdpdGggYSBzaXplLCBzY2FsZSwgYW5kIGJvdW5kYXJ5LiAqL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LiAqL1xuICAgIHNpemU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHNjYWxlIG9mIHRoaXMgb2JqZWN0LiAqL1xuICAgIHNjYWxlOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gYWNjb3VudCB0aGUgem9vbSBhbmQgc2NhbGUgKi9cbiAgICByZWFkb25seSBzaXplV2l0aFpvb206IFZlYzI7XG5cbiAgICAvKiogVGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBib3VuZGFyeTogQUFCQjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnaW9uKGFyZzogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBc3NvY2lhdGVzIHN0cmluZ3Mgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG5cdHByaXZhdGUgbWFwOiBSZWNvcmQ8c3RyaW5nLCBUPjtcblxuXHQvKiogQ3JlYXRlcyBhIG5ldyBtYXAgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLm1hcCA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSB2YWx1ZSBUIHN0b3JlZCBhdCBhIGtleS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqL1xuXHRhZGQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XG5cdFx0dGhpcy5tYXBba2V5XSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5LlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW1cblx0ICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGtleSBvciB1bmRlZmluZWRcblx0ICovXG5cdGdldChrZXk6IHN0cmluZyk6IFQge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGFsaWFzIG9mIGFkZC4gU2V0cyB0aGUgdmFsdWUgc3RvcmVkIGF0IGtleSB0byB0aGUgbmV3IHNwZWNpZmllZCB2YWx1ZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgaXRlbSB0byBiZSBzdG9yZWRcblx0ICovXG5cdHNldChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcblx0XHR0aGlzLmFkZChrZXksIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBrZXksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGNoZWNrXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGUgZ2l2ZW4ga2V5LlxuXHQgKi9cblx0aGFzKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMubWFwW2tleV0gIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyBpbiB0aGlzIG1hcC5cblx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwga2V5cyBpbiB0aGUgbWFwLlxuXHQgKi9cblx0a2V5cygpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuXHR9XG5cdFxuXHQvLyBAaW1wbGVtZW50ZWRcblx0Zm9yRWFjaChmdW5jOiAoa2V5OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcblx0XHRPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGFuIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEga2V5XG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBhdCB3aGljaCB0byBkZWxldGUgYW4gaXRlbVxuXHQgKi9cblx0ZGVsZXRlKGtleTogc3RyaW5nKTogdm9pZCB7XG5cdFx0ZGVsZXRlIHRoaXMubWFwW2tleV07XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0Y2xlYXIoKTogdm9pZCB7XG5cdFx0dGhpcy5mb3JFYWNoKGtleSA9PiBkZWxldGUgdGhpcy5tYXBba2V5XSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdGxldCBzdHIgPSBcIlwiO1xuXG5cdFx0dGhpcy5mb3JFYWNoKChrZXkpID0+IHN0ciArPSBrZXkgKyBcIiAtPiBcIiArIHRoaXMuZ2V0KGtleSkudG9TdHJpbmcoKSArIFwiXFxuXCIpO1xuXG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuL1ZlYzJcIjtcblxuLyoqIEEgNHg0IG1hdHJpeDAgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdDR4NCB7XG5cdHByaXZhdGUgbWF0OiBGbG9hdDMyQXJyYXk7XG5cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLm1hdCA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMFxuXHRcdF0pO1xuXHR9XG5cblx0Ly8gU3RhdGljIG1lbWJlcnNcblx0c3RhdGljIGdldCBJREVOVElUWSgpOiBNYXQ0eDQge1xuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuaWRlbnRpdHkoKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgWkVSTygpOiBNYXQ0eDQge1xuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuemVybygpO1xuXHR9XG5cblx0Ly8gQWNjZXNzb3JzXG5cdHNldCBfMDAoeDogbnVtYmVyKSB7XG5cdFx0dGhpcy5tYXRbMF0gPSB4O1xuXHR9XG5cblx0c2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0aWYoY29sIDwgMCB8fCBjb2wgPiAzIHx8IHJvdyA8IDAgfHwgcm93ID4gMyl7XG5cdFx0XHR0aHJvdyBgRXJyb3IgLSBpbmRleCAoJHtjb2x9LCAke3Jvd30pIGlzIG91dCBvZiBib3VuZHMgZm9yIE1hdDR4NGBcblx0XHR9XG5cdFx0dGhpcy5tYXRbcm93KjQgKyBjb2xdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLm1hdFtyb3cqNCArIGNvbF07XG5cdH1cblxuXHRzZXRBbGwoLi4uaXRlbXM6IEFycmF5PG51bWJlcj4pOiBNYXQ0eDQge1xuXHRcdHRoaXMubWF0LnNldChpdGVtcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpZGVudGl0eSgpOiBNYXQ0eDQge1xuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpXG5cdH1cblxuXHR6ZXJvKCk6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcblx0ICogQHBhcmFtIHpSYWRpYW5zIFRoZSBudW1iZXIgb2YgcmFkaWFucyB0byByb3RhdGVcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcblx0ICovXG5cdHJvdGF0ZSh6UmFkaWFuczogbnVtYmVyKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHRNYXRoLmNvcyh6UmFkaWFucyksIC1NYXRoLnNpbih6UmFkaWFucyksIFx0MCwgMCxcblx0XHRcdE1hdGguc2luKHpSYWRpYW5zKSwgTWF0aC5jb3MoelJhZGlhbnMpLCBcdDAsIDAsXG5cdFx0XHQwLCBcdFx0XHRcdFx0MCwgXHRcdFx0XHRcdFx0MSwgMCxcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQwLCAxXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUdXJucyB0aGlzIE1hdDR4NCBpbnRvIGEgdHJhbnNsYXRpb24gbWF0cml4IG9mIHRoZSBzcGVjaWZpZWQgdHJhbnNsYXRpb25cblx0ICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiBpbiB4IGFuZCB5XG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XG5cdCAqL1xuXHR0cmFuc2xhdGUodHJhbnNsYXRpb246IFZlYzIgfCBGbG9hdDMyQXJyYXkpOiBNYXQ0eDQge1xuXHRcdC8vIElmIHRyYW5zbGF0aW9uIGlzIGEgdmVjLCBnZXQgaXRzIGFycmF5XG5cdFx0aWYodHJhbnNsYXRpb24gaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDEsIDAsIDAsIHRyYW5zbGF0aW9uWzBdLFxuXHRcdFx0MCwgMSwgMCwgdHJhbnNsYXRpb25bMV0sXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cdH1cblxuXHRzY2FsZShzY2FsZTogVmVjMiB8IEZsb2F0MzJBcnJheSB8IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlIGlzIGEgZmxvYXQzMkFycmF5XG5cdFx0aWYoc2NhbGUgaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHNjYWxlID0gc2NhbGUudG9BcnJheSgpO1xuXHRcdH0gZWxzZSBpZighKHNjYWxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSl7XG5cdFx0XHRzY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoW3NjYWxlLCBzY2FsZV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdHNjYWxlWzBdLCAwLCBcdFx0MCwgMCxcblx0XHRcdDAsIFx0XHQgIHNjYWxlWzFdLCAwLCAwLFxuXHRcdFx0MCwgXHRcdCAgMCxcdFx0MSwgMCxcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDAsIDFcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgTWF0NHg0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmlnaHQgc2lkZSBtdWx0aXBsaWNhdGlvbiBUSElTIHggT1RIRVJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBNYXQ0eDQgdG8gbXVsdGlwbHkgYnlcblx0ICogQHJldHVybnMgYSBuZXcgTWF0NHg0IGNvbnRhaW5pbmcgdGhlIHByb2R1Y3Qgb2YgdGhlc2UgdHdvIE1hdDR4NHNcblx0ICovXG5cdG11bHQob3RoZXI6IE1hdDR4NCwgb3V0PzogTWF0NHg0KTogTWF0NHg0IHtcblx0XHRsZXQgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgNDsgaisrKXtcblx0XHRcdFx0bGV0IHZhbHVlID0gMDtcblx0XHRcdFx0Zm9yKGxldCBrID0gMDsgayA8IDQ7IGsrKyl7XG5cdFx0XHRcdFx0dmFsdWUgKz0gdGhpcy5nZXQoaywgaSkgKiBvdGhlci5nZXQoaiwgayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcFtqKjQgKyBpXSAgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihvdXQgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRyZXR1cm4gb3V0LnNldEFsbCguLi50ZW1wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5zZXRBbGwoLi4udGVtcCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgYWxsIGdpdmVuIG1hdHJpY2llcyBpbiBvcmRlci4gZS5nLiBNVUxUKEEsIEIsIEMpIC0+IEEqQipDXG5cdCAqIEBwYXJhbSBtYXRzIEEgbGlzdCBvZiBNYXQ0eDRzIHRvIG11bHRpcGx5IGluIG9yZGVyXG5cdCAqIEByZXR1cm5zIEEgbmV3IE1hdDR4NCBob2xkaW5nIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuXHQgKi9cblx0c3RhdGljIE1VTFQoLi4ubWF0czogQXJyYXk8TWF0NHg0Pik6IE1hdDR4NCB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGFycmF5XG5cdFx0bGV0IHRlbXAgPSBNYXQ0eDQuSURFTlRJVFk7XG5cblx0XHQvLyBNdWx0aXBseSBieSBldmVyeSBhcnJheSBpbiBvcmRlciwgaW4gcGxhY2Vcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgbWF0cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR0ZW1wLm11bHQobWF0c1tpXSwgdGVtcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlbXA7XG5cdH1cblxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIHRoaXMubWF0O1xuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gIGB8JHt0aGlzLm1hdFswXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFszXS50b0ZpeGVkKDIpfXxcXG5gICsgXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs1XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs2XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs3XS50b0ZpeGVkKDIpfXxcXG5gICtcblx0XHRcdFx0YHwke3RoaXMubWF0WzhdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzldLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEwXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxMV0udG9GaXhlZCgyKX18XFxuYCArXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFsxMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTNdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzE0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNV0udG9GaXhlZCgyKX18YDtcblx0fVxufSIsImltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEhpdCBmcm9tIFwiLi9IaXRcIjtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY29udGFpbnMgdGhlIGFyZWEgb2Ygb3ZlcmxhcCBvZiB0d28gY29sbGlkaW5nIG9iamVjdHMgdG8gYWxsb3cgZm9yIHNvcnRpbmcgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmVhQ29sbGlzaW9uIHtcbiAgICAvKiogVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgZm9yIHRoZSBjb2xsaWRpbmcgb2JqZWN0cyAqL1xuICAgIGFyZWE6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgQUFCQiBvZiB0aGUgb3RoZXIgY29sbGlkZXIgaW4gdGhpcyBjb2xsaXNpb24gKi9cbiAgICBjb2xsaWRlcjogQUFCQjtcblxuICAgIC8qKiBUeXBlIG9mIHRoZSBjb2xsaXNpb24gKi9cbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlciBvdGhlciBvYmplY3QgaW4gdGhlIGNvbGxpc2lvbiAqL1xuICAgIG90aGVyOiBQaHlzaWNhbDtcblxuICAgIC8qKiBUaGUgdGlsZSwgaWYgdGhpcyB3YXMgYSB0aWxlbWFwIGNvbGxpc2lvbiAqL1xuICAgIHRpbGU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHBoeXNpY3MgaGl0IGZvciB0aGlzIG9iamVjdCAqL1xuICAgIGhpdDogSGl0O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBcmVhQ29sbGlzaW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSBhcmVhIFRoZSBhcmVhIG9mIHRoZSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIgVGhlIG90aGVyIGNvbGxpZGVyXG4gICAgICovXG5cdGNvbnN0cnVjdG9yKGFyZWE6IG51bWJlciwgY29sbGlkZXI6IEFBQkIsIG90aGVyOiBQaHlzaWNhbCwgdHlwZTogc3RyaW5nLCB0aWxlOiBWZWMyKXtcblx0XHR0aGlzLmFyZWEgPSBhcmVhO1xuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50aWxlID0gdGlsZTtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGF0YSBjb2xsZWN0ZWQgZnJvbSBhIHBoeXNpY3MgaGl0IGJldHdlZW4gdHdvIGdlb21ldHJpYyBvYmplY3RzLlxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXQge1xuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgY29sbGlzaW9uLiBPbmx5IG51bWJlcnMgMCB0aHJvdWdoIDEgaGFwcGVuIGluIHRoaXMgZnJhbWUuICovXG4gICAgdGltZTogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmVhciB0aW1lcyBvZiB0aGUgY29sbGlzaW9uICovXG4gICAgbmVhclRpbWVzOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpc2lvbiAqL1xuICAgIHBvczogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIG92ZXJsYXAgZGlzdGFuY2Ugb2YgdGhlIGhpdCAqL1xuICAgIGRlbHRhOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgIC8qKiBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgaGl0ICovXG4gICAgbm9ybWFsOiBWZWMyID0gVmVjMi5aRVJPO1xufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIEZJRk8gcXVldWUgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWU8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX0VMRU1FTlRTOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgcTogQXJyYXk8VD47XG4gICAgXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgaGVhZDogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGFpbCBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIHRhaWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXG4gICAgcHJpdmF0ZSBzaXplOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHF1ZXVlXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHM6IG51bWJlciA9IDEwMCl7XG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XG4gICAgICAgIHRoaXMucSA9IG5ldyBBcnJheSh0aGlzLk1BWF9FTEVNRU5UUyk7XG4gICAgICAgIHRoaXMuaGVhZCA9IDA7XG4gICAgICAgIHRoaXMudGFpbCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZVxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBlbnF1ZXVlKGl0ZW06IFQpOiB2b2lke1xuICAgICAgICBpZigodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUyA9PT0gdGhpcy5oZWFkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpemUgKz0gMTtcbiAgICAgICAgdGhpcy5xW3RoaXMudGFpbF0gPSBpdGVtO1xuICAgICAgICB0aGlzLnRhaWwgPSAodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgZGVxdWV1ZSgpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSB0aGlzLnRhaWwpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMucVt0aGlzLmhlYWRdO1xuICAgICAgICAvLyBOb3cgZGVsZXRlIHRoZSBpdGVtXG4gICAgICAgIGRlbGV0ZSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgdGhpcy5oZWFkID0gKHRoaXMuaGVhZCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXRcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgcGVla05leHQoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcbiAgICAgICAgICAgIHRocm93IFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIlxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgcXVldWUgaGFzIGl0ZW1zXG4gICAgICovXG4gICAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgIT09IHRoaXMudGFpbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIGdldFNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMucVtpbmRleF0pO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWw7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgZm9yRWFjaChmdW5jOiAoaXRlbTogVCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlKGkgIT09IHRoaXMudGFpbCl7XG4gICAgICAgICAgICBmdW5jKHRoaXMucVtpXSwgaSk7XG4gICAgICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBxdWV1ZSBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHF1ZXVlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHZhbCA9IHN0ciArIHJldHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFwiVG9wIC0+IFwiICsgcmV0dmFsO1xuICAgIH1cbn0iLCIvKiogQSBjb250YWluZXIgZm9yIGluZm8gYWJvdXQgYSB3ZWJHTCBzaGFkZXIgcHJvZ3JhbSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xQcm9ncmFtVHlwZSB7XG5cdC8qKiBBIHdlYkdMIHByb2dyYW0gKi9cblx0cHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuXHRcblx0LyoqIEEgdmVydGV4IHNoYWRlciAqL1xuXHR2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xuXG5cdC8qKiBBIGZyYWdtZW50IHNoYWRlciAqL1xuXHRmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgdGhpcyBzaGFkZXIgcHJvZ3JhbVxuXHQgKi9cblx0ZGVsZXRlKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcblx0XHQvLyBDbGVhbiB1cCBhbGwgYXNwZWN0cyBvZiB0aGlzIHByb2dyYW1cblx0XHRpZih0aGlzLnByb2dyYW0pe1xuXHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXHRcdH1cblx0XHRcdFxuXHRcdGlmKHRoaXMudmVydGV4U2hhZGVyKXtcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5mcmFnbWVudFNoYWRlcil7XG5cdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnbWVudFNoYWRlcik7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFNoYXBlIGZyb20gXCIuL1NoYXBlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL0NpcmNsZVwiO1xuaW1wb3J0IEhpdCBmcm9tIFwiLi4vUGh5c2ljcy9IaXRcIjtcblxuLyoqXG4gKiBBbiBBeGlzLUFsaWduZWQgQm91bmRpbmcgQm94LiBJbiBvdGhlciB3b3JkcywgYSByZWN0YW5nbGUgdGhhdCBpcyBhbHdheXMgYWxpZ25lZCB0byB0aGUgeC15IGdyaWQuXG4gKiBJbnNwaXJlZCBieSB0aGUgaGVscGZ1bCBjb2xsaXNpb24gZG9jdW1lbnRhdGlvbiBAbGluayhoZXJlKShodHRwczovL25vb25hdC5naXRodWIuaW8vaW50ZXJzZWN0LykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFBQkIgZXh0ZW5kcyBTaGFwZSB7XG4gICAgY2VudGVyOiBWZWMyO1xuICAgIGhhbGZTaXplOiBWZWMyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBQUJCXG4gICAgICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBBQUJCXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmIHNpemUgb2YgdGhlIEFBQkIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIGFuIGVkZ2UgaW4geCBhbmQgeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNlbnRlcj86IFZlYzIsIGhhbGZTaXplPzogVmVjMil7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2VudGVyID0gY2VudGVyID8gY2VudGVyIDogbmV3IFZlYzIoMCwgMCk7XG4gICAgICAgIHRoaXMuaGFsZlNpemUgPSBoYWxmU2l6ZSA/IGhhbGZTaXplIDogbmV3IFZlYzIoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xuICAgIGdldCB0b3BMZWZ0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5sZWZ0LCB0aGlzLnRvcClcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xuICAgIGdldCB0b3BSaWdodCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMudG9wKVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgYm90dG9tTGVmdCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy5ib3R0b20pXG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgYm90dG9tUmlnaHQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSlcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLm1heCh0aGlzLmh3LCB0aGlzLmhoKVxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmNlbnRlci5jbG9uZSgpLCByKTtcbiAgICB9XG5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIHNldEhhbGZTaXplKGhhbGZTaXplOiBWZWMyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGFsZlNpemUgPSBoYWxmU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gbW92ZSB0aGVzZSBhbGwgdG8gdGhlIFNoYXBlIGNsYXNzXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcbiAgICAgICAgICAgICYmIHBvaW50LnkgPj0gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGludGVyc2VjdFBvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkeCA9IHBvaW50LnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgLSBNYXRoLmFicyhkeCk7XG4gICAgICAgIFxuICAgICAgICBpZihweCA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkeSA9IHBvaW50LnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgaWYocHkgPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludCB3aXRoIHNvZnQgbGVmdCBhbmQgdG9wIGJvdW5kYXJpZXMuXG4gICAgICogSW4gb3RoZXIgd29yZHMsIGlmIHRoZSB0b3AgbGVmdCBpcyAoMCwgMCksIHRoZSBwb2ludCAoMCwgMCkgaXMgbm90IGluIHRoZSBBQUJCXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnRTb2Z0KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwb2ludC54ID4gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcbiAgICAgICAgICAgICYmIHBvaW50LnkgPiB0aGlzLnkgLSB0aGlzLmhoICYmIHBvaW50LnkgPD0gdGhpcy55ICsgdGhpcy5oaFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBBQUJCIHdpdGggYSBsaW5lIHNlZ21lbnQgZnJvbSBhIHBvaW50IGluIGEgZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0aGF0IHRoZSBsaW5lIHNlZ21lbnQgc3RhcnRzIGZyb21cbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2Ugb2YgdGhlIHNlZ21lbnRcbiAgICAgKiBAcGFyYW0gcGFkZGluZyBQYWRzIHRoZSBBQUJCIHRvIG1ha2UgaXQgd2lkZXIgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdFxuICAgICAqIEByZXR1cm5zIFRoZSBIaXQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uLCBvciBudWxsIGlmIHRoZXJlIHdhcyBubyBpbnRlcnNlY3Rpb25cbiAgICAgKi9cbiAgICBpbnRlcnNlY3RTZWdtZW50KHBvaW50OiBWZWMyLCBkZWx0YTogVmVjMiwgcGFkZGluZz86IFZlYzIpOiBIaXQge1xuICAgICAgICBsZXQgcGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZy54IDogMDtcbiAgICAgICAgbGV0IHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmcueSA6IDA7XG5cbiAgICAgICAgbGV0IHNjYWxlWCA9IDEvZGVsdGEueDtcbiAgICAgICAgbGV0IHNjYWxlWSA9IDEvZGVsdGEueTtcblxuICAgICAgICBsZXQgc2lnblggPSBNYXRoVXRpbHMuc2lnbihzY2FsZVgpO1xuICAgICAgICBsZXQgc2lnblkgPSBNYXRoVXRpbHMuc2lnbihzY2FsZVkpO1xuXG4gICAgICAgIGxldCB0bmVhcnggPSBzY2FsZVgqKHRoaXMueCAtIHNpZ25YKih0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XG4gICAgICAgIGxldCB0bmVhcnkgPSBzY2FsZVkqKHRoaXMueSAtIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XG4gICAgICAgIGxldCB0ZmFyeCA9IHNjYWxlWCoodGhpcy54ICsgc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcbiAgICAgICAgbGV0IHRmYXJ5ID0gc2NhbGVZKih0aGlzLnkgKyBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xuICAgICAgICBcbiAgICAgICAgaWYodG5lYXJ4ID4gdGZhcnkgfHwgdG5lYXJ5ID4gdGZhcngpe1xuICAgICAgICAgICAgLy8gV2UgYXJlbid0IGNvbGxpZGluZyAtIHdlIGNsZWFyIG9uZSBheGlzIGJlZm9yZSBpbnRlcnNlY3RpbmcgYW5vdGhlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG5lYXIgPSBNYXRoLm1heCh0bmVhcngsIHRuZWFyeSk7XG5cbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIGZvciBOYU5zXG4gICAgICAgIGlmKHRuZWFyeCAhPT0gdG5lYXJ4KXtcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKHRuZWFyeSAhPT0gdG5lYXJ5KXtcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ4O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRmYXIgPSBNYXRoLm1pbih0ZmFyeCwgdGZhcnkpO1xuXG4gICAgICAgIGlmKHRuZWFyID09PSAtSW5maW5pdHkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0bmVhciA+PSAxIHx8IHRmYXIgPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFyZSBjb2xsaWRpbmdcbiAgICAgICAgbGV0IGhpdCA9IG5ldyBIaXQoKTtcbiAgICAgICAgaGl0LnRpbWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh0bmVhcik7XG4gICAgICAgIGhpdC5uZWFyVGltZXMueCA9IHRuZWFyeDtcbiAgICAgICAgaGl0Lm5lYXJUaW1lcy55ID0gdG5lYXJ5O1xuXG4gICAgICAgIGlmKHRuZWFyeCA+IHRuZWFyeSl7XG4gICAgICAgICAgICAvLyBXZSBoaXQgb24gdGhlIGxlZnQgb3IgcmlnaHQgc2l6ZVxuICAgICAgICAgICAgaGl0Lm5vcm1hbC54ID0gLXNpZ25YO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKE1hdGguYWJzKHRuZWFyeCAtIHRuZWFyeSkgPCAwLjAwMDEpe1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBjb3JuZXJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IC1zaWduWTtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoaXQgb24gdGhlIHRvcCBvciBib3R0b21cbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IDA7XG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XG4gICAgICAgIH1cblxuICAgICAgICBoaXQuZGVsdGEueCA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueDtcbiAgICAgICAgaGl0LmRlbHRhLnkgPSAoMS4wIC0gaGl0LnRpbWUpICogLWRlbHRhLnk7XG4gICAgICAgIGhpdC5wb3MueCA9IHBvaW50LnggKyBkZWx0YS54ICogaGl0LnRpbWU7XG4gICAgICAgIGhpdC5wb3MueSA9IHBvaW50LnkgKyBkZWx0YS55ICogaGl0LnRpbWU7XG5cbiAgICAgICAgcmV0dXJuIGhpdDtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcbiAgICAgICAgaWYob3RoZXIgaW5zdGFuY2VvZiBBQUJCKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXBzQUFCQihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgXCJPdmVybGFwIG5vdCBkZWZpbmVkIGJldHdlZW4gdGhlc2Ugc2hhcGVzLlwiXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBvdmVybGFwcyBhbm90aGVyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgQUFCQiBvdmVybGFwcyB0aGUgb3RoZXIsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvdmVybGFwc0FBQkIob3RoZXI6IEFBQkIpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xuICAgICAgICBcbiAgICAgICAgaWYocHggPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgaWYocHkgPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgY29sbGlzaW9uIHNpZGVzIHN0b3JlZCBpbiBhIFZlYzIgaWYgdGhlIEFBQkJzIGFyZSB0b3VjaGluZywgbnVsbCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0b3VjaGVzQUFCQihvdGhlcjogQUFCQik6IFZlYzIge1xuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XG5cbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIC8vIElmIG9uZSBheGlzIGlzIGp1c3QgdG91Y2hpbmcgYW5kIHRoZSBvdGhlciBpcyBvdmVybGFwcGluZywgdHJ1ZVxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPj0gMCkgfHwgKHB5ID09PSAwICYmIHB4ID49IDApKXtcbiAgICAgICAgICAgIGxldCByZXQgPSBuZXcgVmVjMigpO1xuXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgcmV0LnggPSBvdGhlci54IDwgdGhpcy54ID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihweSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXG4gICAgICogQWxzbywgaWYgdGhleSBhcmUgb25seSB0b3VjaGluZyBjb3JuZXJzLCB0aGV5IGFyZSBjb25zaWRlcmVkIG5vdCB0b3VjaGluZy5cbiAgICAgKiBWZWMyLnggaXMgLTEgaWYgdGhlIG90aGVyIGlzIHRvIHRoZSBsZWZ0LCAxIGlmIHRvIHRoZSByaWdodC5cbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRoZSBzaWRlIG9mIHRoZSB0b3VjaCwgc3RvcmVkIGFzIGEgVmVjMiwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyB0b3VjaFxuICAgICAqL1xuICAgIHRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMob3RoZXI6IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xuXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyB0b3VjaGluZywgYW5kIHRoZSBvdGhlciBpcyBzdHJpY3RseSBvdmVybGFwcGluZ1xuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPiAwKSB8fCAocHkgPT09IDAgJiYgcHggPiAwKSl7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcblxuICAgICAgICAgICAgaWYocHggPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGlzIEFBQkIgYW5kIGFub3RoZXJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBiZXR3ZWVuIHRoZSBBQUJCc1xuICAgICAqL1xuICAgIG92ZXJsYXBBcmVhKG90aGVyOiBBQUJCKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGxlZnR4ID0gTWF0aC5tYXgodGhpcy54IC0gdGhpcy5odywgb3RoZXIueCAtIG90aGVyLmh3KTtcbiAgICAgICAgbGV0IHJpZ2h0eCA9IE1hdGgubWluKHRoaXMueCArIHRoaXMuaHcsIG90aGVyLnggKyBvdGhlci5odyk7XG4gICAgICAgIGxldCBkeCA9IHJpZ2h0eCAtIGxlZnR4O1xuXG4gICAgICAgIGxldCBsZWZ0eSA9IE1hdGgubWF4KHRoaXMueSAtIHRoaXMuaGgsIG90aGVyLnkgLSBvdGhlci5oaCk7XG4gICAgICAgIGxldCByaWdodHkgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhoLCBvdGhlci55ICsgb3RoZXIuaGgpO1xuICAgICAgICBsZXQgZHkgPSByaWdodHkgLSBsZWZ0eTtcblxuICAgICAgICBpZihkeCA8IDAgfHwgZHkgPCAwKSByZXR1cm4gMDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkeCpkeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbmQgcmVzaXplcyB0aGlzIHJlY3QgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiB0byB0aGUgcG9zaXRpb24gc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHZlbG9jaXR5IFRoZSBtb3ZlbWVudCBvZiB0aGUgcmVjdCBmcm9tIGl0cyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBmcm9tUG9zaXRpb24gQSBwb3NpdGlvbiBzcGVjaWZpZWQgdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHN3ZWVwaW5nXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmU2l6ZSBvZiB0aGUgc3dlZXBpbmcgcmVjdCBcbiAgICAgKi9cbiAgICBzd2VlcCh2ZWxvY2l0eTogVmVjMiwgZnJvbVBvc2l0aW9uPzogVmVjMiwgaGFsZlNpemU/OiBWZWMyKTogdm9pZCB7XG4gICAgICAgIGlmKCFmcm9tUG9zaXRpb24pe1xuICAgICAgICAgICAgZnJvbVBvc2l0aW9uID0gdGhpcy5jZW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighaGFsZlNpemUpe1xuICAgICAgICAgICAgaGFsZlNpemUgPSB0aGlzLmhhbGZTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNlbnRlclggPSBmcm9tUG9zaXRpb24ueCArIHZlbG9jaXR5LngvMjtcbiAgICAgICAgbGV0IGNlbnRlclkgPSBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkvMjtcblxuICAgICAgICBsZXQgbWluWCA9IE1hdGgubWluKGZyb21Qb3NpdGlvbi54IC0gaGFsZlNpemUueCwgZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54IC0gaGFsZlNpemUueCk7XG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oZnJvbVBvc2l0aW9uLnkgLSBoYWxmU2l6ZS55LCBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkgLSBoYWxmU2l6ZS55KTtcblxuICAgICAgICB0aGlzLmNlbnRlci5zZXQoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIHRoaXMuaGFsZlNpemUuc2V0KGNlbnRlclggLSBtaW5YLCBjZW50ZXJZIC0gbWluWSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEBvdmVycmlkZVxuICAgIGNsb25lKCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gbmV3IEFBQkIodGhpcy5jZW50ZXIuY2xvbmUoKSwgdGhpcy5oYWxmU2l6ZS5jbG9uZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEFBQkIgdG8gYSBzdHJpbmcgZm9ybWF0XG4gICAgICogQHJldHVybnMgKGNlbnRlcjogKHgsIHkpLCBoYWxmU2l6ZTogKHgsIHkpKVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcIihjZW50ZXI6IFwiICsgdGhpcy5jZW50ZXIudG9TdHJpbmcoKSArIFwiLCBoYWxmLXNpemU6IFwiICsgdGhpcy5oYWxmU2l6ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xuXG4vKipcbiAqIEEgQ2lyY2xlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZSBleHRlbmRzIFNoYXBlIHtcblx0cHJpdmF0ZSBfY2VudGVyOiBWZWMyO1xuXHRyYWRpdXM6IG51bWJlcjtcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IENpcmNsZVxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoY2VudGVyOiBWZWMyLCByYWRpdXM6IG51bWJlcikge1xuXHRcdHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyA/IHJhZGl1cyA6IDA7XG5cdH1cblxuXHRnZXQgY2VudGVyKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9jZW50ZXI7XG5cdH1cblxuXHRzZXQgY2VudGVyKGNlbnRlcjogVmVjMikge1xuXHRcdHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcblx0fVxuXG5cdGdldCBoYWxmU2l6ZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzKTtcblx0fVxuXG5cdGdldCByKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMucmFkaXVzO1xuXHR9XG5cblx0c2V0IHIocmFkaXVzOiBudW1iZXIpIHtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHQvKipcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIuZGlzdGFuY2VTcVRvKHBvaW50KSA8PSB0aGlzLnJhZGl1cyp0aGlzLnJhZGl1cztcbiAgICB9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCIHtcblx0XHRyZXR1cm4gbmV3IEFBQkIodGhpcy5fY2VudGVyLmNsb25lKCksIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cykpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRjbG9uZSgpOiBDaXJjbGUge1xuXHRcdHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuX2NlbnRlci5jbG9uZSgpLCB0aGlzLnJhZGl1cyk7XG5cdH1cblxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIihjZW50ZXI6IFwiICsgdGhpcy5jZW50ZXIudG9TdHJpbmcoKSArIFwiLCByYWRpdXM6IFwiICsgdGhpcy5yYWRpdXMgKyBcIilcIjtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL0NpcmNsZVwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IFNoYXBlIGNsYXNzIHRoYXQgYWN0cyBhcyBhbiBpbnRlcmZhY2UgZm9yIGJldHRlciBpbnRlcmFjdGlvbnMgd2l0aCBzdWJjbGFzc2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTaGFwZSB7XG4gICAgYWJzdHJhY3QgZ2V0IGNlbnRlcigpOiBWZWMyO1xuXG4gICAgYWJzdHJhY3Qgc2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpO1xuXG4gICAgYWJzdHJhY3QgZ2V0IGhhbGZTaXplKCk6IFZlYzI7XG5cbiAgICBnZXQgeCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIueDtcbiAgICB9XG5cbiAgICBnZXQgeSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIueTtcbiAgICB9XG5cbiAgICBnZXQgaHcoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueDtcbiAgICB9XG5cbiAgICBnZXQgaGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueTtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgLSB0aGlzLmhoO1xuICAgIH1cblxuICAgIGdldCBib3R0b20oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGg7XG4gICAgfVxuXG4gICAgZ2V0IGxlZnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuaHc7XG4gICAgfVxuXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLmh3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib3VuZGluZyByZWN0YW5nbGUgZm9yIHRoaXMgc2hhcGUuIFdhcm5pbmcgLSBtYXkgYmUgdGhlIHNhbWUgYXMgdGhpcyBTaGFwZS5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYW4gQUFCQiBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxuICAgICAqIEByZXR1cm5zIEFuIEFBQkIgdGhhdCBib3VuZHMgdGhpcyBzaGFwZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJvdW5kaW5nIGNpcmNsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxuICAgICAqIEZvciBpbnN0YW5jZSwgdGhlIGJvdW5kaW5nIGNpcmNsZSBvZiBhIENpcmNsZSBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxuICAgICAqIEByZXR1cm5zIEEgQ2lyY2xlIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFNoYXBlXG4gICAgICogQHJldHVybnMgQSBuZXcgY29weSBvZiB0aGlzIHNoYXBlXG4gICAgICovXG4gICAgYWJzdHJhY3QgY2xvbmUoKTogU2hhcGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBzaGFwZSBvdmVybGFwcyBhbm90aGVyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBzaGFwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgYSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgU2hhcGUgb3ZlcmxhcHMgdGhlIG90aGVyIG9uZVxuICAgICAqL1xuICAgIGFic3RyYWN0IG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW47XG5cbiAgICAgLyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBTaGFwZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XG4gICAgICovXG4gICAgYWJzdHJhY3QgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW47XG5cbiAgICBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uKEE6IFNoYXBlLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XG5cdFx0aWYoQSBpbnN0YW5jZW9mIEFBQkIgJiYgQiBpbnN0YW5jZW9mIEFBQkIpe1xuXHRcdFx0cmV0dXJuIFNoYXBlLmdldFRpbWVPZkNvbGxpc2lvbl9BQUJCX0FBQkIoQSwgdmVsQSwgQiwgdmVsQik7XG5cdFx0fVxuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEE6IEFBQkIsIHZlbEE6IFZlYzIsIEI6IFNoYXBlLCB2ZWxCOiBWZWMyKTogW1ZlYzIsIFZlYzIsIGJvb2xlYW4sIGJvb2xlYW5dIHtcbiAgICAgICAgbGV0IHBvc1NtYWxsZXIgPSBBLmNlbnRlcjtcbiAgICAgICAgbGV0IHBvc0xhcmdlciA9IEIuY2VudGVyO1xuICAgICAgICBcbiAgICAgICAgbGV0IHNpemVTbWFsbGVyID0gQS5oYWxmU2l6ZTtcbiAgICAgICAgbGV0IHNpemVMYXJnZXIgPSBCLmhhbGZTaXplO1xuICAgIFxuICAgICAgICBsZXQgZmlyc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XG4gICAgICAgIGxldCBsYXN0Q29udGFjdCA9IG5ldyBWZWMyKDAsIDApO1xuICAgIFxuICAgICAgICBsZXQgY29sbGlkaW5nWCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29sbGlkaW5nWSA9IGZhbHNlO1xuICAgIFxuICAgICAgICAvLyBTb3J0IGJ5IHBvc2l0aW9uXG4gICAgICAgIGlmKHBvc0xhcmdlci54IDwgcG9zU21hbGxlci54KXtcbiAgICAgICAgICAgIC8vIFN3YXAsIGJlY2F1c2Ugc21hbGxlciBpcyBmdXJ0aGVyIHJpZ2h0IHRoYW4gbGFyZ2VyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcbiAgICAgICAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcbiAgICAgICAgICAgIHNpemVTbWFsbGVyID0gc2l6ZUxhcmdlcjtcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHBvc1NtYWxsZXI7XG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xuICAgICAgICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xuICAgICAgICAgICAgdmVsQSA9IHZlbEI7XG4gICAgICAgICAgICB2ZWxCID0gdGVtcDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBIGlzIGxlZnQsIEIgaXMgcmlnaHRcbiAgICAgICAgZmlyc3RDb250YWN0LnggPSBJbmZpbml0eTtcbiAgICAgICAgbGFzdENvbnRhY3QueCA9IEluZmluaXR5O1xuICAgIFxuICAgICAgICBpZiAocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLnggPj0gcG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCl7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGNvbGxpZGluZ1xuICAgICAgICAgICAgbGV0IHJlbFZlbCA9IHZlbEEueCAtIHZlbEIueDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocmVsVmVsID4gMCl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhleSBhcmUgbW92aW5nIHRvd2FyZHMgZWFjaCBvdGhlclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgICAgIGxhc3RDb250YWN0LnggPSAoKHBvc0xhcmdlci54ICsgc2l6ZUxhcmdlci54KSAtIChwb3NTbWFsbGVyLnggLSBzaXplU21hbGxlci54KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsaWRpbmdYID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZihwb3NMYXJnZXIueSA8IHBvc1NtYWxsZXIueSl7XG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciB1cCB0aGFuIGxhcmdlclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XG4gICAgICAgICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcbiAgICAgICAgICAgIHBvc0xhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcbiAgICAgICAgICAgIHZlbEEgPSB2ZWxCO1xuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQSBpcyB0b3AsIEIgaXMgYm90dG9tXG4gICAgICAgIGZpcnN0Q29udGFjdC55ID0gSW5maW5pdHk7XG4gICAgICAgIGxhc3RDb250YWN0LnkgPSBJbmZpbml0eTtcbiAgICBcbiAgICAgICAgaWYgKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55ID49IHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpe1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnkgLSB2ZWxCLnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlbFZlbCA+IDApe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgICAgICBsYXN0Q29udGFjdC55ID0gKChwb3NMYXJnZXIueSArIHNpemVMYXJnZXIueSkgLSAocG9zU21hbGxlci55IC0gc2l6ZVNtYWxsZXIueSkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlkaW5nWSA9IHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIFtmaXJzdENvbnRhY3QsIGxhc3RDb250YWN0LCBjb2xsaWRpbmdYLCBjb2xsaWRpbmdZXTtcbiAgICB9XG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xuXG4vKipcbiAqIEEgTElGTyBzdGFjayB3aXRoIGl0ZW1zIG9mIHR5cGUgVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFjazxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFN0YWNrICovXG4gICAgcHJpdmF0ZSBNQVhfRUxFTUVOVFM6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xuICAgIHByaXZhdGUgc3RhY2s6IEFycmF5PFQ+O1xuICAgIFxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgc3RhY2sgKi9cblx0cHJpdmF0ZSBoZWFkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHN0YWNrXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHM6IG51bWJlciA9IDEwMCl7XG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXk8VD4odGhpcy5NQVhfRUxFTUVOVFMpO1xuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIG5ldyBpdGVtIHRvIGFkZCB0byB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwdXNoKGl0ZW06IFQpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpe1xuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkICs9IDE7XG4gICAgICAgIHRoaXMuc3RhY2tbdGhpcy5oZWFkXSA9IGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHBvcCgpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuaGVhZCArIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwZWVrKCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWRdO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciBvciBub3QgdGhlIHN0YWNrIGlzIGVtcHR5XG4gICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkID09PSAtMTtcbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMuc3RhY2tbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5oZWFkID0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGN1cnJlbnRseSBpbiB0aGUgc3RhY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgZm9yRWFjaChmdW5jOiAoaXRlbTogVCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQpOiB2b2lke1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlKGkgPD0gdGhpcy5oZWFkKXtcbiAgICAgICAgICAgIGZ1bmModGhpcy5zdGFja1tpXSwgaSk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIHN0YWNrIGludG8gYSBzdHJpbmcgZm9ybWF0XG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgc3RhY2tcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmV0dmFsID0gXCJcIjtcblxuICAgICAgICB0aGlzLmZvckVhY2goIChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGl0ZW0udG9TdHJpbmcoKVxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAtPiBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XG4gICAgfVxufSIsImltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0YXRlIGZvciBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXS5cbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIGJlIGV4dGVuZGVkIHRvIGFsbG93IGZvciBjdXN0b20gc3RhdGUgYmVoYXZpb3JzLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTdGF0ZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBUaGUgU3RhdGVNYWNoaW5lIHRoYXQgdXNlcyB0aGlzIFN0YXRlICovXG4gICAgcHJvdGVjdGVkIHBhcmVudDogU3RhdGVNYWNoaW5lO1xuXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RhdGVcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU3RhdGVNYWNoaW5lIG9mIHRoaXMgc3RhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFN0YXRlTWFjaGluZSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXMgc3RhdGUgaXMgZW50ZXJlZC4gVXNlIHRoaXMgdG8gaW5pdGlhbGl6ZSBhbnkgdmFyaWFibGVzIGJlZm9yZSB1cGRhdGVzIG9jY3VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhpcyBzdGF0ZVxuICAgICAqL1xuICAgIGFic3RyYWN0IG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBoYW5kbGVzIGFuIGlucHV0IGV2ZW50LCBzdWNoIGFzIHRha2luZyBkYW1hZ2UuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBHYW1lRXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqL1xuICAgIGFic3RyYWN0IGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkO1xuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgYWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBzdGF0ZSBtYWNoaW5lIHRoYXQgdGhpcyBzdGF0ZSBoYXMgZW5kZWQsIGFuZCBtYWtlcyBpdCB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgc3RhdGUgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHN0YXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0b1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaW5pc2hlZChzdGF0ZU5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZShzdGF0ZU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgZW5kaW5nLlxuICAgICAqIEByZXR1cm5zIGluZm8gdG8gcGFzcyB0byB0aGUgbmV4dCBzdGF0ZVxuICAgICAqL1xuICAgIGFic3RyYWN0IG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufSIsImltcG9ydCBTdGFjayBmcm9tIFwiLi4vU3RhY2tcIjtcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi9TdGF0ZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vTWFwXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBQdXNoIERvd24gQXV0b21hdGEgU3RhdGUgbWFjaGluZS4gU3RhdGVzIGNhbiBhbHNvIGJlIGhpZXJhcmNoaWNhbFxuICogZm9yIG1vcmUgZmxleGliaWxpdHksIGFzIGRlc2NyaWJlZCBpbiBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9zdGF0ZS5odG1sKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG4gICAgLyoqIEEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc3RhdGVzICovXG4gICAgcHJvdGVjdGVkIHN0YWNrOiBTdGFjazxTdGF0ZT47XG4gICAgLyoqIEEgbWFwZSBvZiBzdGF0ZSBrZXlzIHRvIGFjdHVhbCBzdGF0ZSBpbnN0YW5jZXMgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGVNYXA6IE1hcDxTdGF0ZT47XG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRTdGF0ZTogU3RhdGU7XG4gICAgLyoqIEFuIGV2ZW50IHJlY2VpdmVyICovXG4gICAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIGlzIGN1cnJlbnRseSBhY3RpdmUgKi9cbiAgICBwcm90ZWN0ZWQgYWN0aXZlOiBib29sZWFuO1xuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIHNob3VsZCBlbWl0IGFuIGV2ZW50IG9uIHN0YXRlIGNoYW5nZSAqL1xuICAgIHByb3RlY3RlZCBlbWl0RXZlbnRPblN0YXRlQ2hhbmdlOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgZW1pdHRlZCBvbiBzdGF0ZSBjaGFuZ2UgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RhdGVNYWNoaW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICB0aGlzLnN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2aXR5IHN0YXRlIG9mIHRoaXMgc3RhdGUgbWFjaGluZVxuICAgICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgeW91IHdhbnQgdG8gc2V0IHRoaXMgbWFjaGluZSBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzZXRBY3RpdmUoZmxhZzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZsYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIGVtaXQgYW4gZXZlbnQgYW55IHRpbWUgaXRzIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhdGVDaGFuZ2VFdmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXRcbiAgICAgKi9cbiAgICBzZXRFbWl0RXZlbnRPblN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSA9IHN0YXRlQ2hhbmdlRXZlbnROYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoaXMgc3RhdGUgbWFjaGluZSBmcm9tIGVtaXR0aW5nIGV2ZW50cyBvbiBzdGF0ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgY2FuY2VsRW1pdEV2ZW50T25TdGF0ZUNoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgc3RhdGUgbWFjaGluZSB3aXRoIGFuIGluaXRpYWwgc3RhdGUgYW5kIHNldHMgaXQgcnVubmluZ1xuICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIG5hbWUgb2YgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3RhdGUgbWFjaGluZVxuICAgICAqL1xuICAgIGluaXRpYWxpemUoaW5pdGlhbFN0YXRlOiBzdHJpbmcsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGlzIHN0YXRlIG1hY2hpbmVcbiAgICAgKiBAcGFyYW0gc3RhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBhZGRcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZFN0YXRlKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZTogU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcC5hZGQoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lIHRvIHRoZSBwcm92aWRlZCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBzdGF0ZSB0byBjaGFuZ2UgdG9cbiAgICAgKi9cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIEV4aXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmN1cnJlbnRTdGF0ZS5vbkV4aXQoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvcnJlY3Qgc3RhdGUgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgaWYoc3RhdGUgPT09IFwicHJldmlvdXNcIil7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIGN1cnJlbnQgc3RhdGUgb2ZmIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhdGVtYXAgYW5kIHB1dCBpdCBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmVpdmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGFja1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xuXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgaWYgdHVybmVkIG9uXG4gICAgICAgIGlmKHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUsIHtzdGF0ZTogdGhpcy5jdXJyZW50U3RhdGV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGlucHV0LiBUaGlzIGhhcHBlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoaXMgc3RhdGUgbWFjaGluZSdzIHVwZGF0ZSBjeWNsZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGdhbWUgZXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5hY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERpc3RyaWJ1dGUgZXZlbnRzXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgdGhlIHVwZGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcblxuLyoqXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcbiAqIHdpdGggYSBzdGFydEluZGV4IGlmIHJlcXVpcmVkIChhcyBpdCBpcyB3aXRoIFRpbGVkIHVzaW5nIHR3byBpbWFnZXMgaW4gb25lIHRpbHNldCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBpbWFnZSB1c2VkIGJ5IHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCBpbWFnZUtleTogc3RyaW5nO1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xuICAgIHByb3RlY3RlZCBpbWFnZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBpbmRleCBvZiAwdGggaW1hZ2Ugb2YgdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGltYWdlIG9mIHRoaXMgdGlsc2V0ICovXG4gICAgcHJvdGVjdGVkIGVuZEluZGV4OiBudW1iZXI7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIC8vIFRPRE86IENoYW5nZSB0aGlzIHRvIGJlIG1vcmUgZ2VuZXJhbCBhbmQgd29yayB3aXRoIG90aGVyIHRpbGVzZXQgZm9ybWF0c1xuICAgIGNvbnN0cnVjdG9yKHRpbGVzZXREYXRhOiBUaWxlZFRpbGVzZXREYXRhKXtcbiAgICAgICAgLy8gRGVmZXIgaGFuZGxpbmcgb2YgdGhlIGRhdGEgdG8gYSBoZWxwZXIgY2xhc3NcbiAgICAgICAgdGhpcy5pbml0RnJvbVRpbGVkRGF0YSh0aWxlc2V0RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdGlsZXNldCBmcm9tIHRoZSBkYXRhIGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKiBAcGFyYW0gdGlsZWREYXRhIFRoZSBwYXJzZWQgb2JqZWN0IGZyb20gYSBUaWxlZCBqc29uIGZpbGVcbiAgICAgKi9cbiAgICBpbml0RnJvbVRpbGVkRGF0YSh0aWxlZERhdGE6IFRpbGVkVGlsZXNldERhdGEpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZWREYXRhLnRpbGVjb3VudC90aWxlZERhdGEuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZWREYXRhLmNvbHVtbnM7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRpbGVkRGF0YS5maXJzdGdpZDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCArIHRpbGVkRGF0YS50aWxlY291bnQgLSAxO1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLnRpbGV3aWR0aCwgdGlsZWREYXRhLnRpbGV3aWR0aCk7XG4gICAgICAgIHRoaXMuaW1hZ2VLZXkgPSB0aWxlZERhdGEuaW1hZ2U7XG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLmltYWdld2lkdGgsIHRpbGVkRGF0YS5pbWFnZWhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIGltYWdlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGtleSBvZiB0aGlzIHRpbGVtYXBcbiAgICAgKi9cbiAgICBnZXRJbWFnZUtleSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0IGZyb20gdGhlIGltYWdlIG9yaWdpbiBmb3IgdGhpcyB0aWxlLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGZyb20gc3RhcnRJbmRleCB0byBlbmRJbmRleCBvZiB0aGlzIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgb2Zmc2V0IGZvciB0aGUgc3BlY2lmaWVkIHRpbGUuXG4gICAgICovXG4gICAgZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICByZXR1cm4gbmV3IFZlYzIobGVmdCwgdG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBpbmRleFxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxuICAgICAqL1xuICAgIGdldFN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNldFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0aWxlIHNpemVcbiAgICAgKi9cbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHJvd3NcbiAgICAgKi9cbiAgICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVJvd3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbHNldFxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqL1xuICAgIGdldE51bUNvbHMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcbiAgICB9XG5cbiAgICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXggKyAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHRpbGUgaW5kZXguIFRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCB1c2VzIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKi9cbiAgICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aWxlSW5kZXggPj0gdGhpcy5zdGFydEluZGV4ICYmIHRpbGVJbmRleCA8PSB0aGlzLmVuZEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHNpbmd1bGFyIHRpbGUgd2l0aCBpbmRleCB0aWxlSW5kZXggZnJvbSB0aGUgdGlsZXNldCBsb2NhdGVkIGF0IHBvc2l0aW9uIGRhdGFJbmRleFxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGRhdGEgYXJyYXlcbiAgICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIHZpZXdwb3J0IG9yaWdpbiBpbiB0aGUgY3VycmVudCBsYXllclxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcbiAgICAgKi9cbiAgICByZW5kZXJUaWxlKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB0aWxlSW5kZXg6IG51bWJlciwgZGF0YUluZGV4OiBudW1iZXIsIG1heENvbHM6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VLZXkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKChkYXRhSW5kZXggJSBtYXhDb2xzKSAqIHdpZHRoICogc2NhbGUueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcihNYXRoLmZsb29yKGRhdGFJbmRleCAvIG1heENvbHMpICogaGVpZ2h0ICogc2NhbGUueSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKSwgTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKSwgTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pLCBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5cbi8qKlxuICogQSB0d28tZGltZW5zaW9uYWwgdmVjdG9yICh4LCB5KVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWMyIHtcblxuXHQvLyBTdG9yZSB4IGFuZCB5IGluIGFuIGFycmF5XG5cdC8qKiBUaGUgYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGFjdHVhbCB2ZWN0b3IgdmFsdWVzIHggYW5kIHkgKi9cblx0cHJpdmF0ZSB2ZWM6IEZsb2F0MzJBcnJheTtcblxuXHQvKipcdFxuXHQgKiBXaGVuIHRoaXMgdmVjdG9yIGNoYW5nZXMgaXRzIHZhbHVlLCBkbyBzb21ldGhpbmdcblx0ICovXG5cdHByaXZhdGUgb25DaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVmVjMlxuXHQgKiBAcGFyYW0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgdmVjdG9yXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDApIHtcblx0XHR0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xuXHRcdHRoaXMudmVjWzFdID0geTtcblx0fVxuXG5cdC8vIEV4cG9zZSB4IGFuZCB5IHdpdGggZ2V0dGVycyBhbmQgc2V0dGVyc1xuXHRnZXQgeCgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMF07XG5cdH1cblxuXHRzZXQgeCh4OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1swXSA9IHg7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgeSgpIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNbMV07XG5cdH1cblxuXHRzZXQgeSh5OiBudW1iZXIpIHtcblx0XHR0aGlzLnZlY1sxXSA9IHk7XG5cblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFpFUk8oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDApO1xuXHR9XG5cblx0c3RhdGljIHJlYWRvbmx5IFpFUk9fU1RBVElDID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0c3RhdGljIGdldCBJTkYoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKEluZmluaXR5LCBJbmZpbml0eSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFVQKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigwLCAtMSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IERPV04oKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDEpO1xuXHR9XG5cblx0c3RhdGljIGdldCBMRUZUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigtMSwgMCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFJJR0hUKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigxLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4gVGhpcyB0ZW5kcyB0byBiZSBmYXN0ZXIsIHNvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHRha2luZyB0aGVcblx0ICogc3F1YXJlIHJvb3QgZG9lc24ndCBtYXR0ZXIsIGxpa2UgZm9yIGNvbXBhcmluZyBkaXN0YW5jZXMuXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXG5cdCAqL1xuXHRtYWdTcSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqdGhpcy54ICsgdGhpcy55KnRoaXMueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG5cdCAqIEByZXR1cm5zIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cblx0ICovXG5cdG1hZygpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5tYWdTcSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZkZXMgeCBhbmQgeSBieSB0aGUgbWFnbml0dWRlIHRvIG9idGFpbiB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3Rvci5cblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdG5vcm1hbGl6ZSgpOiBWZWMyIHtcblx0XHRpZih0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcblx0XHR0aGlzLnggLz0gbWFnO1xuXHRcdHRoaXMueSAvPSBtYWc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogV29ya3MgbGlrZSBub3JtYWxpemUoKSwgYnV0IHJldHVybnMgYSBuZXcgVmVjMlxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXG5cdCAqL1xuXHRub3JtYWxpemVkKCk6IFZlYzIge1xuXHRcdGlmKHRoaXMuaXNaZXJvKCkpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngvbWFnLCB0aGlzLnkvbWFnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB4IGFuZCB5IGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIHRvIHplcm8uXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLCB3aXRoIHggYW5kIHkgc2V0IHRvIHplcm8uXG5cdCAqL1xuXHR6ZXJvKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldCgwLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IncyB4IGFuZCB5IGJhc2VkIG9uIHRoZSBhbmdsZSBwcm92aWRlZC4gR29lcyBjb3VudGVyIGNsb2Nrd2lzZS5cblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIGF0IHRoZSBzcGVjaWZpZWQgYW5nbGVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IuXG5cdCAqL1xuXHRzZXRUb0FuZ2xlKGFuZ2xlOiBudW1iZXIsIHJhZGl1czogbnVtYmVyID0gMSk6IFZlYzIge1xuXHRcdHRoaXMueCA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0dGhpcy55ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZSgtTWF0aC5zaW4oYW5nbGUpKnJhZGl1cywgNSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciB0aGF0IHBvaW50IGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciBvbmVcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKG90aGVyLnggLSB0aGlzLngsIG90aGVyLnkgLSB0aGlzLnkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHZlY3RvciBjb250YWluaW5nIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkLiBUaGlzIG5ldyBWZWMyIHdpbGwgYmUgYSB1bml0IHZlY3Rvci5cblx0ICovXG5cdGRpclRvKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMudmVjVG8ob3RoZXIpLm5vcm1hbGl6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEtlZXBzIHRoZSB2ZWN0b3IncyBkaXJlY3Rpb24sIGJ1dCBzZXRzIGl0cyBtYWduaXR1ZGUgdG8gYmUgdGhlIHByb3ZpZGVkIG1hZ25pdHVkZVxuXHQgKiBAcGFyYW0gbWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgdGhlIHZlY3RvciBzaG91bGQgYmVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgbWFnbml0dWRlIHNldCB0byB0aGUgbmV3IG1hZ25pdHVkZVxuXHQgKi9cblx0c2NhbGVUbyhtYWduaXR1ZGU6IG51bWJlcik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1hZ25pdHVkZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2NhbGVzIHggYW5kIHkgYnkgdGhlIG51bWJlciBwcm92aWRlZCwgb3IgaWYgdHdvIG51bWJlciBhcmUgcHJvdmlkZWQsIHNjYWxlcyB0aGVtIGluZGl2aWR1YWxseS5cblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3Jcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xuXHQgKi9cblx0c2NhbGUoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRpZih5RmFjdG9yICE9PSBudWxsKXtcblx0XHRcdHRoaXMueCAqPSBmYWN0b3I7XG5cdFx0XHR0aGlzLnkgKj0geUZhY3Rvcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLnggKj0gZmFjdG9yO1xuXHRcdHRoaXMueSAqPSBmYWN0b3I7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHNjYWxlZCB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHdpdGhvdXQgbW9kaWZ5aW5nIGl0LlxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBoYXMgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXG5cdCAqL1xuXHRzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKGZhY3RvciwgeUZhY3Rvcik7XG5cdH1cblxuXHQvKipcblx0ICogUm90YXRlcyB0aGUgdmVjdG9yIGNvdW50ZXItY2xvY2t3aXNlIGJ5IHRoZSBhbmdsZSBhbW91bnQgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgcm90YXRpb24uXG5cdCAqL1xuXHRyb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xuXHRcdGxldCBjcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRsZXQgc24gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0bGV0IHRlbXBYID0gdGhpcy54KmNzIC0gdGhpcy55KnNuO1xuXHRcdGxldCB0ZW1wWSA9IHRoaXMueCpzbiArIHRoaXMueSpjcztcblx0XHR0aGlzLnggPSB0ZW1wWDtcblx0XHR0aGlzLnkgPSB0ZW1wWTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2ZWN0b3JzIGNvb3JkaW5hdGVzIHRvIGJlIHRoZSBvbmVzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3Jcblx0ICogQHBhcmFtIHkgVGhlIG5ldyB5IHZhbHVlIGZvciB0aGlzIHZlY3RvclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvclxuXHQgKi9cblx0c2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBvdGhlciBWZWMyIGludG8gdGhpcyBvbmUuXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBjb3B5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIHZhbHVlcyBzZXQgdG8gdGhlIHZlY3RvciBwcm92aWRlZFxuXHQgKi9cblx0Y29weShvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnNldChvdGhlci54LCBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoaXMgdmVjdG9yIHRoZSBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gYWRkIHRvIHRoaXMgb25lXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGFkZGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRhZGQob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggKz0gb3RoZXIueDtcblx0XHR0aGlzLnkgKz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmNyZW1lbnRzIHRoZSBmaWVsZHMgb2YgdGhpcyB2ZWN0b3IuIEJvdGggYXJlIGluY3JlbWVudGVkIHdpdGggYSwgaWYgb25seSBhIGlzIHByb3ZpZGVkLlxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG51bWJlciB0byBpbmNyZW1lbnQgYnlcblx0ICogQHJldHVybnNzIFRoaXMgdmVjdG9yIGFmdGVyIGluY3JlbWVudGluZ1xuXHQgKi9cblx0aW5jKGE6IG51bWJlciwgYj86IG51bWJlcik6IFZlYzIge1xuXHRcdGlmKGIgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnggKz0gYTtcblx0XHRcdHRoaXMueSArPSBiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzdWJ0cmFjdGluZyB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRzdWIob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggLT0gb3RoZXIueDtcblx0XHR0aGlzLnkgLT0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54ICo9IG90aGVyLnggYW5kIHRoaXMueSAqPSBvdGhlci55XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBtdWx0aXBseSB0aGlzIG9uZSBieVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBtdWx0aXBseWluZyBpdHMgY29tcG9uZW50cyBieSB0aGlzIG9uZVxuXHQgKi9cblx0bXVsdChvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCAqPSBvdGhlci54O1xuXHRcdHRoaXMueSAqPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmlkZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggLz0gb3RoZXIueCBhbmQgdGhpcy55IC89IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gZGl2aWRlIHRoaXMgb25lIGJ5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGRpdmlzaW9uXG5cdCAqL1xuXHRkaXYob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRpZihvdGhlci54ID09PSAwIHx8IG90aGVyLnkgPT09IDApIHRocm93IFwiRGl2aWRlIGJ5IHplcm8gZXJyb3JcIjtcblx0XHR0aGlzLnggLz0gb3RoZXIueDtcblx0XHR0aGlzLnkgLz0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2VzIGFuIGVsZW1lbnQgd2lzZSByZW1haW5kZXIgb3BlcmF0aW9uIG9uIHRoaXMgdmVjdG9yLiB0aGlzLnggJT0gb3RoZXIueCBhbmQgdGhpcy55ICU9IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciB2ZWN0b3Jcblx0ICogQHJldHVybnMgdGhpcyB2ZWN0b3Jcblx0ICovXG5cdHJlbWFpbmRlcihvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCA9IHRoaXMueCAlIG90aGVyLng7XG5cdFx0dGhpcy55ID0gdGhpcy55ICUgb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2Ugc3F1YXJlZCB0b1xuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVNxVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiAodGhpcy54IC0gb3RoZXIueCkqKHRoaXMueCAtIG90aGVyLngpICsgKHRoaXMueSAtIG90aGVyLnkpKih0aGlzLnkgLSBvdGhlci55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHRvXG5cdCAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHRkaXN0YW5jZVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvKG90aGVyKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgd2l0aFxuXHQgKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWQuXG5cdCAqL1xuXHRkb3Qob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLngqb3RoZXIueCArIHRoaXMueSpvdGhlci55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBhbmdsZSB0b1xuXHQgKiBAcmV0dXJucyBUaGUgYW5nbGUsIHJvdGF0aW5nIENDVywgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb3RoZXIgdmVjdG9yXG5cdCAqL1xuXHRhbmdsZVRvQ0NXKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRsZXQgZG90ID0gdGhpcy5kb3Qob3RoZXIpO1xuXHRcdGxldCBkZXQgPSB0aGlzLngqb3RoZXIueSAtIHRoaXMueSpvdGhlci54O1xuXHRcdGxldCBhbmdsZSA9IC1NYXRoLmF0YW4yKGRldCwgZG90KTtcblxuXHRcdGlmKGFuZ2xlIDwgMCl7XG5cdFx0XHRhbmdsZSArPSAyKk1hdGguUEk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byAxIGRlY2ltYWwgcG9pbnRcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMudG9GaXhlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkZWNpbWFsIHBvaW50c1xuXHQgKiBAcGFyYW0gbnVtRGVjaW1hbFBvaW50cyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNyZWF0ZSBhIHN0cmluZyB0b1xuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xuXHQgKi9cblx0dG9GaXhlZChudW1EZWNpbWFsUG9pbnRzOiBudW1iZXIgPSAxKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLngudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiLCBcIiArIHRoaXMueS50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIpXCI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIG9uZS5cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZVxuXHQgKi9cblx0Y2xvbmUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCwgdGhpcy55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIEVYQUNUIHNhbWUgeCBhbmQgeSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xuXHQgKi9cblx0c3RyaWN0RXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBzYW1lIHggYW5kIHlcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcblx0ICovXG5cdGVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xuXHRcdGxldCB4RXEgPSBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IDAuMDAwMDAwMTtcblx0XHRsZXQgeUVxID0gTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCAwLjAwMDAwMDE7XG5cblx0XHRyZXR1cm4geEVxICYmIHlFcTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgdGhlIHplcm8gdmVjdG9yIGV4YWN0bHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cykuXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3Jcblx0ICovXG5cdHN0cmljdElzWmVybygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB4IGFuZCB5IGZvciB0aGlzIHZlY3RvciBhcmUgYm90aCB6ZXJvLlxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXG5cdCAqL1xuXHRpc1plcm8oKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCAwLjAwMDAwMDEgJiYgTWF0aC5hYnModGhpcy55KSA8IDAuMDAwMDAwMTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHRoaXMgdmVjdG9yIGlzIGNoYW5nZWQuXG5cdCAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICovXG5cdHNldE9uQ2hhbmdlKGY6IEZ1bmN0aW9uKTogdm9pZCB7XG5cdFx0dGhpcy5vbkNoYW5nZSA9IGY7XG5cdH1cblxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIHRoaXMudmVjO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlY3RvcnNcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3RvclxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSBvZiB0aGUgbGVycCwgd2l0aCAwIGJlaW5nIHZlY3RvciBBLCBhbmQgMSBiZWluZyB2ZWN0b3IgQlxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgbGVycCBiZXR3ZWVuIHZlY3RvciBhIGFuZCBiLlxuXHQgKi9cblx0c3RhdGljIGxlcnAoYTogVmVjMiwgYjogVmVjMiwgdDogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKE1hdGhVdGlscy5sZXJwKGEueCwgYi54LCB0KSwgTWF0aFV0aWxzLmxlcnAoYS55LCBiLnksIHQpKTtcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIEEgdXRpbCBjbGFzcyBmb3IgcmVuZGVyaW5nIERlYnVnIG1lc3NhZ2VzIHRvIHRoZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnIHtcblxuXHQvKiogQSBtYXAgb2YgbG9nIG1lc3NhZ2VzIHRvIGRpc3BsYXkgb24gdGhlIHNjcmVlbiAqLyBcblx0cHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBBbiBhcnJheSBvZiBnYW1lIG5vZGVzIHRvIHJlbmRlciBkZWJ1ZyBpbmZvIGZvciAqL1xuXHRwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIGFueSBkZWJ1ZyBtZXNzYWdlcyAqL1xuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuXHQvKipcdFRoZSBzaXplIG9mIHRoZSBkZWJ1ZyBjYW52YXMgKi9cblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xuXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0ICovXG5cdHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XG5cblx0LyoqXG5cdCAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXG5cdCAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBJRCBmb3IgdGhpcyBtZXNzYWdlXG5cdCAqIEBwYXJhbSBtZXNzYWdlcyBUaGUgbWVzc2FnZXMgdG8gcHJpbnQgdG8gdGhlIGRlYnVnIHNjcmVlblxuXHQgKi9cblx0c3RhdGljIGxvZyhpZDogc3RyaW5nLCAuLi5tZXNzYWdlczogYW55KTogdm9pZCB7XG5cdFx0Ly8gbGV0IG1lc3NhZ2UgPSBcIlwiO1xuXHRcdC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XG5cdFx0Ly8gXHRtZXNzYWdlICs9IG1lc3NhZ2VzW2ldLnRvU3RyaW5nKCk7XG5cdFx0Ly8gfVxuXHRcdC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXG5cdFx0bGV0IG1lc3NhZ2UgPSBtZXNzYWdlcy5tYXAoKG06IGFueSkgPT4gbS50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmFkZChpZCwgbWVzc2FnZSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbG9nIGl0ZW0gdG8gY2xlYXJcblx0ICovXG5cdHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMubG9nTWVzc2FnZXMuZGVsZXRlKGlkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlbmRlciB3aXRoIHRoZSBkZWJ1Z2dlclxuXHQgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXG5cdCAqL1xuXHRzdGF0aWMgc2V0Tm9kZXMobm9kZXM6IEFycmF5PEdhbWVOb2RlPik6IHZvaWQge1xuXHRcdHRoaXMubm9kZXMgPSBub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGJveCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgYm94IGlzIGZpbGxlZFxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBib3ggdG8gZHJhd1xuXHQgKi9cblx0c3RhdGljIGRyYXdCb3goY2VudGVyOiBWZWMyLCBoYWxmU2l6ZTogVmVjMiwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSBjaXJjbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBjaXJjbGUgaXMgZmlsbGVkXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGNpcmNsZVxuXHQgKi9cblx0c3RhdGljIGRyYXdDaXJjbGUoY2VudGVyOiBWZWMyLCByYWRpdXM6IG51bWJlciwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XG5cblx0XHRpZihmaWxsZWQpe1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmF5IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIGZyb20gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcblx0ICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSByYXlcblx0ICovXG5cdHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSAyO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRcblx0ICovXG5cdHN0YXRpYyBkcmF3UG9pbnQocG9zOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHRsZXQgcG9pbnRTaXplID0gNjtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KHBvcy54IC0gcG9pbnRTaXplLzIsIHBvcy55IC0gcG9pbnRTaXplLzIsIHBvaW50U2l6ZSwgcG9pbnRTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCBmb3IgdGhlIGRlYnVnZ2VyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gcmVuZGVyIHRoZSB0ZXh0XG5cdCAqL1xuXHRzdGF0aWMgc2V0RGVmYXVsdFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmRlZmF1bHRUZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhbnkgbmVjZXNzYXJ5IHNldHVwIG9wZXJhdGlvbnMgb24gdGhlIERlYnVnIGNhbnZhc1xuXHQgKiBAcGFyYW0gY2FudmFzIFRoZSBkZWJ1ZyBjYW52YXNcblx0ICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZXh0cmFjdGVkIGZyb20gdGhlIGNhbnZhc1xuXHQgKi9cblx0c3RhdGljIGluaXRpYWxpemVEZWJ1Z0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XG5cdFx0dGhpcy5kZWJ1Z0NhbnZhc1NpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0O1xuXHR9XG5cblx0LyoqIENsZWFycyB0aGUgZGVidWcgY2FudmFzICovXG5cdHN0YXRpYyBjbGVhckNhbnZhcygpOiB2b2lkIHtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueSk7XG5cdH1cblxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBhbmQgbm9kZXMgc2VudCB0byB0aGUgRGVidWcgc3lzdGVtICovXG5cdHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XG5cdFx0dGhpcy5yZW5kZXJUZXh0KCk7XG5cdFx0dGhpcy5yZW5kZXJOb2RlcygpO1xuXHR9XG5cblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgc2VudCB0byB0aGUgRGVidWcgY2FudmFzICovXG5cdHN0YXRpYyByZW5kZXJUZXh0KCk6IHZvaWQge1xuXHRcdGxldCB5ID0gMjA7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZm9udCA9IFwiMjBweCBBcmlhbFwiO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVmYXVsdFRleHRDb2xvci50b1N0cmluZygpO1xuXG5cdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRleHRcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsVGV4dCh0aGlzLmxvZ01lc3NhZ2VzLmdldChrZXkpLCAxMCwgeSlcblx0XHRcdHkgKz0gMzA7XHRcblx0XHR9KTtcblx0fVxuXG5cdC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xuXHRzdGF0aWMgcmVuZGVyTm9kZXMoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5ub2Rlcyl7XG5cdFx0XHR0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG5cdFx0XHRcdG5vZGUuZGVidWdSZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLy8gQGlnbm9yZVBhZ2VcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRzIGV4dGVuZHMgT2JqZWN0IHtcbiAgICAvLyBUaGUgZnBzIG9mIHRoZSBnYW1lLlxuICAgIHByaXZhdGUgc3RhdGljIHByZXZmcHM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTlVNX1BPSU5UUzogbnVtYmVyID0gNjA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX1dJRFRIOiBudW1iZXIgPSAzMDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX0hFSUdIVDogbnVtYmVyID0gMzAwO1xuICAgIHByaXZhdGUgc3RhdGljIHN0YXRzRGl2OiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHN0YXRpYyBncmFwaENob2ljZXM6IEhUTUxTZWxlY3RFbGVtZW50O1xuXG4gICAgLy8gUXVhZHRyZWUgc3RhdHNcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2Q2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR0NsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcblxuICAgIHByaXZhdGUgc3RhdGljIHByZXZGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dGaWxsVGltZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlVwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHVXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dVcGRhdGVUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2UXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR1F1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcblxuICAgIHN0YXRpYyBpbml0U3RhdHMoKTogdm9pZCB7XG4gICAgICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuQ0FOVkFTX1dJRFRIO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5DQU5WQVNfSEVJR0hUO1xuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0RpdiA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWRpc3BsYXlcIik7XG5cbiAgICAgICAgdGhpcy5wcmV2ZnBzID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gMDtcblxuICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gMDtcblxuICAgICAgICBsZXQgY2xlYXJUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGNsZWFyVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnY2xlYXJcIik7XG4gICAgICAgIGxldCBmaWxsVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBmaWxsVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnZmlsbFwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdXBkYXRlVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNndXBkYXRlXCIpO1xuICAgICAgICBsZXQgcXVlcnlUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHF1ZXJ5VGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNncXVlcnlcIik7XG4gICAgICAgIGxldCBicjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIGxldCBicjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG5cbiAgICAgICAgdGhpcy5zdGF0c0Rpdi5hcHBlbmQoY2xlYXJUaW1lLCBicjEsIGZpbGxUaW1lLCBicjIsIHVwZGF0ZVRpbWUsIGJyMywgcXVlcnlUaW1lKTtcblxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcyA9IDxIVE1MU2VsZWN0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKTtcbiAgICAgICAgbGV0IG9wdGlvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24xLnZhbHVlID0gXCJwcmV2ZnBzXCI7XG4gICAgICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xuICAgICAgICBsZXQgb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjIudmFsdWUgPSBcInByZXZDbGVhclRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24zLnZhbHVlID0gXCJwcmV2RmlsbFRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjQudmFsdWUgPSBcInByZXZVcGRhdGVUaW1lc1wiO1xuICAgICAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uNSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjUudmFsdWUgPSBcInByZXZRdWVyeVRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbkFsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbkFsbC52YWx1ZSA9IFwiYWxsXCI7XG4gICAgICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzLmFwcGVuZChvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCBvcHRpb240LCBvcHRpb241LCBvcHRpb25BbGwpO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVGUFMoZnBzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmV2ZnBzLnB1c2goZnBzKTtcbiAgICAgICAgaWYodGhpcy5wcmV2ZnBzLmxlbmd0aCA+IFN0YXRzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgdGhpcy5wcmV2ZnBzLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMucHVzaCh0aGlzLmF2Z1NHQ2xlYXJUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5wdXNoKHRoaXMuYXZnU0dGaWxsVGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5wdXNoKHRoaXMuYXZnU0dVcGRhdGVUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMucHVzaCh0aGlzLmF2Z1NHUXVlcnlUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVNHU3RhdHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYoa2V5ID09PSBcInNnY2xlYXJcIil7XG4gICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNnZmlsbFwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2d1cGRhdGVcIil7XG4gICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNncXVlcnlcIil7XG4gICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMTAwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gRGlzcGxheSBzdGF0c1xuICAgICAgICB0aGlzLmRyYXdDaGFydHMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZHJhd0NoYXJ0cygpe1xuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XG5cbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gdGhpcy5ncmFwaENob2ljZXMudmFsdWU7XG5cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldmZwc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldmZwcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkNsZWFyVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZDbGVhclRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuUkVELnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZGaWxsVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5HUkVFTi50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2VXBkYXRlVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZVcGRhdGVUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlF1ZXJ5VGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZRdWVyeVRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuT1JBTkdFLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGRyYXdDaGFydChwYXJhbTogQXJyYXk8bnVtYmVyPiwgY29sb3I6IHN0cmluZyl7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuQkxBQ0sudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLkNBTlZBU19XSURUSCAtIDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucGFyYW0pO1xuICAgICAgICBsZXQgcHJldlggPSAxMDtcbiAgICAgICAgbGV0IHByZXZZID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBwYXJhbVswXS9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBmcHMgPSBwYXJhbVtpXTtcbiAgICAgICAgICAgIGxldCB4ID0gMTAgKyBpKih0aGlzLkNBTlZBU19XSURUSCAtIDIwKS90aGlzLk5VTV9QT0lOVFM7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gZnBzL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKVxuICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocHJldlgsIHByZXZZKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTR1N0YXRzKCl7XG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IHRoaXMuU0dDbGVhclRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IHRoaXMuU0dGaWxsVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHRmlsbFRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSB0aGlzLlNHVXBkYXRlVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gdGhpcy5TR1F1ZXJ5VGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnY2xlYXJcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgY2xlYXIgdGltZTogXCIgKyB0aGlzLmF2Z1NHQ2xlYXJUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnZmlsbFwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBmaWxsIHRpbWU6IFwiICsgdGhpcy5hdmdTR0ZpbGxUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNndXBkYXRlXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHVwZGF0ZSB0aW1lOiBcIiArIHRoaXMuYXZnU0dVcGRhdGVUaW1lO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNncXVlcnlcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgcXVlcnkgdGltZTogXCIgKyB0aGlzLmF2Z1NHUXVlcnlUaW1lO1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xuXG4vKipcbiAqIEFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0IG90aGVyIHN5c3RlbXMgY2FuIHVzZSB0byBob29rIGludG8gdGhlIEV2ZW50UXVldWUuXG4gKiBQcm92aWRlcyBhbiBlYXN5IGludGVyZmFjZSBmb3IgZmlyaW5nIG9mZiBldmVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtaXR0ZXIge1xuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIEV2ZW50UXVldWUgKi9cblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXG5cdC8qKiBDcmVhdGVzIGEgbmV3IEVtaXR0ZXIgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW1pdCBhbmQgZXZlbnQgb2YgdHlwZSBldmVudFR5cGUgd2l0aCB0aGUgZGF0YSBwYWNrZXQgZGF0YVxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIG9mZlxuXHQgKiBAcGFyYW0gZGF0YSBBIEByZWZlcmVuY2VbTWFwXSBvciByZWNvcmQgY29udGFpbmluZyBhbnkgZGF0YSBhYm91dCB0aGUgZXZlbnRcblx0ICovXG5cdGZpcmVFdmVudChldmVudFR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCk6IHZvaWQge1xuXHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChuZXcgR2FtZUV2ZW50KGV2ZW50VHlwZSwgZGF0YSkpO1xuXHR9XG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogVGhlIG1haW4gZXZlbnQgc3lzdGVtIG9mIHRoZSBnYW1lIGVuZ2luZS5cbiAqIEV2ZW50cyBhcmUgc2VudCB0byB0aGUgRXZlbnRRdWV1ZSwgd2hpY2ggaGFuZGxlcyBkaXN0cmlidXRpb24gdG8gYW55IHN5c3RlbXMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciB0aG9zZSBldmVudHMuXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLCBcbiAqIGFuZCBhbGxvd3Mgb3RoZXJ3aXNlIHNlcGFyYXRlIGNsYXNzZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyIGNsZWFubHksIHN1Y2ggYXMgYSBQbGF5ZXIgb2JqZWN0IFxuICogcmVxdWVzdGluZyBhIHNvdW5kIGJlIHBsYXllZCBieSB0aGUgYXVkaW8gc3lzdGVtLlxuICogXG4gKiBUaGUgZGlzdHJpYnV0aW9uIG9mIEByZWZlcmVuY2VbR2FtZUV2ZW50XXMgaGFwcGVucyBhcyBmb2xsb3dzOlxuICogXG4gKiBFdmVudHMgYXJlIHJlY2lldmVkIHRocm91Z2hvdXQgYSBmcmFtZSBhbmQgYXJlIHF1ZXVlZCB1cCBieSB0aGUgRXZlbnRRdWV1ZS5cbiAqIEF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZnJhbWUsIGV2ZW50cyBhcmUgc2VudCBvdXQgdG8gYW55IHJlY2VpdmVycyB0aGF0IGFyZSBob29rZWQgaW50byB0aGUgZXZlbnQgdHlwZS5cbiAqIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBhcmUgdGhlbiBmcmVlIHRvIHByb2Nlc3MgZXZlbnRzIGFzIHRoZXkgc2VlIGZpdC5cbiAqIFxuICogT3ZlcmFsbCwgdGhlIEV2ZW50UXVldWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgc29tZXRoaW5nIHNpbWlsYXIgdG8gYW4gZW1haWwgc2VydmVyLFxuICogYW5kIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgY2FuIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGNsaWVudCBpbmJveGVzLlxuICogXG4gKiBTZWUgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZXZlbnQtcXVldWUuaHRtbCkgZm9yIG1vcmUgZGlzY3Vzc2lvbiBvbiBFdmVudFF1ZXVlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdmlzaWJsZSAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIGFjdHVhbCBxdWV1ZSBvZiBldmVudHMgKi9cbiAgICBwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XG4gICAgXG4gICAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cblx0cHJpdmF0ZSByZWNlaXZlcnM6IE1hcDxBcnJheTxSZWNlaXZlcj4+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLk1BWF9TSVpFID0gMTAwO1xuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWU8R2FtZUV2ZW50Pih0aGlzLk1BWF9TSVpFKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMgPSBuZXcgTWFwPEFycmF5PFJlY2VpdmVyPj4oKTtcblx0fVxuICAgIFxuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBTaW5nbGV0b24gRXZlbnRRdWV1ZSAqL1xuXHRzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRXZlbnRRdWV1ZSB7XG5cdFx0aWYodGhpcy5pbnN0YW5jZSA9PT0gbnVsbCl7XG5cdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IEV2ZW50UXVldWUoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdH1cblxuICAgIC8qKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBFdmVudFF1ZXVlLlxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzcyAqL1xuICAgIGFkZEV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZXMgYSByZWNlaXZlciB3aXRoIGEgdHlwZSBvZiBldmVudC4gRXZlcnkgdGltZSB0aGlzIGV2ZW50IGFwcGVhcnMgaW4gdGhlIGZ1dHVyZSxcbiAgICAgKiBpdCB3aWxsIGJlIGdpdmVuIHRvIHRoZSByZWNlaXZlciAoYW5kIGFueSBvdGhlcnMgd2F0Y2hpbmcgdGhhdCB0eXBlKS5cbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSBldmVudCByZWNlaXZlclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9yIHR5cGVzIG9mIGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xuICAgICAgICAgICAgZm9yKGxldCB0IG9mIHR5cGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdHlwZSk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBzcGVjaWZpZWQgcmVjZWl2ZXIgZnJvbSBhbGwgZXZlbnRzLCBvciBmcm9tIHdoYXRldmVyIGV2ZW50cyBhcmUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIHJlY2VpdmVyIHRvIHVuc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIGtleXMgVGhlIGV2ZW50cyB0byB1bnN1YnNjcmliZSBmcm9tLiBJZiBub25lIGFyZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgZnJvbSBhbGxcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIC4uLmV2ZW50czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgICAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBrZXlzIHdlcmUgcHJvdmlkZWQsIG9ubHkgY29udGludWUgaWYgdGhpcyBrZXkgaXMgb25lIG9mIHRoZW1cbiAgICAgICAgICAgIGlmKGV2ZW50cy5sZW5ndGggPiAwICYmIGV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIG91ciByZWNlaXZlciBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLmluZGV4T2YocmVjZWl2ZXIpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbiBpbmRleCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgcmVjZWl2ZXJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXNzb2NpYXRlIHRoZSByZWNlaXZlciBhbmQgdGhlIHR5cGVcblx0cHJpdmF0ZSBhZGRMaXN0ZW5lcihyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xuXHRcdGlmKHRoaXMucmVjZWl2ZXJzLmhhcyh0eXBlKSl7XG5cdFx0XHR0aGlzLnJlY2VpdmVycy5nZXQodHlwZSkucHVzaChyZWNlaXZlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmFkZCh0eXBlLCBbcmVjZWl2ZXJdKTtcblx0XHR9XG5cdH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgd2hpbGUodGhpcy5xLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgZWFjaCBldmVudFxuXHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5xLmRlcXVldWUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBoYXMgdGhpcyBldmVudCB0eXBlLCBzZW5kIGl0IHRoZSBldmVudFxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKGV2ZW50LnR5cGUpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBpcyBzdWJzY3JpYmVkIHRvIGFsbCBldmVudHMsIHNlbmQgaXQgdGhlIGV2ZW50XG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoR2FtZUV2ZW50VHlwZS5BTEwpKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChHYW1lRXZlbnRUeXBlLkFMTCkpe1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbi1nYW1lIGV2ZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUV2ZW50IHtcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGV2ZW50ICovXG4gICAgcHVibGljIHR5cGU6IHN0cmluZztcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBldmVudCAqL1xuICAgIHB1YmxpYyBkYXRhOiBNYXA8YW55PjtcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIG1zICovXG5cdHB1YmxpYyB0aW1lOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cbiAgICAgKiBUaGlzIGlzIGhhbmRsZWQgaW1wbGljaXRseSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBnYW1lIGV2ZW50IGRhdGFcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcCkpe1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhIHJhdyBvYmplY3QsIHVucGFja1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBkYXRhKXtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWRkKGtleSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBHYW1lRXZlbnQgaXMgdGhlIHNwZWNpZmllZCB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBHYW1lRXZlbnQgYXMgYSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lRXZlbnRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgXCI6IEBcIiArIHRoaXMudGltZTtcbiAgICB9XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGVudW0gR2FtZUV2ZW50VHlwZSB7XG5cdC8qKlxuXHQgKiBNb3VzZSBEb3duIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBVcCBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxuXHQgKi9cblx0TU9VU0VfVVAgPSBcIm1vdXNlX3VwXCIsXG5cdC8qKlxuXHQgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9NT1ZFID0gXCJtb3VzZV9tb3ZlXCIsXG5cblx0LyoqXG5cdCAqIEtleSBEb3duIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIGRvd259XG5cdCAqL1xuXHRLRVlfRE9XTiA9IFwia2V5X2Rvd25cIixcblxuXHQvKipcblx0ICogS2V5IFVwIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIHVwfVxuXHQgKi9cblx0S0VZX1VQID0gXCJrZXlfdXBcIixcblxuXHQvKipcblx0ICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0Q0FOVkFTX0JMVVIgPSBcImNhbnZhc19ibHVyXCIsXG5cblx0LyoqXG5cdCAqIE1vdXNlIHdoZWVsIHVwIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX1VQID0gXCJ3aGVlbF91cFwiLFxuXG5cdC8qKlxuXHQgKiBNb3VzZSB3aGVlbCBkb3duIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcblxuXHQvKipcblx0ICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFNUQVJUX1JFQ09SRElORyA9IFwic3RhcnRfcmVjb3JkaW5nXCIsXG5cblx0LyoqXG5cdCAqIFN0b3AgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFNUT1BfUkVDT1JESU5HID0gXCJzdG9wX3JlY29yZGluZ1wiLFxuXHRcblx0LyoqXG5cdCAqIFBsYXkgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdFBMQVlfUkVDT1JESU5HID0gXCJwbGF5X3JlY29yZGluZ1wiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cblx0ICovXG5cdFBMQVlfU09VTkQgPSBcInBsYXlfc291bmRcIixcblxuXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZ31cblx0ICovXG5cdFNUT1BfU09VTkQgPSBcInN0b3Bfc291bmRcIixcblxuXHQvKipcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSB9XG5cdCAqL1xuIFx0UExBWV9TRlggPSBcInBsYXlfc2Z4XCIsXG5cbiBcdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cblx0ICovXG4gIFx0UExBWV9NVVNJQyA9IFwicGxheV9tdXNpY1wiLFxuXG5cdC8qKlxuXHQgKiBNdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cblx0ICovXG5cdE1VVEVfQ0hBTk5FTCA9IFwibXV0ZV9jaGFubmVsXCIsXG5cblx0LyoqXG5cdCAqIFVubXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XG5cdCAqL1xuXHRVTk1VVEVfQ0hBTk5FTCA9IFwidW5tdXRlX2NoYW5uZWxcIixcblxuXHQvKipcblx0ICogRW5jb21wYXNzZXMgYWxsIGV2ZW50IHR5cGVzLiBVc2VkIGZvciByZWNlaXZlcnMgb25seS5cblx0ICovXG5cdEFMTCA9IFwiYWxsXCIsXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5cbi8qKlxuICogUmVjZWl2ZXMgc3Vic2NyaWJlZCBldmVudHMgZnJvbSB0aGUgRXZlbnRRdWV1ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjZWl2ZXIge1xuXHQvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB0aGlzIFJlY2VpdmVyIGNhbiBob2xkIGF0IG9uZSB0aW1lICovXG5cdHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XG5cblx0LyoqIFRoZSBpbmJveCBvZiB0aGUgUmVjZWl2ZXIgKi9cblx0cHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xuXG5cdC8qKiBDcmVhdGVzIGEgbmV3IFJlY2VpdmVyICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5NQVhfU0laRSA9IDEwMDtcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlKHRoaXMuTUFYX1NJWkUpO1xuXHR9XG5cblx0ZGVzdHJveSgpe1xuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS51bnN1YnNjcmliZSh0aGlzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZHMgdGhlc2UgdHlwZXMgb2YgZXZlbnRzIHRvIHRoaXMgcmVjZWl2ZXIncyBxdWV1ZSBldmVyeSB1cGRhdGUuXG5cdCAqIEBwYXJhbSBldmVudFR5cGVzIFRoZSB0eXBlcyBvZiBldmVudHMgdGhpcyByZWNlaXZlciB3aWxsIGJlIHN1YnNjcmliZWQgdG9cblx0ICovXG5cdHN1YnNjcmliZShldmVudFR5cGVzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnN1YnNjcmliZSh0aGlzLCBldmVudFR5cGVzKTtcblx0XHR0aGlzLnEuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBxdWV1ZSBvZiB0aGlzIHJlY2lldmVyLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gdG8gZGlzdHJpYnV0ZSBldmVudHNcblx0ICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byByZWNlaXZlXG5cdCAqL1xuXHRyZWNlaXZlKGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcblx0XHR0cnl7XG5cdFx0dGhpcy5xLmVucXVldWUoZXZlbnQpO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJSZWNlaXZlciBvdmVyZmxvdyBmb3IgZXZlbnQgXCIgKyBldmVudC50b1N0cmluZygpKTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgbmV4dCBldmVudCBmcm9tIHRoZSByZWNlaXZlcidzIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxuXHQgKi9cblx0Z2V0TmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XG5cdFx0cmV0dXJuIHRoaXMucS5kZXF1ZXVlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTG9va3MgYXQgdGhlIG5leHQgZXZlbnQgaW4gdGhlIHJlY2VpdmVyJ3MgcXVldWUsIGJ1dCBkb2Vzbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZVxuXHQgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcblx0ICovXG5cdHBlZWtOZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcblx0XHRyZXR1cm4gdGhpcy5xLnBlZWtOZXh0KClcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbnkgZXZlbnRzIGluIGl0cyBxdWV1ZVxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZWNlaXZlciBoYXMgYW5vdGhlciBldmVudCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRoYXNOZXh0RXZlbnQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMucS5oYXNJdGVtcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIElnbm9yZSBhbGwgZXZlbnRzIHRoaXMgZnJhbWVcblx0ICovXG5cdGlnbm9yZUV2ZW50cygpOiB2b2lkIHtcblx0XHR0aGlzLnEuY2xlYXIoKTtcblx0fVxufSIsImltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogUmVjZWl2ZXMgaW5wdXQgZXZlbnRzIGZyb20gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gYW5kIGFsbG93cyBmb3IgZWFzeSBhY2Nlc3Mgb2YgaW5mb3JtYXRpb24gYWJvdXQgaW5wdXQgYnkgb3RoZXIgc3lzdGVtc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NlZDogYm9vbGVhbjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VKdXN0UHJlc3NlZDogYm9vbGVhbjtcblxuXHRwcml2YXRlIHN0YXRpYyBrZXlKdXN0UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xuXHRwcml2YXRlIHN0YXRpYyBrZXlQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XG5cblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQb3NpdGlvbjogVmVjMjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc1Bvc2l0aW9uOiBWZWMyO1xuXG5cdHByaXZhdGUgc3RhdGljIHNjcm9sbERpcmVjdGlvbjogbnVtYmVyO1xuXHRwcml2YXRlIHN0YXRpYyBqdXN0U2Nyb2xsZWQ6IGJvb2xlYW47XG5cblx0cHJpdmF0ZSBzdGF0aWMgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblx0cHJpdmF0ZSBzdGF0aWMgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHRwcml2YXRlIHN0YXRpYyB2aWV3cG9ydDogVmlld3BvcnQ7XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5TWFwOiBNYXA8QXJyYXk8c3RyaW5nPj47XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5c0Rpc2FibGVkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZURpc2FibGVkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgSW5wdXQgb2JqZWN0XG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBBIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcblx0ICovXG5cdHN0YXRpYyBpbml0aWFsaXplKHZpZXdwb3J0OiBWaWV3cG9ydCwga2V5TWFwOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pil7XG5cdFx0SW5wdXQudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcblx0XHRJbnB1dC5rZXlQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xuXHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xuXHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGtleW1hcFxuXHRcdElucHV0LmtleU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEFkZCBhbGwga2V5cyB0byB0aGUga2V5bWFwXG5cdFx0Zm9yKGxldCBlbnRyeSBpbiBrZXlNYXApe1xuXHRcdFx0bGV0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XG5cdFx0XHRsZXQga2V5cyA9IGtleU1hcFtlbnRyeV0ua2V5cztcblx0XHRcdElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XG5cdFx0fVxuXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcblx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGlucHV0IGV2ZW50c1xuXHRcdElucHV0LmV2ZW50UXVldWUuc3Vic2NyaWJlKElucHV0LnJlY2VpdmVyLCBbR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsXG5cdFx0XHQgR2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwgR2FtZUV2ZW50VHlwZS5LRVlfVVAsIEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTl0pO1xuXHR9XG5cblx0c3RhdGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJlc2V0IHRoZSBqdXN0UHJlc3NlZCB2YWx1ZXMgdG8gZmFsc2Vcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcblxuXHRcdHdoaWxlKElucHV0LnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcdFx0XHRcblx0XHRcdGxldCBldmVudCA9IElucHV0LnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuXHRcdFx0XG5cdFx0XHQvLyBIYW5kbGUgZWFjaCBldmVudCB0eXBlXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04pe1xuXHRcdFx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gdHJ1ZTtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQKXtcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSl7XG5cdFx0XHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9ET1dOKXtcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXG5cdFx0XHRcdGlmKGtleSA9PT0gXCIgXCIpe1xuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KSl7XG5cdFx0XHRcdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XG5cdFx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9VUCl7XG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxuXHRcdFx0XHRpZihrZXkgPT09IFwiIFwiKXtcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIpe1xuXHRcdFx0XHRJbnB1dC5jbGVhcktleVByZXNzZXMoKVxuXHRcdFx0fVxuXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX1VQKXtcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gLTE7XG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOKXtcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMTtcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBjbGVhcktleVByZXNzZXMoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdFx0SW5wdXQua2V5UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBrZXkgd2FzIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXG5cdCAqIElmIHRoZSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBJbnB1dCB3aWxsIHJldHVybiBmYWxzZS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtleSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0tleUp1c3RQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZihJbnB1dC5rZXlKdXN0UHJlc3NlZC5oYXMoa2V5KSl7XG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5SnVzdFByZXNzZWQuZ2V0KGtleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyB0aGF0IGFyZSBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxuXHQgKiBJZiBhIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGluIElucHV0IGxpc3QuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgbmV3bHkgcHJlc3NlZCBrZXlzLlxuXHQgKi9cblx0c3RhdGljIGdldEtleXNKdXN0UHJlc3NlZCgpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcblxuXHRcdGxldCBrZXlzID0gQXJyYXk8c3RyaW5nPigpO1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmKElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpKXtcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGtleXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBiZWluZyBwcmVzc2VkLlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0tleVByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmKElucHV0LmtleVByZXNzZWQuaGFzKGtleSkpe1xuXHRcdFx0cmV0dXJuIElucHV0LmtleVByZXNzZWQuZ2V0KGtleSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBiaW5kaW5nIG9mIGFuIGlucHV0IG5hbWUgdG8ga2V5c1xuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuXHQgKiBAcGFyYW0ga2V5cyBUaGUgY29ycmVzcG9uZGluZyBrZXlzXG5cdCAqL1xuXHRzdGF0aWMgY2hhbmdlS2V5QmluZGluZyhpbnB1dE5hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuXHRcdElucHV0LmtleU1hcC5zZXQoaW5wdXROYW1lLCBrZXlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIGtleSBiaW5kaW5nc1xuXHQgKi9cblx0c3RhdGljIGNsZWFyQWxsS2V5QmluZGluZ3MoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5TWFwLmNsZWFyKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWVcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNKdXN0UHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKXtcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XG5cdFx0XHRsZXQganVzdFByZXNzZWQgPSBmYWxzZTtcblxuXHRcdFx0Zm9yKGxldCBrZXkgb2Yga2V5cyl7XG5cdFx0XHRcdGp1c3RQcmVzc2VkID0ganVzdFByZXNzZWQgfHwgSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ganVzdFByZXNzZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XHRcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IGlzIGN1cnJlbnRseSBwcmVzc2VkXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IGlzIHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzUHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKXtcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XG5cdFx0XHRsZXQgcHJlc3NlZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IobGV0IGtleSBvZiBrZXlzKXtcblx0XHRcdFx0cHJlc3NlZCA9IHByZXNzZWQgfHwgSW5wdXQuaXNLZXlQcmVzc2VkKGtleSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcmVzc2VkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzTW91c2VKdXN0UHJlc3NlZCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNNb3VzZVByZXNzZWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVzZXIgc2Nyb2xsZWQgb3Igbm90XG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIganVzdCBzY3JvbGxlZCBJbnB1dCBmcmFtZSwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgZGlkSnVzdFNjcm9sbCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gSW5wdXQuanVzdFNjcm9sbGVkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXG5cdCAqIEByZXR1cm5zIC0xIGlmIHRoZSB1c2VyIHNjcm9sbGVkIHVwLCAxIGlmIHRoZXkgc2Nyb2xsZWQgZG93blxuXHQgKi9cblx0c3RhdGljIGdldFNjcm9sbERpcmVjdGlvbigpOiBudW1iZXIge1xuXHRcdHJldHVybiBJbnB1dC5zY3JvbGxEaXJlY3Rpb247XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0TW91c2VQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5zY2FsZWQoMS90aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2UgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLmNsb25lKCkuc2NhbGUoMS90aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKS5hZGQoSW5wdXQudmlld3BvcnQuZ2V0T3JpZ2luKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzUG9zaXRpb247XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3MgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbi5jbG9uZSgpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcblx0ICovXG5cdHN0YXRpYyBkaXNhYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gdHJ1ZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXG5cdCAqL1xuXHRzdGF0aWMgZW5hYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xuXHR9XG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgd2ViIGJyb3dzZXIgdG8gcmVjZWl2ZSBhc3luY2hyb25vdXMgZXZlbnRzIGFuZCBzZW5kIHRoZW0gdG8gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIHtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuICAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElucHV0SGFuZGxlclxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGdhbWUgY2FudmFzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCl7XG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuXHRcdFxuICAgICAgICBjYW52YXMub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VEb3duKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBjYW52YXMub25tb3VzZXVwID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlVXAoZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVDb250ZXh0TWVudTtcbiAgICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCwgY2FudmFzKTtcbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gdGhpcy5oYW5kbGVLZXlEb3duO1xuICAgICAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcbiAgICAgICAgZG9jdW1lbnQub25ibHVyID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlRG93biA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuXHRcdGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwge3Bvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVVwID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIHtwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSwge3Bvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIHtrZXk6IGtleX0pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX1VQLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCB7fSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ29udGV4dE1lbnUgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlV2hlZWwgPSAoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgZ2FtZUV2ZW50OiBHYW1lRXZlbnQ7XG4gICAgICAgIGlmKGV2ZW50LmRlbHRhWSA8IDApe1xuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0S2V5KGtleUV2ZW50OiBLZXlib2FyZEV2ZW50KXtcbiAgICAgICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogVmVjMiB7XG4gICAgICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgeCA9IG1vdXNlRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cbn0iLCJpbXBvcnQge30gZnJvbSBcIi4uLy4uL2luZGV4XCI7ICAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIGdhbWUgZW5naW5lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXR1cCgpe1xuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeDogbnVtYmVyLCB5OiBudW1iZXIsIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmKHIgPCAwKSByID0gMDtcbiAgICAgICAgICAgIGlmKHIgPiBNYXRoLm1pbih3LCBoKSkgciA9IE1hdGgubWluKHcsIGgpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHJvdW5kZWQgcmVjdFxuICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBUb3BcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFJpZ2h0XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIExlZnRcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSwgeCArIHIsIHksIHIpXG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQSBnYW1lIGxvb3Agd2l0aCBhIGZpeGVkIHVwZGF0ZSB0aW1lIGFuZCBhIHZhcmlhYmxlIHJlbmRlciB0aW1lLlxuICogRXZlcnkgZnJhbWUsIHRoZSBnYW1lIHVwZGF0ZXMgdW50aWwgYWxsIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICogSWYgdG9vIG11Y2ggdGltZSBoYXMgcGFzc2VkLCBzdWNoIGFzIGlmIHRoZSBsYXN0IHVwZGF0ZSB3YXMgdG9vIHNsb3csIFxuICogb3IgaWYgdGhlIGJyb3dzZXIgd2FzIHB1dCBpbnRvIHRoZSBiYWNrZ3JvdW5kLCB0aGUgbG9vcCB3aWxsIHBhbmljIGFuZCBkaXNjYXJkIHRpbWUuXG4gKiBBIHJlbmRlciBoYXBwZW5zIGF0IHRoZSBlbmQgb2YgZXZlcnkgZnJhbWUuIFRoaXMgaGFwcGVucyBhcyBmYXN0IGFzIHBvc3NpYmxlIHVubGVzcyBzcGVjaWZpZWQuXG4gKiBBIGxvb3Agb2YgdGhpcyB0eXBlIGFsbG93cyBmb3IgZGV0ZXJtaW5pc3RpYyBiZWhhdmlvciAtIE5vIG1hdHRlciB3aGF0IHRoZSBmcmFtZSByYXRlIGlzLCB0aGUgdXBkYXRlIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUsIFxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRVcGRhdGVHYW1lTG9vcCBleHRlbmRzIEdhbWVMb29wIHtcblxuXHQvKiogVGhlIG1heCBhbGxvd2VkIHVwZGF0ZSBmcHMuKi9cbiAgICBwcml2YXRlIG1heFVwZGF0ZUZQUzogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZXN0ZXAgZm9yIGVhY2ggdXBkYXRlLiBUaGlzIGlzIHRoZSBkZWx0YVQgcGFzc2VkIHRvIHVwZGF0ZSBjYWxscy4gKi9cblx0cHJpdmF0ZSB1cGRhdGVUaW1lc3RlcDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgeWV0IHRvIHNpbXVsYXRlLiAqL1xuICAgIHByaXZhdGUgZnJhbWVEZWx0YTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSB0aW1lIHdoZW4gdGhlIGxhc3QgZnJhbWUgd2FzIGRyYXduLiAqL1xuICAgIHByaXZhdGUgbGFzdEZyYW1lVGltZTogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgbWluaW11bSB0aW1lIHdlIHdhbnQgdG8gd2FpdCBiZXR3ZWVuIGdhbWUgZnJhbWVzLiAqL1xuICAgIHByaXZhdGUgbWluRnJhbWVEZWxheTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGUgZ2FtZS4gKi9cblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgYWN0dWFsIGZwcyBvZiB0aGUgZ2FtZS4gKi9cbiAgICBwcml2YXRlIGZwczogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZSBiZXR3ZWVuIGZwcyBtZWFzdXJlbWVudCB1cGRhdGVzLiAqL1xuICAgIHByaXZhdGUgZnBzVXBkYXRlSW50ZXJ2YWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgbGFzdCBmcHMgdXBkYXRlLiAqL1xuICAgIHByaXZhdGUgbGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHNpbmNlIHRoZSBsYXN0IGZwcyB1cGRhdGUgd2FzIGRvbmUuICovXG4gICAgcHJpdmF0ZSBmcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaGFzIHN0YXJ0ZWQuICovXG4gICAgcHJpdmF0ZSBzdGFydGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBwYXVzZWQgKi9cbiAgICBwcml2YXRlIHBhdXNlZDogYm9vbGVhbjtcbiAgICBcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIGN1cnJlbnRseSBydW5uaW5nLiAqL1xuICAgIHByaXZhdGUgcnVubmluZzogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHVwZGF0ZSBzdGVwcyB0aGlzIGl0ZXJhdGlvbiBvZiB0aGUgZ2FtZSBsb29wLiAqL1xuICAgIHByaXZhdGUgbnVtVXBkYXRlU3RlcHM6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IDYwO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5tYXhVcGRhdGVGUFM7ICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnBzIHRvIHRoZSBtYXggYWxsb3dlZCBmcHNcbiAgICAgICAgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcblx0fVxuXG5cdGdldEZQUygpOiBudW1iZXIge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0LyoqXG4gICAgICogVXBkYXRlcyB0aGUgZnJhbWUgY291bnQgYW5kIHN1bSBvZiB0aW1lIGZvciB0aGUgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIHRpbWVzdGVwIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlRlBTKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZnBzID0gMC45ICogdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgKiAxMDAwIC8gKHRpbWVzdGFtcCAtIHRoaXMubGFzdEZwc1VwZGF0ZSkgKygxIC0gMC45KSAqIHRoaXMuZnBzO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcblxuICAgICAgICBEZWJ1Zy5sb2coXCJmcHNcIiwgXCJGUFM6IFwiICsgdGhpcy5mcHMudG9GaXhlZCgxKSk7XG4gICAgICAgIFN0YXRzLnVwZGF0ZUZQUyh0aGlzLmZwcyk7XG4gICAgfVxuXG5cdCAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGh5c2ljcyBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gaW5pdE1heCBUaGUgbWF4IGZyYW1lcmF0ZVxuICAgICAqL1xuICAgIHNldE1heFVwZGF0ZUZQUyhpbml0TWF4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSBpbml0TWF4O1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbXVtIHJlbmRlcmluZyBmcmFtZXJhdGVcbiAgICAgKiBAcGFyYW0gbWF4RlBTIFRoZSBtYXggZnJhbWVyYXRlXG4gICAgICovXG4gICAgc2V0TWF4RlBTKG1heEZQUzogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAvbWF4RlBTO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgZ2FtZSBsb29wIHBhbmljcywgaS5lLiBpdCB0cmllcyB0byBwcm9jZXNzIHRvbyBtdWNoIHRpbWUgaW4gYW4gZW50aXJlIGZyYW1lLlxuXHQgKiBUaGlzIHdpbGwgcmVzZXQgdGhlIGFtb3VudCBvZiB0aW1lIGJhY2sgdG8gemVyby5cblx0ICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSBkaXNjYXJkaW5nIGZyb20gcHJvY2Vzc2luZy5cblx0ICovXG5cdHJlc2V0RnJhbWVEZWx0YSgpIDogbnVtYmVyIHtcbiAgICAgICAgbGV0IG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xuICAgIH1cblxuXHQvKipcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcCBhbmQgY2FsbHMgdGhlIGZpcnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAqL1xuXHRzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYoIXRoaXMuc3RhcnRlZCl7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHRoaXMuZG9GaXJzdEZyYW1lKHRpbWVzdGFtcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xuXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYW55IHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhbWVcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZSBvZiB0aGUgZnJhbWUgaW4gbXNcblx0ICovXG5cdHByb3RlY3RlZCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gVXBkYXRlIHRoZSBhbW91bnQgb2YgdGltZSB3ZSBuZWVkIG91ciB1cGRhdGUgdG8gcHJvY2Vzc1xuXHRcdHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWU7XG5cblx0XHQvLyBTZXQgdGhlIG5ldyB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZXJhdGVcbiAgICAgICAgaWYodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCl7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZQUyh0aW1lc3RhbXApO1xuICAgICAgICB9XG5cblx0XHQvLyBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmcmFtZXNcbiAgICAgICAgdGhpcy5mcmFtZSsrO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xuXHR9XG5cblx0LyoqXG4gICAgICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZS4gVXBkYXRlcyB1bnRpbCB0aGUgY3VycmVudCB0aW1lIGlzIHJlYWNoZWQuIFJlbmRlcnMgb25jZVxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIElmIGEgcGF1c2Ugd2FzIGV4ZWN1dGVkLCBzdG9wIGRvaW5nIHRoZSBsb29wLlxuICAgICAgICBpZih0aGlzLnBhdXNlZCl7IFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgdG8gcHJlcGFyZSBmb3IgYW5vdGhlciB1cGRhdGUgb3IgcmVuZGVyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHRyeWluZyB0byByZW5kZXIgdG9vIHNvb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHRpbWVzdGFtcCA8IHRoaXMubGFzdEZyYW1lVGltZSArIHRoaXMubWluRnJhbWVEZWxheSl7XG4gICAgICAgICAgICByZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXG5cdFx0dGhpcy5zdGFydEZyYW1lKHRpbWVzdGFtcCk7XG5cblx0XHQvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxuXHRcdHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xuXHRcdGxldCBwYW5pYyA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnVwZGF0ZVRpbWVzdGVwKXtcblx0XHRcdC8vIERvIGFuIHVwZGF0ZVxuXHRcdFx0dGhpcy5fZG9VcGRhdGUodGhpcy51cGRhdGVUaW1lc3RlcC8xMDAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSB1cGRhdGUgc3RlcCB0aW1lIGZyb20gdGhlIHRpbWUgd2UgaGF2ZSB0byBwcm9jZXNzXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcblxuXHRcdFx0Ly8gSW5jcmVtZW50IHN0ZXBzIGFuZCBjaGVjayBpZiB3ZSd2ZSBkb25lIHRvbyBtYW55XG4gICAgICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XG4gICAgICAgICAgICBpZih0aGlzLm51bVVwZGF0ZVN0ZXBzID4gMTAwKXtcbiAgICAgICAgICAgICAgICBwYW5pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGVzIGFyZSBkb25lLCByZW5kZXJcbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcblxuICAgICAgICAvLyBXcmFwIHVwIHRoZSBmcmFtZVxuICAgICAgICB0aGlzLmZpbmlzaEZyYW1lKHBhbmljKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZSBhbmQgaGFuZGxlcyB0aGUgcGFuaWMgc3RhdGUgaWYgdGhlcmUgaXMgb25lXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCBwYW5pY2tlZFxuXHQgKi9cblx0cHJvdGVjdGVkIGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZCB7XG5cdFx0aWYocGFuaWMpIHtcbiAgICAgICAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLnJlc2V0RnJhbWVEZWx0YSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XG4gICAgICAgIH1cblx0fVxuXG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcbmltcG9ydCBSZWNvcmRlciBmcm9tIFwiLi4vUGxheWJhY2svUmVjb3JkZXJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBHYW1lT3B0aW9ucyBmcm9tIFwiLi9HYW1lT3B0aW9uc1wiO1xuaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XG5pbXBvcnQgRml4ZWRVcGRhdGVHYW1lTG9vcCBmcm9tIFwiLi9GaXhlZFVwZGF0ZUdhbWVMb29wXCI7XG5pbXBvcnQgRW52aXJvbm1lbnRJbml0aWFsaXplciBmcm9tIFwiLi9FbnZpcm9ubWVudEluaXRpYWxpemVyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5cbi8qKlxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBIYW5kbGVzIHRoZSB1cGRhdGUgb3JkZXIsIGFuZCBpbml0aWFsaXplcyBhbGwgc3Vic3lzdGVtcy5cbiAqIFRoZSBHYW1lIG1hbmFnZXMgdGhlIHVwZGF0ZSBjeWNsZSwgYW5kIHJlcXVlc3RzIGFuaW1hdGlvbiBmcmFtZXMgdG8gcmVuZGVyIHRvIHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgICBnYW1lT3B0aW9uczogR2FtZU9wdGlvbnM7XG4gICAgcHJpdmF0ZSBzaG93RGVidWc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBzaG93U3RhdHM6IGJvb2xlYW47XG5cbiAgICAvLyBUaGUgZ2FtZSBsb29wXG4gICAgcHJpdmF0ZSBsb29wOiBHYW1lTG9vcDtcblxuICAgIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxuICAgIHJlYWRvbmx5IEdBTUVfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICByZWFkb25seSBERUJVR19DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xuXHRyZWFkb25seSBXSURUSDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IEhFSUdIVDogbnVtYmVyO1xuICAgIHByaXZhdGUgdmlld3BvcnQ6IFZpZXdwb3J0O1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBjbGVhckNvbG9yOiBDb2xvcjtcbiAgICBcbiAgICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cdHByaXZhdGUgaW5wdXRIYW5kbGVyOiBJbnB1dEhhbmRsZXI7XG5cdHByaXZhdGUgcmVjb3JkZXI6IFJlY29yZGVyO1xuICAgIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgcHJpdmF0ZSBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR2FtZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBHYW1lIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pe1xuICAgICAgICAvLyBCZWZvcmUgYW55dGhpbmcgZWxzZSwgYnVpbGQgdGhlIGVudmlyb25tZW50XG4gICAgICAgIEVudmlyb25tZW50SW5pdGlhbGl6ZXIuc2V0dXAoKTtcblxuICAgICAgICAvLyBUeXBlY2FzdCB0aGUgY29uZmlnIG9iamVjdCB0byBhIEdhbWVDb25maWcgb2JqZWN0XG4gICAgICAgIHRoaXMuZ2FtZU9wdGlvbnMgPSBHYW1lT3B0aW9ucy5wYXJzZShvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd0RlYnVnO1xuICAgICAgICB0aGlzLnNob3dTdGF0cyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIGdhbWUgbG9vcFxuICAgICAgICB0aGlzLmxvb3AgPSBuZXcgRml4ZWRVcGRhdGVHYW1lTG9vcCgpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgZ2FtZSBjYW52YXMgYW5kIGdpdmUgaXQgYSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgIHRoaXMuR0FNRV9DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLWNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5ERUJVR19DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWJ1Zy1jYW52YXNcIik7XG4gICAgXG4gICAgICAgIC8vIEdpdmUgdGhlIGNhbnZhcyBhIHNpemUgYW5kIGdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgdGhpcy5XSURUSCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS54O1xuICAgICAgICB0aGlzLkhFSUdIVCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIC8vIFRoaXMgc3RlcCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhlIHJlc291cmNlIG1hbmFnZXIgZG9lcyBhbnl0aGluZ1xuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnVzZVdlYkdMKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBXZWJHTFJlbmRlcmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVHYW1lV2luZG93KCk7XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmluaXRpYWxpemVDYW52YXModGhpcy5HQU1FX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLnIsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5nLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuYik7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWJ1Z2dpbmcgYW5kIHN0YXRzXG4gICAgICAgIERlYnVnLmluaXRpYWxpemVEZWJ1Z0NhbnZhcyh0aGlzLkRFQlVHX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgICAgICBTdGF0cy5pbml0U3RhdHMoKTtcblxuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhdHMgb3V0cHV0IGFuZCBtYWtlIGl0IG5vIGxvbmdlciBoaWRkZW5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHNcIikuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaXplIHRoZSB2aWV3cG9ydCB0byB0aGUgZ2FtZSBjYW52YXNcbiAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChjYW52YXNTaXplLCB0aGlzLmdhbWVPcHRpb25zLnpvb21MZXZlbCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IGdhbWUgc3Vic3lzdGVtc1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gbmV3IElucHV0SGFuZGxlcih0aGlzLkdBTUVfQ0FOVkFTKTtcbiAgICAgICAgSW5wdXQuaW5pdGlhbGl6ZSh0aGlzLnZpZXdwb3J0LCB0aGlzLmdhbWVPcHRpb25zLmlucHV0cyk7XG4gICAgICAgIHRoaXMucmVjb3JkZXIgPSBuZXcgUmVjb3JkZXIoKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XG4gICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBnYW1lIHdpbmRvdyB0aGF0IGhvbGRzIHRoZSBjYW52YXNlc1xuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGdhbWVXaW5kb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtd2luZG93XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgd2luZG93XG4gICAgICAgIGdhbWVXaW5kb3cuc3R5bGUud2lkdGggPSB0aGlzLldJRFRIICsgXCJweFwiO1xuICAgICAgICBnYW1lV2luZG93LnN0eWxlLmhlaWdodCA9IHRoaXMuSEVJR0hUICsgXCJweFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyB0aGUgU2NlbmVNYW5hZ2VyIGZyb20gdGhlIEdhbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgU2NlbmVNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0U2NlbmVNYW5hZ2VyKCk6IFNjZW5lTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGdhbWVcbiAgICAgKi9cbiAgICBzdGFydChJbml0aWFsU2NlbmU6IG5ldyAoLi4uYXJnczogYW55KSA9PiBTY2VuZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICAvLyBTZXQgdGhlIHVwZGF0ZSBmdW5jdGlvbiBvZiB0aGUgbG9vcFxuICAgICAgICB0aGlzLmxvb3AuZG9VcGRhdGUgPSAoZGVsdGFUOiBudW1iZXIpID0+IHRoaXMudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5sb29wLmRvUmVuZGVyID0gKCkgPT4gdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICAvLyBQcmVsb2FkIHJlZ2lzdHJ5IGl0ZW1zXG4gICAgICAgIFJlZ2lzdHJ5TWFuYWdlci5wcmVsb2FkKCk7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaXRlbXMgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgZG9uZSBsb2FkaW5nLCBzdGFydCB0aGUgbG9vcFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBQcmVsb2FkIC0gbG9hZGluZyBmaXJzdCBzY2VuZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoSW5pdGlhbFNjZW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubG9vcC5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFsbCBuZWNlc3Nhcnkgc3Vic3lzdGVtcyBvZiB0aGUgZ2FtZS4gRGVmZXJzIHNjZW5lIHVwZGF0ZXMgdG8gdGhlIHNjZW5lTWFuYWdlclxuICAgICAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWUgc2luZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBldmVudHMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbG9vcFxuICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGRhdGEgc3RydWN0dXJlcyBzbyBnYW1lIG9iamVjdHMgY2FuIHNlZSB0aGUgaW5wdXRcbiAgICAgICAgICAgIElucHV0LnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlY29yZGluZyBvZiB0aGUgZ2FtZVxuICAgICAgICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzY2VuZXNcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNvdW5kc1xuICAgICAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvYWQgb3IgdW5sb2FkIGFueSByZXNvdXJjZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gVXBkYXRlIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgZGVmZXJzIHNjZW5lIHJlbmRlcmluZyB0byB0aGUgc2NlbmVNYW5hZ2VyLiBSZW5kZXJzIHRoZSBkZWJ1ZyBjYW52YXNcbiAgICAgKi9cbiAgICByZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNlc1xuICAgICAgICAgICAgRGVidWcuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmNsZWFyKHRoaXMuY2xlYXJDb2xvcik7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnJlbmRlcigpO1xuXG4gICAgICAgICAgICAvLyBIYWNreSBkZWJ1ZyBtb2RlXG4gICAgICAgICAgICBpZihJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZ1wiKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RGVidWcgPSAhdGhpcy5zaG93RGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlYnVnIHJlbmRlclxuICAgICAgICAgICAgaWYodGhpcy5zaG93RGVidWcpe1xuICAgICAgICAgICAgICAgIERlYnVnLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNob3dTdGF0cyl7XG4gICAgICAgICAgICAgICAgU3RhdHMucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFJlbmRlciAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBOdWxsRnVuYyBmcm9tIFwiLi4vRGF0YVR5cGVzL0Z1bmN0aW9ucy9OdWxsRnVuY1wiO1xuXG4vKipcbiAqIFRoZSBtYWluIGdhbWUgbG9vcCBvZiB0aGUgZ2FtZS4gS2VlcHMgdHJhY2sgb2YgZnBzIGFuZCBoYW5kbGVzIHNjaGVkdWxpbmcgb2YgdXBkYXRlcyBhbmQgcmVuZGVyaW5nLlxuICogVGhpcyBjbGFzcyBpcyBsZWZ0IGFic3RyYWN0LCBzbyB0aGF0IGEgc3ViY2xhc3MgY2FuIGhhbmRsZSBleGFjdGx5IGhvdyB0aGUgbG9vcCBpcyBzY2hlZHVsZWQuXG4gKiBGb3IgYW4gZXhhbXBsZSBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZ2FtZSBsb29wIHNjaGVkdWxpbmcsIGNoZWNrIG91dCBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9nYW1lLWxvb3AuaHRtbClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZUxvb3Age1xuXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgKi9cblx0cHJvdGVjdGVkIF9kb1VwZGF0ZTogRnVuY3Rpb24gPSBOdWxsRnVuYztcblxuXHRzZXQgZG9VcGRhdGUodXBkYXRlOiBGdW5jdGlvbil7XG5cdFx0dGhpcy5fZG9VcGRhdGUgPSB1cGRhdGU7XG5cdH1cblxuXHQvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIHJlbmRlciBvY2N1cnMgKi9cblx0cHJvdGVjdGVkIF9kb1JlbmRlcjogRnVuY3Rpb24gPSBOdWxsRnVuYztcblxuXG5cdHNldCBkb1JlbmRlcihyZW5kZXI6IEZ1bmN0aW9uKXtcblx0XHR0aGlzLl9kb1JlbmRlciA9IHJlbmRlcjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBGUFMgb2YgdGhlIGdhbWVcblx0ICovXG5cdGFic3RyYWN0IGdldEZQUygpOiBudW1iZXI7XG5cblx0LyoqXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3BcbiAgICAgKi9cblx0YWJzdHJhY3Qgc3RhcnQoKTogdm9pZDtcblxuXHQvKipcblx0ICogUGF1c2VzIHRoZSBnYW1lIGxvb3AsIHVzdWFsbHkgZm9yIGFuIGVycm9yIGNvbmRpdGlvbi5cblx0ICovXG5cdGFic3RyYWN0IHBhdXNlKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlc3VtZXMgdGhlIGdhbWUgbG9vcC5cblx0ICovXG5cdGFic3RyYWN0IHJlc3VtZSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSdW5zIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZ2FtZS4gTm8gdXBkYXRlIG9jY3VycyBoZXJlLCBvbmx5IGEgcmVuZGVyLlxuXHQgKiBUaGlzIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGRlbHRhIHRpbWUgdmFsdWVzXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJ1biBiZWZvcmUgYW55IHVwZGF0ZXMgb3IgdGhlIHJlbmRlciBvZiBhIGZyYW1lLlxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogVGhlIGNvcmUgb2YgdGhlIGZyYW1lLCB3aGVyZSBhbnkgbmVjZXNzYXJ5IHVwZGF0ZXMgb2NjdXIsIGFuZCB3aGVyZSBhIHJlbmRlciBoYXBwZW5zXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBXcmFwcyB1cCB0aGUgZnJhbWVcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSB1cGRhdGUgY3ljbGUgcGFuaWNrZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRvbyBtYW55IHVwZGF0ZXMgdHJ5IHRvIGhhcHBlbiBpbiBhIHNpbmdsZSBmcmFtZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZDtcbn0iLCIvLyBAaWdub3JlUGFnZVxuXG4vKiogVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgQHJlZmVyZW5jZVtHYW1lTG9vcF0gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVPcHRpb25zIHtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgY2FudmFzU2l6ZToge3g6IG51bWJlciwgeTogbnVtYmVyfTtcblxuICAgIC8qIFRoZSBkZWZhdWx0IGxldmVsIG9mIHpvb20gKi9cbiAgICB6b29tTGV2ZWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgY29sb3IgdG8gY2xlYXIgdGhlIGNhbnZhcyB0byBlYWNoIGZyYW1lICovXG4gICAgY2xlYXJDb2xvcjoge3I6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXJ9XG5cbiAgICAvKiBBIGxpc3Qgb2YgaW5wdXQgYmluZGluZ3MgKi9cbiAgICBpbnB1dHM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz59PjtcblxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBkZWJ1ZyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXG4gICAgc2hvd0RlYnVnOiBib29sZWFuO1xuXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIHN0YXRzIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cbiAgICBzaG93U3RhdHM6IGJvb2xlYW47XG5cbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0byB1c2Ugd2ViR0wgKi9cbiAgICB1c2VXZWJHTDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZGF0YSBpbiB0aGUgcmF3IG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGdhbWUgb3B0aW9ucyBhcyBhIFJlY29yZFxuICAgICAqIEByZXR1cm5zIEEgdmVyc2lvbiBvZiB0aGUgb3B0aW9ucyBjb252ZXJ0ZWQgdG8gYSBHYW1lT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IEdhbWVPcHRpb25zIHtcbiAgICAgICAgbGV0IGdPcHQgPSBuZXcgR2FtZU9wdGlvbnMoKTtcblxuICAgICAgICBnT3B0LmNhbnZhc1NpemUgPSBvcHRpb25zLmNhbnZhc1NpemUgPyBvcHRpb25zLmNhbnZhc1NpemUgOiB7eDogODAwLCB5OiA2MDB9O1xuICAgICAgICBnT3B0Lnpvb21MZXZlbCA9IG9wdGlvbnMuem9vbUxldmVsID8gb3B0aW9ucy56b29tTGV2ZWwgOiAxO1xuICAgICAgICBnT3B0LmNsZWFyQ29sb3IgPSBvcHRpb25zLmNsZWFyQ29sb3IgPyBvcHRpb25zLmNsZWFyQ29sb3IgOiB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NX07XG4gICAgICAgIGdPcHQuaW5wdXRzID0gb3B0aW9ucy5pbnB1dHMgPyBvcHRpb25zLmlucHV0cyA6IFtdO1xuICAgICAgICBnT3B0LnNob3dEZWJ1ZyA9ICEhb3B0aW9ucy5zaG93RGVidWc7XG4gICAgICAgIGdPcHQuc2hvd1N0YXRzID0gISFvcHRpb25zLnNob3dTdGF0cztcbiAgICAgICAgZ09wdC51c2VXZWJHTCA9ICEhb3B0aW9ucy51c2VXZWJHTDtcblxuICAgICAgICByZXR1cm4gZ09wdDtcbiAgICB9XG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuL0dhbWVOb2RlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWdpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW4gdGhlIGdhbWUgd29ybGQgdGhhdCBjYW4gYmUgZHJhd24gdG8gdGhlIHNjcmVlblxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgR2FtZU5vZGUgaW1wbGVtZW50cyBSZWdpb24ge1xuXHRwcml2YXRlIF9zaXplOiBWZWMyO1xuXHRwcml2YXRlIF9zY2FsZTogVmVjMjtcblx0cHJpdmF0ZSBfYm91bmRhcnk6IEFBQkI7XG5cdHByaXZhdGUgX2hhc0N1c3RvbVNoYWRlcjogYm9vbGVhbjtcblx0cHJpdmF0ZSBfY3VzdG9tU2hhZGVyS2V5OiBzdHJpbmc7XG5cdHByaXZhdGUgX2FscGhhOiBudW1iZXI7XG5cblx0LyoqIEEgZmxhZyBmb3Igd2hldGhlciBvciBub3QgdGhlIENhbnZhc05vZGUgaXMgdmlzaWJsZSAqL1xuXHR2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblx0XG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl9zaXplID0gbmV3IFZlYzIoMCwgMCk7XG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuX3NjYWxlID0gbmV3IFZlYzIoMSwgMSk7XG5cdFx0dGhpcy5fc2NhbGUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zY2FsZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5fYm91bmRhcnkgPSBuZXcgQUFCQigpO1xuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcblxuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IGZhbHNlO1xuXHR9XG5cblx0Z2V0IGFscGhhKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhO1xuXHR9XG5cblx0c2V0IGFscGhhKGE6IG51bWJlcikge1xuXHRcdHRoaXMuX2FscGhhID0gYTtcblx0fVxuXG5cdGdldCBzaXplKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG5cblx0c2V0IHNpemUoc2l6ZTogVmVjMil7XG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnNpemVDaGFuZ2VkKCk7XG5cdH1cblxuXHRnZXQgc2NhbGUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYWxlO1xuXHR9XG5cblx0c2V0IHNjYWxlKHNjYWxlOiBWZWMyKXtcblx0XHR0aGlzLl9zY2FsZSA9IHNjYWxlO1xuXHRcdC8vIEVudGVyIGFzIGEgbGFtYmRhIHRvIGJpbmQgXCJ0aGlzXCJcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnNjYWxlQ2hhbmdlZCgpO1xuXHR9XG5cblx0c2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKSB7XG5cdFx0dGhpcy5zY2FsZS54ID0gdmFsdWU7XG5cdH1cblxuXHRzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnNjYWxlLnkgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBoYXNDdXN0b21TaGFkZXIoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhc0N1c3RvbVNoYWRlcjtcblx0fVxuXG5cdGdldCBjdXN0b21TaGFkZXJLZXkoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VzdG9tU2hhZGVyS2V5O1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XG5cdFx0c3VwZXIucG9zaXRpb25DaGFuZ2VkKCk7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHR9XG5cblx0LyoqIENhbGxlZCBpZiB0aGUgc2l6ZSB2ZWN0b3IgaXMgY2hhbmdlZCBvciByZXBsYWNlZC4gKi9cblx0cHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcblx0fVxuXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHNjYWxlIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkICovXG5cdHByb3RlY3RlZCBzY2FsZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHR9XG5cblx0Ly8gQGRvY0lnbm9yZVxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiwgc2l6ZSwgb3Igc2NhbGUgb2YgdGhlIENhbnZhc05vZGUgaXMgY2hhbmdlZC4gVXBkYXRlcyB0aGUgYm91bmRhcnkuICovXG5cdHByaXZhdGUgdXBkYXRlQm91bmRhcnkoKTogdm9pZCB7XG5cdFx0dGhpcy5fYm91bmRhcnkuY2VudGVyLnNldCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG5cdFx0dGhpcy5fYm91bmRhcnkuaGFsZlNpemUuc2V0KHRoaXMuc2l6ZS54KnRoaXMuc2NhbGUueC8yLCB0aGlzLnNpemUueSp0aGlzLnNjYWxlLnkvMik7XG5cdH1cblxuXHRnZXQgYm91bmRhcnkoKTogQUFCQiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xuXHR9XG5cblx0Z2V0IHNpemVXaXRoWm9vbSgpOiBWZWMyIHtcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5ib3VuZGFyeS5oYWxmU2l6ZS5jbG9uZSgpLnNjYWxlZCh6b29tLCB6b29tKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY3VzdG9tIHNoYWRlciB0byB0aGlzIENhbnZhc05vZGVcblx0ICogQHBhcmFtIGtleSBUaGUgcmVnaXN0cnkga2V5IG9mIHRoZSBTaGFkZXJUeXBlXG5cdCAqL1xuXHR1c2VDdXN0b21TaGFkZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSB0cnVlO1xuXHRcdHRoaXMuX2N1c3RvbVNoYWRlcktleSA9IGtleTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50ICh4LCB5KSBpcyBpbnNpZGUgb2YgdGhpcyBjYW52YXMgb2JqZWN0XG5cdCAqIEBwYXJhbSB4IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuXHQgKiBAcGFyYW0geSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgY29udGFpbnMgdGhlIHBvaW50LlxuXHQgKi9cblx0Y29udGFpbnMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnkuY29udGFpbnNQb2ludChuZXcgVmVjMih4LCB5KSk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0ZGVidWdSZW5kZXIoKTogdm9pZCB7XG5cdFx0RGVidWcuZHJhd0JveCh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuc2l6ZVdpdGhab29tLCBmYWxzZSwgQ29sb3IuQkxVRSk7XG5cdFx0c3VwZXIuZGVidWdSZW5kZXIoKTtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllclwiO1xuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcbmltcG9ydCB7IGlzUmVnaW9uIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XG5pbXBvcnQgQWN0b3IgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGVcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuQ29udHJvbGxlclwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9DaXJjbGVcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkLlxuICogVG8gY29uc3RydWN0IEdhbWVOb2Rlcywgc2VlIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFBvc2l0aW9uZWQsIFVuaXF1ZSwgVXBkYXRlYWJsZSwgUGh5c2ljYWwsIEFjdG9yLCBEZWJ1Z1JlbmRlcmFibGUge1xuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XG5cblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfaWQ6IG51bWJlcjtcblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcblx0bW92aW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbldhbGw6IGJvb2xlYW4gPSBmYWxzZTtcblx0b25DZWlsaW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXHRjb2xsaXNpb25TaGFwZTogU2hhcGU7XG5cdGNvbGxpZGVyT2Zmc2V0OiBWZWMyO1xuXHRpc1N0YXRpYzogYm9vbGVhbjtcblx0aXNDb2xsaWRhYmxlOiBib29sZWFuO1xuXHRpc1RyaWdnZXI6IGJvb2xlYW47XG5cdHRyaWdnZXJNYXNrOiBudW1iZXI7XG5cdHRyaWdnZXJFbnRlcnM6IEFycmF5PHN0cmluZz47XG5cdHRyaWdnZXJFeGl0czogQXJyYXk8c3RyaW5nPjtcblx0X3ZlbG9jaXR5OiBWZWMyO1xuXHRzd2VwdFJlY3Q6IEFBQkI7XG5cdGNvbGxpZGVkV2l0aFRpbGVtYXA6IGJvb2xlYW47XG5cdGdyb3VwOiBudW1iZXI7XG5cdGlzUGxheWVyOiBib29sZWFuO1xuXHRpc0NvbGxpZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0X2FpOiBBSTtcblx0YWlBY3RpdmU6IGJvb2xlYW47XG5cdHBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXHRwYXRoZmluZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBHRU5FUkFMIC0tLS0tLS0tLS0qL1xuXHQvKiogQW4gZXZlbnQgcmVjZWl2ZXIuICovXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdC8qKiBBbiBldmVudCBlbWl0dGVyLiAqL1xuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblx0LyoqIFRoZSB2aXN1YWwgbGF5ZXIgdGhpcyBHYW1lTm9kZSByZXNpZGVzIGluLiAqL1xuXHRwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xuXHQvKiogQSB1dGlsaXR5IHRoYXQgYWxsb3dzIHRoZSB1c2Ugb2YgdHdlZW5zIG9uIHRoaXMgR2FtZU5vZGUgKi9cblx0dHdlZW5zOiBUd2VlbkNvbnRyb2xsZXI7XG5cdC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cblx0cm90YXRpb246IG51bWJlcjtcblx0LyoqIFRoZSBvcGFjaXR5IHZhbHVlIG9mIHRoaXMgR2FtZU5vZGUgKi9cblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XG5cblx0YWJzdHJhY3QgZ2V0IGFscGhhKCk6IG51bWJlcjtcblxuXHQvLyBDb25zdHJ1Y3RvciBkb2NzIGFyZSBpZ25vcmVkLCBhcyB0aGUgdXNlciBzaG91bGQgTk9UIGNyZWF0ZSBuZXcgR2FtZU5vZGVzIHdpdGggYSByYXcgY29uc3RydWN0b3Jcblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXHRcdHRoaXMudHdlZW5zID0gbmV3IFR3ZWVuQ29udHJvbGxlcih0aGlzKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0fVxuXG5cdGRlc3Ryb3koKXtcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xuXHRcdFx0dGhpcy5yZW1vdmVQaHlzaWNzKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5fYWkuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZW1vdmVBY3Rvcih0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcblxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xuXHRnZXQgcG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuXHR9XG5cblx0c2V0IHBvc2l0aW9uKHBvczogVmVjMikge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucG9zaXRpb25DaGFuZ2VkKCk7XG5cdH1cblxuXHRnZXQgcmVsYXRpdmVQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBwb2ludCB0byBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgem9vbSBhbmQgb3JpZ2luIG9mIHRoaXMgbm9kZVxuXHQgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNvbnZlclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcblx0ICovXG5cdGluUmVsYXRpdmVDb29yZGluYXRlcyhwb2ludDogVmVjMik6IFZlYzIge1xuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cdFx0cmV0dXJuIHBvaW50LmNsb25lKCkuc3ViKG9yaWdpbikuc2NhbGUoem9vbSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gVU5JUVVFIC0tLS0tLS0tLS0qL1xuXHRnZXQgaWQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH1cblxuXHRzZXQgaWQoaWQ6IG51bWJlcikge1xuXHRcdC8vIGlkIGNhbiBvbmx5IGJlIHNldCBvbmNlXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcblx0XHR9XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdG8gbW92ZSB0aGUgb2JqZWN0LlxuICAgICAqL1xuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcblx0fTtcblxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xuXHRcdHRoaXMucGF0aGZpbmRpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0aGUgb2JqZWN0IHdpbGwgbW92ZS5cbiAgICAgKi9cblx0ZmluaXNoTW92ZSgpOiB2b2lkIHtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcblx0XHRpZih0aGlzLnBhdGhmaW5kaW5nKXtcblx0XHRcdHRoaXMucGF0aC5oYW5kbGVQYXRoUHJvZ3Jlc3ModGhpcyk7XG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xuXHRcdFx0dGhpcy5wYXRoZmluZGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcblx0ICogQHBhcmFtIGNvbGxpc2lvblNoYXBlIFRoZSBjb2xsaWRlciBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXMgaGFzIGEgcmVnaW9uIChpbXBsZW1lbnRzIFJlZ2lvbiksXG5cdCAqIGl0IHdpbGwgYmUgdXNlZCB3aGVuIG5vIGNvbGxpc2lvbiBzaGFwZSBpcyBzcGVjaWZpZWQgKG9yIGlmIGNvbGxpc2lvbiBzaGFwZSBpcyBudWxsKS5cblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIGlzU3RhdGljIFdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90LiBGYWxzZSBieSBkZWZhdWx0XG5cdCAqL1xuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuXHRcdC8vIEluaXRpYWxpemUgdGhlIHBoeXNpY3MgdmFyaWFibGVzXG5cdFx0dGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMub25Hcm91bmQgPSBmYWxzZTtcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gaXNDb2xsaWRhYmxlO1xuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcblx0XHR0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdHMgPSBuZXcgQXJyYXkoMzIpO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcblx0XHR0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3VwID0gLTE7XHRcdFx0XHRcdC8vIFRoZSBkZWZhdWx0IGdyb3VwLCBjb2xsaWRlcyB3aXRoIGV2ZXJ5dGhpbmdcblxuXHRcdC8vIFNldCB0aGUgY29sbGlzaW9uIHNoYXBlIGlmIHByb3ZpZGVkLCBvciBzaW1wbHkgdXNlIHRoZSB0aGUgcmVnaW9uIGlmIHRoZXJlIGlzIG9uZS5cblx0XHRpZihjb2xsaXNpb25TaGFwZSl7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb247XG5cdFx0fSBlbHNlIGlmIChpc1JlZ2lvbih0aGlzKSkge1xuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9ICg8YW55PnRoaXMpLmJvdW5kYXJ5LmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxuXHRcdGlmKGNvbGxpZGVyT2Zmc2V0KXtcblx0XHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBjb2xsaWRlck9mZnNldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzd2VwdCByZWN0XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSB0aGlzLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIG9iamVjdCB3aXRoIHBoeXNpY3Ncblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cdH1cblxuXHQvKiogUmVtb3ZlcyB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XG5cdFx0Ly8gUmVtb3ZlIHRoaXMgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLmRlcmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cblx0XHQvLyBOdWxsaWZ5IGFsbCBwaHlzaWNzIGZpZWxkc1xuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IGZhbHNlO1xuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuXHRcdHRoaXMub25XYWxsID0gZmFsc2U7XG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG5cdFx0dGhpcy50cmlnZ2VyTWFzayA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG51bGw7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JvdXAgPSAtMTtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcblx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcblx0fVxuXG5cdC8qKiBEaXNhYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cblx0ZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcblx0fVxuXG5cdC8qKiBSZWVuYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXG5cdHVuZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XG5cdH1cblxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cbiAgICBkaXNhYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR9XG5cbiAgICAvKiogRW5hYmxlcyB0aGlzIG9iamVjdCB0byBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBkaXNhYmxlUGh5c2ljcyB3YXMgY2FsbGVkICovXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sbGlkZXIgZm9yIHRoaXMgR2FtZU5vZGVcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXG5cdCAqL1xuXHRzZXRDb2xsaXNpb25TaGFwZShjb2xsaWRlcjogU2hhcGUpOiB2b2lkIHtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIuY29weSh0aGlzLnBvc2l0aW9uKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCBhY3RpdmF0ZXMgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gb25FbnRlciBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxuICAgICAqL1xuICAgIHNldFRyaWdnZXIoZ3JvdXA6IHN0cmluZywgb25FbnRlcjogc3RyaW5nLCBvbkV4aXQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSB0cnVlO1xuXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcblx0XHRsZXQgbGF5ZXJOdW1iZXIgPSB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZ2V0R3JvdXBOdW1iZXIoZ3JvdXApO1xuXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xuXHRcdFx0Y29uc29sZS53YXJuKGBUcmlnZ2VyIGZvciBHYW1lTm9kZSAke3RoaXMuaWR9IG5vdCBzZXQgLSBncm91cCBcIiR7Z3JvdXB9XCIgd2FzIG5vdCByZWNvZ25pemVkIGJ5IHRoZSBwaHlzaWNzIG1hbmFnZXIuYCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIHRyaWdnZXIgbWFza1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XG5cblx0XHQvLyBMYXllciBudW1iZXJzIGFyZSBiaXRzLCBzbyBnZXQgd2hpY2ggYml0IGl0IGlzXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcblxuXHRcdC8vIFNldCB0aGUgZXZlbnQgbmFtZXNcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcblx0XHR0aGlzLnRyaWdnZXJFeGl0c1tpbmRleF0gPSBvbkV4aXQ7XG5cdH07XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdC8qKlxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cblx0ICovXG5cdHNldEdyb3VwKGdyb3VwOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVuZWRcblx0Z2V0TGFzdFZlbG9jaXR5KCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl92ZWxvY2l0eTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0Z2V0IGFpKCk6IEFJIHtcblx0XHRyZXR1cm4gdGhpcy5fYWk7XG5cdH1cblxuXHRzZXQgYWkoYWk6IEFJKSB7XG5cdFx0aWYoIXRoaXMuX2FpKXtcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FpID0gYWk7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWRkQUk8VCBleHRlbmRzIEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRpZighdGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBhaSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FpID0gbmV3IGFpKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWkuaW5pdGlhbGl6ZUFJKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0c2V0QUlBY3RpdmUoYWN0aXZlOiBib29sZWFuLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IGFjdGl2ZTtcblx0XHRpZih0aGlzLmFpQWN0aXZlKXtcblx0XHRcdHRoaXMuYWkuYWN0aXZhdGUob3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0LyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xuXHRzZXQgcG9zaXRpb25YKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBwb3NpdGlvblkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuXHR9XG5cblx0YWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcblxuXHRhYnN0cmFjdCBzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpO1xuXG5cdC8qLS0tLS0tLS0tLSBHQU1FIE5PREUgLS0tLS0tLS0tLSovXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0by5cblx0ICovXG5cdHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzY2VuZSB0aGlzIG9iamVjdCBpcyBpbi4gXG5cdCAqIEByZXR1cm5zIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvXG5cdCovXG5cdGdldFNjZW5lKCk6IFNjZW5lIHtcblx0XHRyZXR1cm4gdGhpcy5zY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsYXllciBvZiB0aGlzIG9iamVjdC5cblx0ICogQHBhcmFtIGxheWVyIFRoZSBsYXllciB0aGlzIG9iamVjdCB3aWxsIGJlIG9uLlxuXHQgKi9cblx0c2V0TGF5ZXIobGF5ZXI6IExheWVyKTogdm9pZCB7XG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQgKiBAcmV0dXJucyBUaGlzIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQqL1xuXHRnZXRMYXllcigpOiBMYXllciB7XG5cdFx0cmV0dXJuIHRoaXMubGF5ZXI7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiB2ZWN0b3IgaXMgbW9kaWZpZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGlmKHRoaXMuY29sbGlkZXJPZmZzZXQpe1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5hZGQodGhpcy5jb2xsaWRlck9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGlzIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSB1cGRhdGUuXG5cdCAqL1xuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBEZWZlciBldmVudCBoYW5kbGluZyB0byBBSS5cblx0XHR3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcblx0XHRcdHRoaXMuX2FpLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcblx0XHQvLyBEcmF3IHRoZSBwb3NpdGlvbiBvZiB0aGlzIEdhbWVOb2RlXG5cdFx0RGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XG5cblx0XHQvLyBJZiB2ZWxvY2l0eSBpcyBub3QgemVybywgZHJhdyBhIHZlY3RvciBmb3IgaXRcblx0XHRpZih0aGlzLl92ZWxvY2l0eSAmJiAhdGhpcy5fdmVsb2NpdHkuaXNaZXJvKCkpe1xuXHRcdFx0RGVidWcuZHJhd1JheSh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuX3ZlbG9jaXR5LmNsb25lKCkuc2NhbGVUbygyMCkuYWRkKHRoaXMucmVsYXRpdmVQb3NpdGlvbiksIENvbG9yLkJMVUUpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgaGFzIGEgY29sbGlkZXIsIGRyYXcgaXRcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGxldCBjb2xvciA9IHRoaXMuaXNDb2xsaWRpbmcgPyBDb2xvci5SRUQgOiBDb2xvci5HUkVFTjtcblxuXHRcdFx0aWYodGhpcy5pc1RyaWdnZXIpe1xuXHRcdFx0XHRjb2xvciA9IENvbG9yLk1BR0VOVEE7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbG9yLmEgPSAwLjI7XG5cblx0XHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdFx0RGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUuc2NhbGVkKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCB0cnVlLCBjb2xvcik7XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIENpcmNsZSl7XG5cdFx0XHRcdERlYnVnLmRyYXdDaXJjbGUodGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmh3KnRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCksIHRydWUsIGNvbG9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGVudW0gVHdlZW5hYmxlUHJvcGVydGllc3tcblx0cG9zWCA9IFwicG9zaXRpb25YXCIsXG5cdHBvc1kgPSBcInBvc2l0aW9uWVwiLFxuXHRzY2FsZVggPSBcInNjYWxlWFwiLFxuXHRzY2FsZVkgPSBcInNjYWxlWVwiLFxuXHRyb3RhdGlvbiA9IFwicm90YXRpb25cIixcblx0YWxwaGEgPSBcImFscGhhXCJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgZ2FtZSBvYmplY3QgdGhhdCBkb2Vzbid0IHJlbHkgb24gYW55IHJlc291cmNlcyB0byByZW5kZXIgLSBpdCBpcyBkcmF3biB0byB0aGUgc2NyZWVuIGJ5IHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIEdyYXBoaWMgKi9cbiAgICBjb2xvcjogQ29sb3I7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuUkVEO1xuICAgIH1cblxuICAgIGdldCBhbHBoYSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmNvbG9yLmE7XG5cdH1cblxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XG5cdFx0dGhpcy5jb2xvci5hID0gYTtcblx0fVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYy4gREVQUkVDQVRFRFxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgbmV3IGNvbG9yIG9mIHRoZSBHcmFwaGljLlxuICAgICAqL1xuICAgIHNldENvbG9yKGNvbG9yOiBDb2xvcil7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG59IiwiZXhwb3J0IGVudW0gR3JhcGhpY1R5cGUge1xuXHRQT0lOVCA9IFwiUE9JTlRcIixcblx0UkVDVCA9IFwiUkVDVFwiLFxuXHRMSU5FID0gXCJMSU5FXCIsXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpYyB7XG4gICAgcHJvdGVjdGVkIF9lbmQ6IFZlYzI7XG4gICAgdGhpY2tuZXNzOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFydDogVmVjMiwgZW5kOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAyO1xuXG4gICAgICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cblxuICAgIHNldCBzdGFydChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zO1xuICAgIH1cblxuICAgIGdldCBzdGFydCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfVxuXG4gICAgc2V0IGVuZChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLl9lbmQgPSBwb3M7XG4gICAgfVxuXG4gICAgZ2V0IGVuZCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9XG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKiogQSBiYXNpYyBwb2ludCB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBHcmFwaGljIHtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKiBBIGJhc2ljIHJlY3RhbmdsZSB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEdyYXBoaWMge1xuXG4gICAgLyoqIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFJlY3QgKi9cbiAgICBib3JkZXJDb2xvcjogQ29sb3I7XG5cbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cbiAgICBib3JkZXJXaWR0aDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIGNvbG9yIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBib3JkZXIgY29sb3JcbiAgICAgKi9cbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgc2V0Qm9yZGVyV2lkdGgod2lkdGg6IG51bWJlcil7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcbiAgICB9XG5cbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICB9XG59IiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBbiBzcHJpdGUgd2l0aCBzcGVjaWZpZWQgYW5pbWF0aW9uIGZyYW1lcy4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUNvbHM7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG5cbiAgICBnZXQgcm93cygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cbiAgICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzcHJpdGVzaGVldDogU3ByaXRlc2hlZXQpe1xuICAgICAgICBzdXBlcihzcHJpdGVzaGVldC5uYW1lKTtcbiAgICAgICAgdGhpcy5udW1Db2xzID0gc3ByaXRlc2hlZXQuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHNwcml0ZSB0byB0aGUgc3ByaXRlIHNpemUgc3BlY2lmaWVkIGJ5IHRoZSBzcHJpdGVzaGVldFxuICAgICAgICB0aGlzLnNpemUuc2V0KHNwcml0ZXNoZWV0LnNwcml0ZVdpZHRoLCBzcHJpdGVzaGVldC5zcHJpdGVIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBhbmltYXRpb25zIHRvIHRoZSBhbmltYXRlZCBzcHJpdGVcbiAgICAgICAgZm9yKGxldCBhbmltYXRpb24gb2Ygc3ByaXRlc2hlZXQuYW5pbWF0aW9ucyl7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbWFnZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGluZGV4IG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoKGluZGV4ICUgdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS54LCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL0NhbnZhc05vZGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHNwcml0ZSAtIGFuIGluLWdhbWUgaW1hZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIFRoZSBpZCBvZiB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2VNYW5hZ2VyICovXG4gICAgaW1hZ2VJZDogc3RyaW5nO1xuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cbiAgICBpbWFnZU9mZnNldDogVmVjMjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WDogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHktYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGltYWdlSWQ6IHN0cmluZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW1hZ2VJZCA9IGltYWdlSWQ7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VJZCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWMyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmludmVydFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnZlcnRZID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiBpbWFnZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSB0aWxlbWFwIC0gdGhpcyBjYW4gY29uc2lzdCBvZiBhIGNvbWJpbmF0aW9uIG9mIHRpbGVzZXRzIGluIG9uZSBsYXllclxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBUaWxlbWFwIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyB0aGF0IHRoaXMgdGlsZW1hcCB1c2VzICovXG4gICAgcHJvdGVjdGVkIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0PjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiBhIHRpbGUgaW4gdGhpcyB0aWxlbWFwICovXG4gICAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgZGF0YSAqL1xuICAgIHByb3RlY3RlZCBkYXRhOiBBcnJheTxudW1iZXI+O1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgY29sbGlzaW9uIGRhdGEgKi9cbiAgICBwcm90ZWN0ZWQgY29sbGlzaW9uTWFwOiBBcnJheTxib29sZWFuPjtcblxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgdGlsZW1hcCAqL1xuICAgIG5hbWU6IHN0cmluZztcblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBubyBsb25nZXIgYmUgc3BlY2lmaWMgdG8gVGlsZWRcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhLCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sIHNjYWxlOiBWZWMyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGlsZXNldHMgPSB0aWxlc2V0cztcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xuXG4gICAgICAgIGxldCB0aWxlY291bnQgPSAwO1xuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xuICAgICAgICAgICAgdGlsZWNvdW50ICs9IHRpbGVzZXQuZ2V0VGlsZUNvdW50KCkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXAgPSBuZXcgQXJyYXkodGlsZWNvdW50KTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxuICAgICAgICB0aGlzLnBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGEsIGxheWVyKTtcbiAgICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgdGlsZXNldHMgYXNzb2NhaXRlZCB3aXRoIHRoaXMgdGlsZW1hcC5cbiAgICAgKi9cbiAgICBnZXRUaWxlc2V0cygpOiBUaWxlc2V0W10ge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlc2V0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZy5cbiAgICAgKi9cbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUuc2NhbGVkKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNpemUgdGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAgICogQHJldHVybnMgVGhlIHRpbGUgc2l6ZSB3aXRoIHpvb21cbiAgICAqL1xuICAgIGdldFRpbGVTaXplV2l0aFpvb20oKTogVmVjMiB7XG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlU2l6ZSgpLnNjYWxlKHpvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhpcyB0aWxlbWFwIHRvIHRoZSBwaHlzaWNzIHN5c3RlbVxuICAgICovXG4gICAgYWRkUGh5c2ljcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmdyb3VwID0gLTE7XG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3RlclRpbGVtYXAodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgcG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlRGF0YSBhcnJheVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQ7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCB1c2UgdGlsZWQgZGF0YSBzcGVjaWZpY2FsbHkgLSBpdCBzaG91bGQgYmUgbW9yZSBnZW5lcmFsXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgdGlsZXNldCB1c2luZyB0aGUgZGF0YSBsb2FkZWQgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBEYXRhIFRoZSB0aWxlbWFwIGRhdGEgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIGxheWVyIFRoZSBsYXllciBkYXRhIGZyb20gZmlsZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkO1xufSIsImltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9UaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb3J0aG9nb25hbCB0aWxlbWFwIC0gaS5lLiBhIHRvcCBkb3duIG9yIHBsYXRmb3JtZXIgdGlsZW1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcnRob2dvbmFsVGlsZW1hcCBleHRlbmRzIFRpbGVtYXAge1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRpbGVzXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XG5cbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlIG9yIG5vdFxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwLlxuICAgICAqL1xuICAgIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLm51bUNvbHMsIHRoaXMubnVtUm93cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlciB7XG4gICAgICAgIGxldCBsb2NhbENvb3JkcyA9IHRoaXMuZ2V0Q29sUm93QXQod29ybGRDb29yZHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQXRSb3dDb2wobG9jYWxDb29yZHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXG4gICAgICogQHBhcmFtIHJvd0NvbCBUaGUgY29vcmRpbmF0ZXMgaW4gdGlsZW1hcCBzcGFjZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMik6IG51bWJlciB7XG4gICAgICAgIGlmKHJvd0NvbC54IDwgMCB8fCByb3dDb2wueCA+PSB0aGlzLm51bUNvbHMgfHwgcm93Q29sLnkgPCAwIHx8IHJvd0NvbC55ID49IHRoaXMubnVtUm93cyl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLnhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb25cbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBnZXRUaWxlKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIG5ldyBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgc2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMiwgdHlwZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLng7XG4gICAgICAgIHRoaXMuc2V0VGlsZShpbmRleCwgdHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZVxuICAgICAqIEBwYXJhbSBpbmRleE9yQ29sIFRoZSBpbmRleCBvZiB0aGUgdGlsZSBvciB0aGUgY29sdW1uIGl0IGlzIGluXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IHRoZSB0aWxlIGlzIGluXG4gICAgICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdGlsZSBpcyBjb2xsaWRhYmxlLlxuICAgICAqL1xuICAgIGlzVGlsZUNvbGxpZGFibGUoaW5kZXhPckNvbDogbnVtYmVyLCByb3c/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICAgIGxldCB0aWxlID0gMDtcblxuICAgICAgICBpZihyb3cpe1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbHVtbiBhbmQgYSByb3dcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGVBdFJvd0NvbChuZXcgVmVjMihpbmRleE9yQ29sLCByb3cpKTtcblxuICAgICAgICAgICAgaWYodGlsZSA8IDApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKGluZGV4T3JDb2wgPCAwIHx8IGluZGV4T3JDb2wgPj0gdGhpcy5kYXRhLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgLy8gVGlsZXMgdGhhdCBkb24ndCBleGlzdCBhcmVuJ3QgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gaW5kZXhcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGUoaW5kZXhPckNvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25NYXBbdGlsZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgaW4gd29ybGQgY29vcmRpbmF0ZXMgYW5kIHJldHVybnMgdGhlIHJvdyBhbmQgY29sdW1uIG9mIHRoZSB0aWxlIGF0IHRoYXQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB3b3JsZCBzcGFjZVxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG90ZW50aWFsIHRpbGUgaW4gdGlsZW1hcCBzcGFjZVxuICAgICAqL1xuICAgIGdldENvbFJvd0F0KHdvcmxkQ29vcmRzOiBWZWMyKTogVmVjMiB7XG4gICAgICAgIGxldCBjb2wgPSBNYXRoLmZsb29yKHdvcmxkQ29vcmRzLnggLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLngpO1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy55IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55KTtcblxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoY29sLCByb3cpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGRlYnVnUmVuZGVyKCl7XG4gICAgICAgIC8vIEhhbGYgb2YgdGhlIHRpbGUgc2l6ZVxuICAgICAgICBsZXQgem9vbWVkSGFsZlRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZVdpdGhab29tKCkuc2NhbGVkKDAuNSk7XG4gICAgICAgIGxldCBoYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKDAuNSk7XG5cbiAgICAgICAgLy8gVGhlIGNlbnRlciBvZiB0aGUgdG9wIGxlZnQgdGlsZVxuICAgICAgICBsZXQgdG9wTGVmdCA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5zdWIodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEEgdmVjIHRvIHN0b3JlIHRoZSBjZW50ZXJcbiAgICAgICAgbGV0IGNlbnRlciA9IFZlYzIuWkVSTztcblxuICAgICAgICBmb3IobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnVtQ29sczsgY29sKyspe1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4LXBvc2l0aW9uXG4gICAgICAgICAgICBjZW50ZXIueCA9IHRvcExlZnQueCArIGNvbCoyKmhhbGZUaWxlU2l6ZS54ICsgaGFsZlRpbGVTaXplLng7XG5cbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0NvbGxpZGFibGUgJiYgdGhpcy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeS1wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIueSA9IHRvcExlZnQueSArIHJvdyoyKmhhbGZUaWxlU2l6ZS55ICsgaGFsZlRpbGVTaXplLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyBhIGJveCBmb3IgdGhpcyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoY2VudGVyKSwgem9vbWVkSGFsZlRpbGVTaXplLCBmYWxzZSwgQ29sb3IuQkxVRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIFVJRWxlbWVudCAtIHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhpbmdzIGxpa2UgYnV0dG9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcblx0Ly8gU3R5bGUgYXR0cmlidXRlcyAtIFRPRE8gLSBhYnN0cmFjdCB0aGlzIGludG8gYSBzdHlsZSBvYmplY3QvaW50ZXJmYWNlXG5cdC8qKiBUaGUgYmFja2dvdW5kIGNvbG9yICovXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XG5cdC8qKiBUaGUgYm9yZGVyIGNvbG9yICovXG5cdGJvcmRlckNvbG9yOiBDb2xvcjtcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXG5cdGJvcmRlclJhZGl1czogbnVtYmVyO1xuXHQvKiogVGhlIGJvcmRlciB3aWR0aCAqL1xuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xuXHQvKiogVGhlIHBhZGRpbmcgKi9cblx0cGFkZGluZzogVmVjMjtcblxuXHQvLyBFdmVudEF0dHJpYnV0ZXNcblx0LyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCBvbiBhIGNsaWNrICovXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gY2xpY2sgKi9cblx0b25DbGlja0V2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uRW50ZXI6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xuXHRvbkVudGVyRXZlbnRJZDogc3RyaW5nO1xuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cblx0b25MZWF2ZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcG9nYXRlZCB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uTGVhdmVFdmVudElkOiBzdHJpbmc7XG5cblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBjbGlja2VkIG9uICovXG5cdHByb3RlY3RlZCBpc0NsaWNrZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXG5cdHByb3RlY3RlZCBpc0VudGVyZWQ6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xuXHRcdHRoaXMuYm9yZGVyV2lkdGggPSAxO1xuXHRcdHRoaXMucGFkZGluZyA9IFZlYzIuWkVSTztcblxuXHRcdHRoaXMub25DbGljayA9IG51bGw7XG5cdFx0dGhpcy5vbkNsaWNrRXZlbnRJZCA9IG51bGw7XG5cdFx0dGhpcy5vblJlbGVhc2UgPSBudWxsO1xuXHRcdHRoaXMub25SZWxlYXNlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLm9uRW50ZXIgPSBudWxsO1xuXHRcdHRoaXMub25FbnRlckV2ZW50SWQgPSBudWxsO1xuXHRcdHRoaXMub25MZWF2ZSA9IG51bGw7XG5cdFx0dGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cdHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xuXHRcdHRoaXMucGFkZGluZy5jb3B5KHBhZGRpbmcpO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0c3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cblx0XHQvLyBTZWUgb2YgdGhpcyBvYmplY3Qgd2FzIGp1c3QgY2xpY2tlZFxuXHRcdGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSAmJiB0aGlzLnZpc2libGUgJiYgIXRoaXMubGF5ZXIuaXNIaWRkZW4oKSl7XG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2sgIT09IG51bGwpe1xuXHRcdFx0XHRcdHRoaXMub25DbGljaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMub25DbGlja0V2ZW50SWQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGxldCBkYXRhID0ge307XG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtb3VzZSB3YXNuJ3QganVzdCBwcmVzc2VkLCB0aGVuIHdlIGRlZmluaXRlbHkgd2VyZW4ndCBjbGlja2VkXG5cdFx0aWYoIUlucHV0LmlzTW91c2VQcmVzc2VkKCkpe1xuXHRcdFx0aWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoaXMgZWxlbWVudFxuXHRcdGxldCBtb3VzZVBvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcblx0XHRpZihtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKXtcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcblxuXHRcdFx0aWYodGhpcy5vbkVudGVyICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkVudGVyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uRW50ZXJFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW50ZXJFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZih0aGlzLmlzRW50ZXJlZCkge1xuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYodGhpcy5vbkxlYXZlICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkxlYXZlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uTGVhdmVFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uTGVhdmVFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpIHtcblx0XHRcdC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxuXHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxuXHQgKi9cblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBib3JkZXIgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xuXHQgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcblx0ICovXG5cdGNhbGN1bGF0ZUJvcmRlckNvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcblx0fVxufSIsImltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBIGNsaWNrYWJsZSBidXR0b24gVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBMYWJlbCB7XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XG5cdFx0c3VwZXIocG9zaXRpb24sIHRleHQpO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9IG5ldyBDb2xvcig0MSwgNDYsIDMwKTtcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xuXHRcdC8vIENoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiBjbGlja2VkIG9yIGhvdmVyZWRcblx0XHRpZih0aGlzLmlzRW50ZXJlZCAmJiAhdGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmxpZ2h0ZW4oKTtcblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmRhcmtlbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCBleHRlbmRzIFVJRWxlbWVudHtcblx0LyoqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvZiB0aGlzIFVJRWxlbWVudCAqL1xuXHR0ZXh0Q29sb3I6IENvbG9yO1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXG5cdHRleHQ6IHN0cmluZztcblx0LyoqIFRoZSBuYW1lIG9mIHRoZSBmb250ICovXG5cdGZvbnQ6IHN0cmluZztcblx0LyoqIFRoZSBzaXplIG9mIHRoZSBmb250ICovXG5cdGZvbnRTaXplOiBudW1iZXI7XG5cdC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgaEFsaWduOiBzdHJpbmc7XG5cdC8qKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XG5cblx0LyoqIEEgZmxhZyBmb3IgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGhhcyBiZWVuIG1lYXN1cmVkIG9uIHRoZSBjYW52YXMgZm9yIGF1dG8gd2lkdGggYXNzaWdubWVudCAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUFzc2lnbmVkOiBib29sZWFuO1xuXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHBvc2l0aW9uKTtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuXHRcdHRoaXMuZm9udCA9IFwiQXJpYWxcIjtcblx0XHR0aGlzLmZvbnRTaXplID0gMzA7XG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcblxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSBmb250IGRldGFpbHMgZm9yIHJlbmRlcmluZ1xuXHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmb250IGRldGFpbHNcblx0ICovXG5cdGdldEZvbnRTdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0ZXh0IGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmcgdGhlIHRleHQgY29sb3Jcblx0ICovXG5cdGNhbGN1bGF0ZVRleHRDb2xvcigpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnRleHRDb2xvci50b1N0cmluZ1JHQkEoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIHRoZSBjYW52YXMgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dFxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxuXHQgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIHRleHQgd2lkdGhcblx0ICovXG5cdHByb3RlY3RlZCBjYWxjdWxhdGVUZXh0V2lkdGgoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBudW1iZXIge1xuXHRcdGN0eC5mb250ID0gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdFx0cmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXHR9XG5cblx0c2V0SEFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmhBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0c2V0VkFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnZBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXG5cdCAqL1xuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XG5cdFx0bGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcblx0XHRpZih0aGlzLmhBbGlnbiA9PT0gSEFsaWduLkNFTlRFUil7XG5cdFx0XHRvZmZzZXQueCA9IGhEaWZmLzI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKXtcblx0XHRcdG9mZnNldC54ID0gaERpZmY7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1Ape1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFx0XHRvZmZzZXQueSA9IDA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZBbGlnbiA9PT0gVkFsaWduLkJPVFRPTSl7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueS8yO1xuXHRcdH1cblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0c3VwZXIuc2l6ZUNoYW5nZWQoKTtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xuXHRcdGxldCB3aWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZm9udFNpemU7XG5cdFx0dGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54KjIsIGhlaWdodCArIHRoaXMucGFkZGluZy55KjIpO1xuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsbHkgYXNzaWducyBhIHNpemUgdG8gdGhlIFVJRWxlbWVudCBpZiBub25lIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRoYW5kbGVJbml0aWFsU2l6aW5nKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMuc2l6ZUFzc2lnbmVkKXtcblx0XHRcdHRoaXMuYXV0b1NpemUoY3R4KTtcblx0XHR9XG5cdH1cblxuXHQvKiogT24gdGhlIG5leHQgcmVuZGVyLCBzaXplIHRoaXMgZWxlbWVudCB0byBpdCdzIGN1cnJlbnQgdGV4dCB1c2luZyBpdHMgY3VycmVudCBmb250IHNpemUgKi9cblx0c2l6ZVRvVGV4dCgpOiB2b2lkIHtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xuXHR9XG59XG5cbmV4cG9ydCBlbnVtIFZBbGlnbiB7XG5cdFRPUCA9IFwidG9wXCIsXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXG5cdEJPVFRPTSA9IFwiYm90dG9tXCJcbn1cblxuZXhwb3J0IGVudW0gSEFsaWduIHtcblx0TEVGVCA9IFwibGVmdFwiLFxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxuXHRSSUdIVCA9IFwicmlnaHRcIlxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgVUlFbGVtZW50IHtcbiAgICAvKiogVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXIgZnJvbSBbMCwgMV0gKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgbmliICovXG4gICAgcHVibGljIG5pYkNvbG9yOiBDb2xvcjtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xuICAgIHB1YmxpYyBuaWJTaXplOiBWZWMyO1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciB0cmFjayAqL1xuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XG4gICAgLyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCB0byBhIHZhbHVlIGNoYW5nZSAqL1xuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlOiBGdW5jdGlvbjtcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2VFdmVudElkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xuICAgICAgICBzdXBlcihwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5uaWJDb2xvciA9IENvbG9yLlJFRDtcbiAgICAgICAgdGhpcy5zbGlkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHRoaXMubmliU2l6ZSA9IG5ldyBWZWMyKDEwLCAyMCk7XG5cbiAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBzaXplXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCAyMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogQSBtZXRob2QgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHRoZSB2YWx1ZSBjaGFuZ2luZyAqL1xuICAgIHByb3RlY3RlZCB2YWx1ZUNoYW5nZWQoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCwge3RhcmdldDogdGhpcywgdmFsdWU6IHRoaXMudmFsdWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XG4gICAgICAgICAgICBsZXQgdmFsID0gTWF0aFV0aWxzLmludkxlcnAodGhpcy5wb3NpdGlvbi54IC0gdGhpcy5zaXplLngvMiwgdGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngvMiwgSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGhVdGlscy5jbGFtcDAxKHZhbCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XG5cbi8qKiBBIHRleHQgaW5wdXQgVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XG4gICAgLyoqIEEgZmxhZyB0aGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB0eXBlIGluIHRoaXMgVGV4dElucHV0ICovXG4gICAgZm9jdXNlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cbiAgICBjdXJzb3JDb3VudGVyOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XG4gICAgICAgIHN1cGVyKHBvc2l0aW9uLCBcIlwiKTtcblxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3JDb3VudGVyID0gMDtcblxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcbiAgICAgICAgdGhpcy5zaXplLnNldCgyMDAsIHRoaXMuZm9udFNpemUpO1xuICAgICAgICB0aGlzLmhBbGlnbiA9IFwibGVmdFwiO1xuXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5XSElURTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgaWYoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpe1xuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XG4gICAgICAgICAgICBsZXQga2V5cyA9IElucHV0LmdldEtleXNKdXN0UHJlc3NlZCgpO1xuICAgICAgICAgICAgbGV0IG51bXMgPSBcIjEyMzQ1Njc4OTBcIjtcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XG4gICAgICAgICAgICBsZXQgbGV0dGVycyA9IFwicXdlcnR5dWlvcGFzZGZnaGprbHp4Y3Zibm1cIjtcbiAgICAgICAgICAgIGxldCBtYXNrID0gbnVtcyArIHNwZWNpYWxDaGFycyArIGxldHRlcnM7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICBsZXQgc2hpZnRQcmVzc2VkID0gSW5wdXQuaXNLZXlQcmVzc2VkKFwic2hpZnRcIik7XG4gICAgICAgICAgICBsZXQgYmFja3NwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJiYWNrc3BhY2VcIik7XG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihiYWNrc3BhY2VQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihzcGFjZVByZXNzZWQpe1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBcIiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZihzaGlmdFByZXNzZWQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcblx0QlVUVE9OID0gXCJCVVRUT05cIixcblx0TEFCRUwgPSBcIkxBQkVMXCIsXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXG5cdFRFWFRfSU5QVVQgPSBcIlRFWFRJTlBVVFwiXG59IiwiaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvTmF2aWdhYmxlXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi9OYXZpZ2F0aW9uUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBtYW5hZ2VyIGNsYXNzIGZvciBuYXZpZ2F0aW9uLlxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcbiAqIGZyb20gb25lIHBvc2l0aW9uIHRvIGFub3RoZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcblx0LyoqIFRoZSBsaXN0IG9mIGFsbCBuYXZpZ2FibGUgZW50aXRpZXMgKi9cblx0cHJvdGVjdGVkIG5hdmlnYWJsZUVudGl0aWVzOiBNYXA8TmF2aWdhYmxlPjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBuYXZpZ2FibGUgZW50aXRyeVxuXHQgKiBAcGFyYW0gbmF2IFRoZSBhY3R1YWwgTmF2aWdhYmxlIGluc3RhbmNlXG5cdCAqL1xuXHRhZGROYXZpZ2FibGVFbnRpdHkobmF2TmFtZTogc3RyaW5nLCBuYXY6IE5hdmlnYWJsZSk6IHZvaWQge1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMuYWRkKG5hdk5hbWUsIG5hdik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxuXHQgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBOYXZpZ2FibGUgb2JqZWN0XG5cdCAqIEBwYXJhbSBmcm9tUG9zaXRpb24gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIG5hdmlnYXRpb25cblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXG5cdCAqIEByZXR1cm5zIEEgTmF2aWdhdGlvblBhdGggY29udGFpbmluZyB0aGUgcm91dGUgdG8gdGFrZSBvdmVyIHRoZSBOYXZpZ2FibGUgZW50aXR5IHRvIGdldCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbnMuXG5cdCAqL1xuXHRnZXRQYXRoKG5hdk5hbWU6IHN0cmluZywgZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xuXHRcdGxldCBuYXYgPSB0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmdldChuYXZOYW1lKTtcblx0XHRyZXR1cm4gbmF2LmdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbi5jbG9uZSgpLCB0b1Bvc2l0aW9uLmNsb25lKCkpO1xuXHR9XG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG4vKipcbiAqIEEgcGF0aCB0aGF0IEFJcyBjYW4gZm9sbG93LiBVc2VzIGZpbmlzaE1vdmUoKSBpbiBQaHlzaWNhbCB0byBkZXRlcm1pbmUgcHJvZ3Jlc3Mgb24gdGhlIHJvdXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25QYXRoIHtcblx0LyoqIFRoZSBuYXZpZ2F0aW9uIHBhdGgsIHN0b3JlZCBhcyBhIHN0YWNrIG9mIG5leHQgcG9zaXRpb25zICovXG5cdHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcblx0LyoqIFRoZSBjdXJyZW50IGRpcmVjdGlvbiBvZiBtb3ZlbWVudCAqL1xuXHRwcm90ZWN0ZWQgY3VycmVudE1vdmVEaXJlY3Rpb246IFZlYzI7XG5cdC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xuXHRwcm90ZWN0ZWQgZGlzdGFuY2VUaHJlc2hvbGQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIG5ldyBOYXZpZ2F0aW9uUGF0aFxuXHQgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiBub2RlcyB0byB0YWtlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXRoOiBTdGFjazxWZWMyPil7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLmN1cnJlbnRNb3ZlRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSA0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBuYXZpZ2F0aW9uIGFsb25nIHRoaXMgTmF2aWdhdGlvblBhdGhcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGlzRG9uZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gaW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYWxvbmcgdGhlIHBhdGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gbW92ZSBhbG9uZyB0aGUgcGF0aFxuXHQgKiBAcmV0dXJucyBUaGUgbW92ZW1lbnQgZGlyZWN0aW9uIGFzIGEgVmVjMlxuXHQgKi9cblx0Z2V0TW92ZURpcmVjdGlvbihub2RlOiBHYW1lTm9kZSk6IFZlYzIge1xuXHRcdC8vIFJldHVybiBkaXJlY3Rpb24gdG8gbmV4dCBwb2ludCBpbiB0aGUgbmF2XG5cdFx0cmV0dXJuIG5vZGUucG9zaXRpb24uZGlyVG8odGhpcy5wYXRoLnBlZWsoKSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGlzIE5hdmlnYXRpb25QYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSBtb3ZpbmcgYWxvbmcgdGhlIHBhdGhcblx0ICovXG5cdGhhbmRsZVBhdGhQcm9ncmVzcyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuXHRcdGlmKG5vZGUucG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucGF0aC5wZWVrKCkpIDwgdGhpcy5kaXN0YW5jZVRocmVzaG9sZCp0aGlzLmRpc3RhbmNlVGhyZXNob2xkKXtcblx0XHRcdC8vIFdlJ3ZlIHJlYWNoZWQgb3VyIG5vZGUsIG1vdmUgb24gdG8gdGhlIG5leHQgZGVzdGluYXRpb25cblx0XHRcdHRoaXMucGF0aC5wb3AoKTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKVxuXHR9XG59IiwiaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xuaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvTmF2aWdhYmxlXCI7XG5pbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvR3JhcGhVdGlsc1wiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBOYXZtZXNoLiBOYXZtZXNoZXMgYXJlIGdyYXBocyBpbiB0aGUgZ2FtZSB3b3JsZCBhbG9uZyB3aGljaCBub2RlcyBjYW4gbW92ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2bWVzaCBpbXBsZW1lbnRzIE5hdmlnYWJsZSB7XG5cdC8qKiBUaGUgZ3JhcGggb2YgcG9pbnRzIGluIHRoZSBOYXZNZXNoICovXG5cdHByb3RlY3RlZCBncmFwaDogUG9zaXRpb25HcmFwaDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBOYXZtZXNoIGZyb20gdGhlIHBvaW50cyBpbiB0aGUgc3BlZWNpZmllZCBncmFwaFxuXHQgKiBAcGFyYW0gZ3JhcGggVGhlIGdyYXBoIHRvIGNvbnN0cnVjdCBhIG5hdm1lc2ggZnJvbVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZ3JhcGg6IFBvc2l0aW9uR3JhcGgpe1xuXHRcdHRoaXMuZ3JhcGggPSBncmFwaDtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRnZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb246IFZlYzIsIHRvUG9zaXRpb246IFZlYzIpOiBOYXZpZ2F0aW9uUGF0aCB7XG5cdFx0bGV0IHN0YXJ0ID0gdGhpcy5nZXRDbG9zZXN0Tm9kZShmcm9tUG9zaXRpb24pO1xuXHRcdGxldCBlbmQgPSB0aGlzLmdldENsb3Nlc3ROb2RlKHRvUG9zaXRpb24pO1xuXG5cdFx0bGV0IHBhcmVudCA9IEdyYXBoVXRpbHMuZGppa3N0cmEodGhpcy5ncmFwaCwgc3RhcnQpO1xuXG5cdFx0bGV0IHBhdGhTdGFjayA9IG5ldyBTdGFjazxWZWMyPih0aGlzLmdyYXBoLm51bVZlcnRpY2VzKTtcblx0XHRcblx0XHQvLyBQdXNoIHRoZSBmaW5hbCBwb3NpdGlvbiBhbmQgdGhlIGZpbmFsIHBvc2l0aW9uIGluIHRoZSBncmFwaFxuXHRcdHBhdGhTdGFjay5wdXNoKHRvUG9zaXRpb24uY2xvbmUoKSk7XG5cdFx0cGF0aFN0YWNrLnB1c2godGhpcy5ncmFwaC5wb3NpdGlvbnNbZW5kXSk7XG5cblx0XHQvLyBBZGQgYWxsIHBhcmVudHMgYWxvbmcgdGhlIHBhdGhcblx0XHRsZXQgaSA9IGVuZDtcblx0XHR3aGlsZShwYXJlbnRbaV0gIT09IC0xKXtcblx0XHRcdHBhdGhTdGFjay5wdXNoKHRoaXMuZ3JhcGgucG9zaXRpb25zW3BhcmVudFtpXV0pO1xuXHRcdFx0aSA9IHBhcmVudFtpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IE5hdmlnYXRpb25QYXRoKHBhdGhTdGFjayk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY2xvc2VzdCBub2RlIGluIHRoaXMgTmF2bWVzaCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gcXVlcnlcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhlIE5hdm1lc2ggdG8gdGhlIHBvc2l0aW9uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgZ2V0Q2xvc2VzdE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xuXHRcdGxldCBuID0gdGhpcy5ncmFwaC5udW1WZXJ0aWNlcztcblx0XHRsZXQgaSA9IDE7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRsZXQgZGlzdCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLmdyYXBoLnBvc2l0aW9uc1swXSk7XG5cdFx0d2hpbGUoaSA8IG4pe1xuXHRcdFx0bGV0IGQgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ncmFwaC5wb3NpdGlvbnNbaV0pO1xuXHRcdFx0aWYoZCA8IGRpc3Qpe1xuXHRcdFx0XHRkaXN0ID0gZDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fVxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4vUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IEFyZWFDb2xsaXNpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb25cIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuXG4vKipcbiAqIEFMR09SSVRITTpcbiAqIFx0SW4gYW4gZWZmb3J0IHRvIGtlZXAgdGhpbmdzIHNpbXBsZSBhbmQgd29ya2luZyBlZmZlY3RpdmVseSwgZWFjaCBkeW5hbWljIG5vZGUgd2lsbCByZXNvbHZlIGl0c1xuICogXHRjb2xsaXNpb25zIGNvbnNpZGVyaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhcyBzdGF0aWMuXG4gKiBcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcbiAqIFx0ZWZmaWNpZW50LCBhcyBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZvciB0aGlzIGdhbWUgZW5naW5lLiBFdmVyeSBkeW5hbWljIG5vZGUgaXMgY2hlY2tlZCBhZ2FpbnN0IGV2ZXJ5XG4gKiBcdG90aGVyIG5vZGUgZm9yIGNvbGxpc2lvbiBhcmVhLiBJZiBjb2xsaXNpb24gYXJlYSBpcyBub24temVybyAobWVhbmluZyB0aGUgY3VycmVudCBub2RlIHN3ZWVwcyBpbnRvIGFub3RoZXIpLFxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cbiAqIFxuICogXHRJTklUSUFMSVpBVElPTjpcbiAqIFx0XHQtIFBoeXNpY3MgY29uc3RhbnRzIGFyZSByZXNldFxuICogXHRcdC0gU3dlcHQgc2hhcGVzIGFyZSByZWNhbGN1bGF0ZWQuIElmIGEgbm9kZSBpc24ndCBtb3ZpbmcsIGl0IGlzIHNraXBwZWQuXG4gKiBcbiAqIFx0Q09MTElTSU9OIERFVEVDVElPTjpcbiAqIFx0XHQtIEZvciBhIG5vZGUsIGNvbGxpc2lvbiBhcmVhIHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgc3dlcHQgQUFCQiBvZiB0aGUgbm9kZSBhZ2FpbnN0IGV2ZXJ5IG90aGVyIEFBQkIgaW4gYSBzdGF0aWMgc3RhdGVcbiAqIFx0XHQtIFRoZXNlIGNvbGxpc2lvbnMgd2lsbCBiZSBzb3J0ZWQgYnkgYXJlYSBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gKiBcdFxuICogXHRDT0xMSVNJT04gUkVTT0xVVElPTjpcbiAqIFx0XHQtIEZvciBlYWNoIGhpdCwgdGltZSBvZiBjb2xsaXNpb24gaXMgY2FsY3VsYXRlZCB1c2luZyBhIHN3ZXB0IGxpbmUgdGhyb3VnaCB0aGUgQUFCQiBvZiB0aGUgc3RhdGljIG5vZGUgZXhwYW5kZWRcbiAqIFx0XHRcdHdpdGggbWlua293c2tpIHN1bXMgKGRpc2NyZXRlbHksIGJ1dCB0aGUgY29uY2VwdCBpcyB0aGVyZSlcbiAqIFx0XHQtIFRoZSBjb2xsaXNpb24gaXMgcmVzb2x2ZWQgYmFzZWQgb24gdGhlIG5lYXIgdGltZSBvZiB0aGUgY29sbGlzaW9uIChmcm9tIG1ldGhvZCBvZiBzZXBhcmF0ZWQgYXhlcylcbiAqIFx0XHRcdC0gWCBpcyByZXNvbHZlZCBieSBuZWFyIHgsIFkgYnkgbmVhciB5LlxuICogXHRcdFx0LSBUaGVyZSBpcyBzb21lIGZ1ZGdpbmcgdG8gYWxsb3cgZm9yIHNsaWRpbmcgYWxvbmcgd2FsbHMgb2Ygc2VwYXJhdGUgY29sbGlkZXJzLiBTb3J0aW5nIGJ5IGFyZWEgYWxzbyBoZWxwcyB3aXRoIHRoaXMuXG4gKiBcdFx0XHQtIENvcm5lciB0byBjb3JuZXIgY29sbGlzaW9ucyBhcmUgcmVzb2x2ZSB0byBmYXZvciB4LW1vdmVtZW50LiBUaGlzIGlzIGluIGNvbnNpZGVyYXRpb24gb2YgcGxhdGZvcm1lcnMsIHRvIGdpdmVcbiAqIFx0XHRcdFx0dGhlIHBsYXllciBzb21lIGhlbHAgd2l0aCBqdW1wc1xuICogXG4gKiBcdFByb3M6XG4gKiBcdFx0LSBFdmVyeXRoaW5nIGhhcHBlbnMgd2l0aCBhIGNvbnNpc3RlbnQgdGltZS4gVGhlcmUgaXMgYSBkaXN0aW5jdCBiZWZvcmUgYW5kIGFmdGVyIGZvciBlYWNoIHJlc29sdXRpb24uXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cbiAqIFx0XG4gKiBcdENvbnM6XG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BoeXNpY3NNYW5hZ2VyIGV4dGVuZHMgUGh5c2ljc01hbmFnZXIge1xuXG5cdC8qKiBUaGUgYXJyYXkgb2Ygc3RhdGljIG5vZGVzICovXG5cdHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xuXG5cdC8qKiBUaGUgYXJyYXkgb2YgZHluYW1pYyBub2RlcyAqL1xuXHRwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XG5cblx0LyoqIFRoZSBhcnJheSBvZiB0aWxlbWFwcyAqL1xuXHRwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgY29sbGlzaW9uIG1hc2tzIGZvciBlYWNoIGdyb3VwICovXG5cdHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcblxuXHRjb25zdHJ1Y3RvcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmR5bmFtaWNOb2RlcyA9IG5ldyBBcnJheSgpO1xuXHRcdHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcblxuXHRcdC8vIFBhcnNlIG9wdGlvbnNcblx0XHR0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEEgcmVjb3JkIG9mIG9wdGlvbnNcblx0ICovXG5cdHByb3RlY3RlZCBwYXJzZU9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGlmKG9wdGlvbnMuZ3JvdXBOYW1lcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRsZXQgZ3JvdXAgPSBvcHRpb25zLmdyb3VwTmFtZXNbaV07XG5cblx0XHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGdyb3VwIG5hbWUgYW5kIG51bWJlclxuXHRcdFx0XHR0aGlzLmdyb3VwTmFtZXNbaV0gPSBncm91cDtcblxuXHRcdFx0XHR0aGlzLmdyb3VwTWFwLnNldChncm91cCwgMSA8PCBpKTtcblxuXHRcdFx0XHRsZXQgY29sbGlzaW9uTWFzayA9IDA7XG5cblx0XHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IG9wdGlvbnMuY29sbGlzaW9uc1tpXS5sZW5ndGg7IGorKyl7XG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2xsaXNpb25zW2ldW2pdKXtcblx0XHRcdFx0XHRcdGNvbGxpc2lvbk1hc2sgfD0gMSA8PCBqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uTWFza3NbaV0gPSBjb2xsaXNpb25NYXNrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xuXHRcdFx0Ly8gU3RhdGljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5wdXNoKG5vZGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEeW5hbWljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0ZGVyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGNvbnNvbGUubG9nKFwiRGVyZWdpc3RlcmluZyBwaHlzaWNzIG9iamVjdFwiKTtcblx0XHRpZihub2RlLmlzU3RhdGljKXtcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzdGF0aWMgbGlzdFxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnN0YXRpY05vZGVzLmluZGV4T2Yobm9kZSk7XG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBkeW5hbWljIGxpc3Rcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5keW5hbWljTm9kZXMuaW5kZXhPZihub2RlKTtcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG5cdFx0dGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGRlcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudGlsZW1hcHMuaW5kZXhPZih0aWxlbWFwKTtcblx0XHR0aGlzLnRpbGVtYXBzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Zm9yKGxldCBub2RlIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcblx0XHRcdC8qLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIENsZWFyIGZyYW1lIGRlcGVuZGVudCBib29sZWFuIHZhbHVlcyBmb3IgZWFjaCBub2RlXG5cdFx0XHRub2RlLm9uR3JvdW5kID0gZmFsc2U7XG5cdFx0XHRub2RlLm9uQ2VpbGluZyA9IGZhbHNlO1xuXHRcdFx0bm9kZS5vbldhbGwgPSBmYWxzZTtcblx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgbm90IGFjdGl2ZSwgZG9uJ3QgcHJvY2VzcyBpdFxuXHRcdFx0aWYoIW5vZGUuYWN0aXZlKXtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgc3dlcHQgc2hhcGVzIG9mIGVhY2ggbm9kZVxuXHRcdFx0aWYobm9kZS5tb3Zpbmcpe1xuXHRcdFx0XHQvLyBJZiBtb3ZpbmcsIHJlZmxlY3QgdGhhdCBpbiB0aGUgc3dlcHQgc2hhcGVcblx0XHRcdFx0bm9kZS5zd2VwdFJlY3Quc3dlZXAobm9kZS5fdmVsb2NpdHksIG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElmIG91ciBub2RlIGlzbid0IG1vdmluZywgZG9uJ3QgYm90aGVyIHRvIGNoZWNrIGl0IChvdGhlciBub2RlcyB3aWxsIGRldGVjdCBpZiB0aGV5IHJ1biBpbnRvIGl0KVxuXHRcdFx0XHRub2RlLl92ZWxvY2l0eS56ZXJvKCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKi0tLS0tLS0tLS0gREVURUNUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gR2F0aGVyIGEgc2V0IG9mIG92ZXJsYXBzXG5cdFx0XHRsZXQgb3ZlcmxhcHMgPSBuZXcgQXJyYXk8QXJlYUNvbGxpc2lvbj4oKTtcblxuXHRcdFx0bGV0IGdyb3VwSW5kZXggPSBNYXRoLmxvZzIobm9kZS5ncm91cCk7XG5cblx0XHRcdC8vIEZpcnN0LCBjaGVjayB0aGlzIG5vZGUgYWdhaW5zdCBldmVyeSBzdGF0aWMgbm9kZSAob3JkZXIgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSwgc2luY2Ugd2Ugc29ydCBhbnl3YXlzKVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLnN0YXRpY05vZGVzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuLCBjaGVjayBpdCBhZ2FpbnN0IGV2ZXJ5IGR5bmFtaWMgbm9kZVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBvdXJzZWx2ZXNcblx0XHRcdFx0aWYobm9kZSA9PT0gb3RoZXIpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTGFzdGx5LCBnYXRoZXIgYSBzZXQgb2YgQUFCQnMgZnJvbSB0aGUgdGlsZW1hcC5cblx0XHRcdC8vIFRoaXMgc3RlcCBpbnZvbHZlcyB0aGUgbW9zdCBleHRyYSB3b3JrLCBzbyBpdCBpcyBhYnN0cmFjdGVkIGludG8gYSBtZXRob2Rcblx0XHRcdGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIHRpbGVtYXBzXG5cdFx0XHRcdGlmKCF0aWxlbWFwLmFjdGl2ZSkgY29udGludWU7XG5cblx0XHRcdFx0aWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcblx0XHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZSwgdGlsZW1hcCwgb3ZlcmxhcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgdGhlIG92ZXJsYXBzIGJ5IGFyZWFcblx0XHRcdG92ZXJsYXBzID0gb3ZlcmxhcHMuc29ydCgoYSwgYikgPT4gYi5hcmVhIC0gYS5hcmVhKTtcblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBoaXRzIHRvIHVzZSBsYXRlclxuXHRcdFx0bGV0IGhpdHMgPSBbXTtcblxuXHRcdFx0LyotLS0tLS0tLS0tIFJFU09MVVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBGb3IgZXZlcnkgb3ZlcmxhcCwgZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29sbGlkZSB3aXRoIGl0IGFuZCB3aGVuXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZigodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBEbyBhIHN3ZXB0IGxpbmUgdGVzdCBvbiB0aGUgc3RhdGljIEFBQkIgd2l0aCB0aGlzIEFBQkIgc2l6ZSBhcyBwYWRkaW5nICh0aGlzIGlzIGJhc2ljYWxseSB1c2luZyBhIG1pbmtvd3NraSBzdW0hKVxuXHRcdFx0XHQvLyBTdGFydCB0aGUgc3dlZXAgYXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIGEgZGVsdGEgb2YgX3ZlbG9jaXR5XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXI7XG5cdFx0XHRcdGNvbnN0IGRlbHRhID0gbm9kZS5fdmVsb2NpdHk7XG5cdFx0XHRcdGNvbnN0IHBhZGRpbmcgPSBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplO1xuXHRcdFx0XHRjb25zdCBvdGhlckFBQkIgPSBvdmVybGFwLmNvbGxpZGVyO1xuXG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gb3RoZXJBQUJCLmludGVyc2VjdFNlZ21lbnQobm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplKTtcblxuXHRcdFx0XHRvdmVybGFwLmhpdCA9IGhpdDtcblxuXHRcdFx0XHRpZihoaXQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGhpdHMucHVzaChoaXQpO1xuXG5cdFx0XHRcdFx0Ly8gV2UgZ290IGEgaGl0LCByZXNvbHZlIHdpdGggdGhlIHRpbWUgaW5zaWRlIG9mIHRoZSBoaXRcblx0XHRcdFx0XHRsZXQgdG5lYXJ4ID0gaGl0Lm5lYXJUaW1lcy54O1xuXHRcdFx0XHRcdGxldCB0bmVhcnkgPSBoaXQubmVhclRpbWVzLnk7XG5cblx0XHRcdFx0XHQvLyBBbGxvdyBlZGdlIGNsaXBwaW5nIChlZGdlIG92ZXJsYXBzIGRvbid0IGNvdW50LCBvbmx5IGFyZWEgb3ZlcmxhcHMpXG5cdFx0XHRcdFx0Ly8gSW1wb3J0YW50bHkgZG9uJ3QgYWxsb3cgYm90aCBjYXNlcyB0byBiZSB0cnVlLiBUaGVuIHdlIGNsaXAgdGhyb3VnaCBjb3JuZXJzLiBGYXZvciB4IHRvIGhlbHAgcGxheWVycyBsYW5kIGp1bXBzXG5cdFx0XHRcdFx0aWYodG5lYXJ4IDwgMS4wICYmIChwb2ludC55ID09PSBvdGhlckFBQkIudG9wIC0gcGFkZGluZy55IHx8IHBvaW50LnkgPT09IG90aGVyQUFCQi5ib3R0b20gKyBwYWRkaW5nLnkpICYmIGRlbHRhLnggIT09IDApIHtcblx0XHRcdFx0XHRcdHRuZWFyeCA9IDEuMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYodG5lYXJ5IDwgMS4wICYmIChwb2ludC54ID09PSBvdGhlckFBQkIubGVmdCAtIHBhZGRpbmcueCB8fCBwb2ludC54ID09PSBvdGhlckFBQkIucmlnaHQgKyBwYWRkaW5nLngpICYmIGRlbHRhLnkgIT09IDApIHtcblx0XHRcdFx0XHRcdHRuZWFyeSA9IDEuMDtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmKGhpdC5uZWFyVGltZXMueCA+PSAwICYmIGhpdC5uZWFyVGltZXMueCA8IDEpe1xuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0XHRcdG5vZGUuX3ZlbG9jaXR5LnggPSBub2RlLl92ZWxvY2l0eS54ICogdG5lYXJ4O1xuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnkgPj0gMCAmJiBoaXQubmVhclRpbWVzLnkgPCAxKXtcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS55ID0gbm9kZS5fdmVsb2NpdHkueSAqIHRuZWFyeTtcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qLS0tLS0tLS0tLSBJTkZPUk1BVElPTi9UUklHR0VSIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gQ2hlY2sgaWYgd2UgZW5kZWQgdXAgb24gdGhlIGdyb3VuZCwgY2VpbGluZyBvciB3YWxsXG5cdFx0XHQvLyBBbHNvIGNoZWNrIGZvciB0cmlnZ2Vyc1xuXHRcdFx0Zm9yKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKXtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGEgdHJpZ2dlci4gSWYgd2UgY2FyZSBhYm91dCB0aGUgdHJpZ2dlciwgcmVhY3Rcblx0XHRcdFx0aWYob3ZlcmxhcC5vdGhlci5pc1RyaWdnZXIgJiYgKG92ZXJsYXAub3RoZXIudHJpZ2dlck1hc2sgJiBub2RlLmdyb3VwKSl7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBiaXQgdGhhdCB0aGlzIGdyb3VwIGlzIHJlcHJlc2VudGVkIGJ5XG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCB0aGUgdHJpZ2dlckVudGVyIGV2ZW50IG5hbWVcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXG5cdFx0XHRcdFx0XHRvdGhlcjogKDxHYW1lTm9kZT5vdmVybGFwLm90aGVyKS5pZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGNvbGxpc2lvbiBzaWRlcyBmb3Igbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZigodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGZvciBkaXJlY3Rpb24gaWYgdGhlIG92ZXJsYXAgd2FzIGNvbGxpZGFibGVcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0bGV0IGNvbGxpc2lvblNpZGUgPSBvdmVybGFwLmNvbGxpZGVyLnRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMobm9kZS5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZSAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLmhpdCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhpdCBhIHRpbGVtYXAsIGtlZXAgdHJhY2sgb2YgaXRcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZS55ID09PSAtMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNvbGxpc2lvblNpZGUueSA9PT0gMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiBib3R0b20gb2Ygb3ZlcmxhcCwgc28gb25DZWlsaW5nXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgd2Fzbid0IHRvdWNoaW5nIG9uIHksIHNvIGl0IGlzIHRvdWNoaW5nIG9uIHhcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XG5cdFx0XHRub2RlLmZpbmlzaE1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxuXHQgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcblx0ICovXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XG5cdFx0Ly8gR2V0IHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3Zpbmcgbm9kZVxuXHRcdGxldCBtaW4gPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5sZWZ0LCBub2RlLnN3ZXB0UmVjdC50b3ApO1xuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcblxuXHRcdC8vIENvbnZlcnQgdGhlIG1pbi9tYXggeC95IHRvIHRoZSBtaW4gYW5kIG1heCByb3cvY29sIGluIHRoZSB0aWxlbWFwIGFycmF5XG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtaW4pO1xuXHRcdGxldCBtYXhJbmRleCA9IHRpbGVtYXAuZ2V0Q29sUm93QXQobWF4KTtcblxuXHRcdGxldCB0aWxlU2l6ZSA9IHRpbGVtYXAuZ2V0VGlsZVNpemUoKTtcblxuXHRcdC8vIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdGlsZXMgKHdoaWNoIGlzbid0IG1hbnkgaW4gdGhlIHNjb3BlIG9mIHRoZSB2ZWxvY2l0eSBwZXIgZnJhbWUpXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xuXHRcdFx0Zm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xuXHRcdFx0XHRpZih0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLngvMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkvMik7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCBjb2xsaWRlciA9IG5ldyBBQUJCKHRpbGVQb3MsIHRpbGVTaXplLnNjYWxlZCgxLzIpKTtcblxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBjb2xsaXNpb24gYXJlYSBiZXR3ZWVuIHRoZSBub2RlIGFuZCB0aGUgdGlsZVxuXHRcdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xuXHRcdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgdGlsZW1hcCwgXCJUaWxlbWFwXCIsIG5ldyBWZWMyKGNvbCwgcm93KSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IHBoeXNpY3MgbWFuYWdlci5cbiAqIFRoaXMgY2xhc3MgZXhwb3NlcyBmdW5jdGlvbnMgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IHRoYXQgc2hvdWxkIGFsbG93IGZvciBhIHdvcmtpbmcgcGh5c2ljcyBzeXN0ZW0gdG8gYmUgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGh5c2ljc01hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblx0LyoqIFRoZSBldmVudCByZWNlaXZlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdC8qKiBUaGUgZXZlbnQgZW1pdHRlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXG5cdHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuXG5cdC8qKiBNYXBzIGxheWVyIG5hbWVzIHRvIG51bWJlcnMgKi9cblx0cHJvdGVjdGVkIGdyb3VwTWFwOiBNYXA8bnVtYmVyPjtcblxuXHQvKiogTWFwcyBsYXllciBudW1iZXJzIHRvIG5hbWVzICovXG5cdHByb3RlY3RlZCBncm91cE5hbWVzOiBBcnJheTxzdHJpbmc+O1xuXG5cdC8qKiBUaGUgZGVmYXVsdCBncm91cCBuYW1lICovXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9HUk9VUCA9IFwiRGVmYXVsdFwiO1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cblx0XHQvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3Ncblx0XHR0aGlzLmdyb3VwTWFwID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuZ3JvdXBOYW1lcyA9IG5ldyBBcnJheSgpO1xuXHR9XG5cblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBnYW1lbm9kZSB3aXRoIHRoaXMgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblxuXHQvKipcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaHlzaWNzIGxheWVyIG9mIHRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCB0aGF0IHRoZSBHYW1lTm9kZSBzaG91bGQgYmUgb25cblx0ICovXG5cdHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XG5cdFx0bm9kZS5ncm91cCA9IHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGxheWVyIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcblx0ICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuXHQgKiBAcmV0dXJucyBUaGUgbGF5ZXIgbnVtYmVyLCBvciAwIGlmIHRoZXJlIGlzIG5vdCBhIGxheWVyIHdpdGggdGhhdCBuYW1lIHJlZ2lzdGVyZWRcblx0ICovXG5cdGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xuXHRcdGlmKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xuXHRcdH0gZWxzZXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxuXHQgKiBAcGFyYW0gZ3JvdXBzIEEgbWFzayBvZiBncm91cHNcblx0ICogQHJldHVybnMgQWxsIGdyb3VwcyBjb250YWluZWQgaW4gdGhlIG1hc2tcblx0ICovXG5cdGdldEdyb3VwTmFtZXMoZ3JvdXBzOiBudW1iZXIpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRpZihncm91cHMgPT09IC0xKXtcblx0XHRcdHJldHVybiBbUGh5c2ljc01hbmFnZXIuREVGQVVMVF9HUk9VUF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBnID0gMTtcblx0XHRcdGxldCBuYW1lcyA9IFtdO1xuXG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgMzI7IGkrKyl7XG5cdFx0XHRcdGlmKGcgJiBncm91cHMpe1xuXHRcdFx0XHRcdC8vIFRoaXMgZ3JvdXAgaXMgaW4gdGhlIGdyb3VwcyBudW1iZXJcblx0XHRcdFx0XHRuYW1lcy5wdXNoKHRoaXMuZ3JvdXBOYW1lc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTaGlmdCB0aGUgYml0IG92ZXJcblx0XHRcdFx0ZyA9IGcgPDwgMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvcmRlciB7XG5cdHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHRwcml2YXRlIGxvZzogUXVldWU8TG9nSXRlbT47XG5cdHByaXZhdGUgcmVjb3JkaW5nOiBib29sZWFuO1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cdHByaXZhdGUgZnJhbWU6IG51bWJlcjtcblx0cHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuO1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdHRoaXMubG9nID0gbmV3IFF1ZXVlKDEwMDApO1xuXHRcdHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5mcmFtZSA9IDA7XG5cblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdFx0dGhpcy5ldmVudFF1ZXVlLnN1YnNjcmliZSh0aGlzLnJlY2VpdmVyLCBcImFsbFwiKTtcblx0fVxuXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdGlmKHRoaXMucmVjb3JkaW5nKXtcblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcblx0XHR9XG5cblx0XHRpZih0aGlzLnBsYXlpbmcpe1xuXHRcdFx0Ly8gSWYgcGxheWluZywgaWdub3JlIGV2ZW50cywganVzdCBmZWVkIHRoZSByZWNvcmQgdG8gdGhlIGV2ZW50IHF1ZXVlXG5cdFx0XHR0aGlzLnJlY2VpdmVyLmlnbm9yZUV2ZW50cygpO1xuXG5cdFx0XHQvKlxuXHRcdFx0XHRXaGlsZSB0aGVyZSBpcyBhIG5leHQgaXRlbSwgYW5kIHdoaWxlIGl0IHNob3VsZCBvY2N1ciBpbiB0aGlzIGZyYW1lLFxuXHRcdFx0XHRzZW5kIHRoZSBldmVudC4gaS5lLiwgd2hpbGUgY3VycmVudF9mcmFtZSAqIGN1cnJlbnRfZGVsdGFfdCBpcyBncmVhdGVyXG5cdFx0XHRcdHRoYW4gcmVjb3JkZWRfZnJhbWUgKiByZWNvcmRlZF9kZWx0YV90XG5cdFx0XHQqL1xuXHRcdFx0d2hpbGUodGhpcy5sb2cuaGFzSXRlbXMoKVxuXHRcdFx0XHRcdCYmIHRoaXMubG9nLnBlZWtOZXh0KCkuZnJhbWUgKiB0aGlzLmxvZy5wZWVrTmV4dCgpLmRlbHRhIDwgdGhpcy5mcmFtZSAqIGRlbHRhVCl7XG5cdFx0XHRcdGxldCBldmVudCA9IHRoaXMubG9nLmRlcXVldWUoKS5ldmVudDtcblx0XHRcdFx0Y29uc29sZS5sb2coZXZlbnQpO1xuXHRcdFx0XHR0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighdGhpcy5sb2cuaGFzSXRlbXMoKSl7XG5cdFx0XHRcdHRoaXMucGxheWluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZyYW1lICs9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIG5vdCBwbGF5aW5nLCBoYW5kbGUgZXZlbnRzXG5cdFx0XHR3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcblxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUT1BfUkVDT1JESU5HKXtcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xuXHRcdFx0XHRcdHRoaXMubG9nLmVucXVldWUobmV3IExvZ0l0ZW0odGhpcy5mcmFtZSwgZGVsdGFULCBldmVudCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVEFSVF9SRUNPUkRJTkcpe1xuXHRcdFx0XHRcdHRoaXMubG9nLmNsZWFyKCk7XG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfUkVDT1JESU5HKXtcblx0XHRcdFx0XHR0aGlzLmZyYW1lID0gMDtcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucGxheWluZyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuY2xhc3MgTG9nSXRlbSB7XG5cdGZyYW1lOiBudW1iZXI7XG5cdGRlbHRhOiBudW1iZXI7XG5cdGV2ZW50OiBHYW1lRXZlbnQ7XG5cblx0Y29uc3RydWN0b3IoZnJhbWU6IG51bWJlciwgZGVsdGFUOiBudW1iZXIsIGV2ZW50OiBHYW1lRXZlbnQpe1xuXHRcdHRoaXMuZnJhbWUgPSBmcmFtZTtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGFUO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVnaXN0cnk8VD4gZXh0ZW5kcyBNYXA8VD57XG5cbiAgICAvKiogUHJlbG9hZHMgcmVnaXN0cnkgZGF0YSAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBwcmVsb2FkKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVnaXN0ZXIgdGhpcyBpdGVtIHdpdGhcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYWRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XG5pbXBvcnQgTGFiZWxTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUG9pbnRTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUmVjdFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZVwiO1xuaW1wb3J0IFNwcml0ZVNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9TcHJpdGVTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cnlcIjtcblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IHRoYXQgaGFuZGxlcyBzaGFkZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8U2hhZGVyVHlwZT4ge1xuXG5cdC8vIFNoYWRlciBuYW1lc1xuXHRwdWJsaWMgc3RhdGljIFBPSU5UX1NIQURFUiA9IFwicG9pbnRcIjtcblx0cHVibGljIHN0YXRpYyBSRUNUX1NIQURFUiA9IFwicmVjdFwiO1xuXHRwdWJsaWMgc3RhdGljIFNQUklURV9TSEFERVIgPSBcInNwcml0ZVwiO1xuXHRwdWJsaWMgc3RhdGljIExBQkVMX1NIQURFUiA9IFwibGFiZWxcIjtcblxuXHRwcml2YXRlIHJlZ2lzdHJ5SXRlbXM6IEFycmF5PFNoYWRlclJlZ2lzdHJ5SXRlbT4gPSBuZXcgQXJyYXkoKTtcblxuXHQvKipcblx0ICogUHJlbG9hZHMgYWxsIGJ1aWx0LWluIHNoYWRlcnNcblx0ICovXG5cdHB1YmxpYyBwcmVsb2FkKCl7XG5cdFx0Ly8gR2V0IHRoZSByZXNvdXJjZU1hbmFnZXIgYW5kIHF1ZXVlIGFsbCBidWlsdC1pbiBzaGFkZXJzIGZvciBwcmVsb2FkaW5nXG5cdFx0Y29uc3Qgcm0gPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHBvaW50IHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIsIFBvaW50U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC5mc2hhZGVyXCIpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcmVjdCBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIsIFJlY3RTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC5mc2hhZGVyXCIpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgc3ByaXRlIHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSLCBTcHJpdGVTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUuZnNoYWRlclwiKTtcblx0XG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgbGFiZWwgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUiwgTGFiZWxTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIGFueSBwcmVsb2FkZWQgaXRlbXNcblx0XHRmb3IobGV0IGl0ZW0gb2YgdGhpcy5yZWdpc3RyeUl0ZW1zKXtcblx0XHRcdGNvbnN0IHNoYWRlciA9IG5ldyBpdGVtLmNvbnN0cihpdGVtLmtleSk7XG5cdFx0XHRzaGFkZXIuaW5pdEJ1ZmZlck9iamVjdCgpO1xuXHRcdFx0dGhpcy5hZGQoaXRlbS5rZXksIHNoYWRlcik7XG5cblx0XHRcdC8vIExvYWQgaWYgZGVzaXJlZFxuXHRcdFx0aWYoaXRlbS5wcmVsb2FkICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRybS5zaGFkZXIoaXRlbS5rZXksIGl0ZW0ucHJlbG9hZC52c2hhZGVyTG9jYXRpb24sIGl0ZW0ucHJlbG9hZC5mc2hhZGVyTG9jYXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5IGFuZCBsb2FkcyBpdCBiZWZvcmUgdGhlIGdhbWUgYmVnaW5zXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxuXHQgKiBAcGFyYW0gdnNoYWRlckxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvZiB0aGUgdmVydGV4IHNoYWRlclxuXHQgKiBAcGFyYW0gZnNoYWRlckxvY2F0aW9uIHRoZSBsb2NhdGlvbiBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyXG5cdCAqL1xuXHRwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSwgdnNoYWRlckxvY2F0aW9uOiBzdHJpbmcsIGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlclByZWxvYWQgPSBuZXcgU2hhZGVyUHJlbG9hZCgpO1xuXHRcdHNoYWRlclByZWxvYWQudnNoYWRlckxvY2F0aW9uID0gdnNoYWRlckxvY2F0aW9uO1xuXHRcdHNoYWRlclByZWxvYWQuZnNoYWRlckxvY2F0aW9uID0gZnNoYWRlckxvY2F0aW9uO1xuXG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XG5cdFx0cmVnaXN0cnlJdGVtLnByZWxvYWQgPSBzaGFkZXJQcmVsb2FkO1xuXG5cdFx0dGhpcy5yZWdpc3RyeUl0ZW1zLnB1c2gocmVnaXN0cnlJdGVtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5LiBOT1RFOiBJZiB5b3UgdXNlIHRoaXMsIHlvdSBNVVNUIGxvYWQgdGhlIHNoYWRlciBiZWZvcmUgdXNlLlxuXHQgKiBJZiB5b3Ugd2lzaCB0byBwcmVsb2FkIHRoZSBzaGFkZXIsIHVzZSByZWdpc3RlckFuZFByZWxvYWRJdGVtKClcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXG5cdCAqL1xuXHRwdWJsaWMgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlKTogdm9pZCB7XG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XG5cblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xuXHR9XG59XG5cbmNsYXNzIFNoYWRlclJlZ2lzdHJ5SXRlbSB7XG5cdGtleTogc3RyaW5nO1xuXHRjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlO1xuXHRwcmVsb2FkOiBTaGFkZXJQcmVsb2FkO1xufVxuXG5jbGFzcyBTaGFkZXJQcmVsb2FkIHtcblx0dnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XG5cdGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xuXG4vKipcbiAqIFRoZSBSZWdpc3RyeSBpcyB0aGUgc3lzdGVtJ3Mgd2F5IG9mIGNvbnZlcnRpbmcgY2xhc3NlcyBhbmQgdHlwZXMgaW50byBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9ucyBmb3IgdXNlIGVsc2V3aGVyZSBpbiB0aGUgYXBwbGljYXRpb24uXG4gKiBJdCBhbGxvd3MgY2xhc3NlcyB0byBiZSBhY2Nlc3NlZCB3aXRob3V0IGV4cGxpY2l0bHkgdXNpbmcgY29uc3RydWN0b3JzIGluIGNvZGUsXG4gKiBhbmQgZm9yIHJlc291cmNlcyB0byBiZSBsb2FkZWQgYXQgR2FtZSBjcmVhdGlvbiB0aW1lLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpc3RyeU1hbmFnZXIge1xuXG5cdHB1YmxpYyBzdGF0aWMgc2hhZGVycyA9IG5ldyBTaGFkZXJSZWdpc3RyeSgpO1xuXG5cdC8qKiBBZGRpdGlvbmFsIGN1c3RvbSByZWdpc3RyaWVzIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgbWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdHJpZXM6IE1hcDxSZWdpc3RyeTxhbnk+PiA9IG5ldyBNYXAoKTtcblxuXHRzdGF0aWMgcHJlbG9hZCgpe1xuXHRcdHRoaXMuc2hhZGVycy5wcmVsb2FkKCk7XG5cblx0XHR0aGlzLnJlZ2lzdHJpZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KS5wcmVsb2FkKCkpO1xuXHR9XG5cblx0c3RhdGljIGFkZEN1c3RvbVJlZ2lzdHJ5KG5hbWU6IHN0cmluZywgcmVnaXN0cnk6IFJlZ2lzdHJ5PGFueT4pe1xuXHRcdHRoaXMucmVnaXN0cmllcy5hZGQobmFtZSwgcmVnaXN0cnkpO1xuXHR9XG5cblx0c3RhdGljIGdldFJlZ2lzdHJ5KGtleTogc3RyaW5nKXtcblx0XHRyZXR1cm4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpO1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IHsgQW5pbWF0aW9uRGF0YSwgQW5pbWF0aW9uU3RhdGUgfSBmcm9tIFwiLi9BbmltYXRpb25UeXBlc1wiO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBtYW5hZ2VyIGNsYXNzIGZvciBhbiBhbmltYXRlZCBDYW52YXNOb2RlLlxuICogVGhpcyBjbGFzcyBrZWVwcyB0cmFjayBvZiB0aGUgcG9zc2libGUgYW5pbWF0aW9ucywgYXMgd2VsbCBhcyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUsXG4gKiBhbmQgYWJzdHJhY3RzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBwbGF5aW5nLCBwYXVzaW5nLCBhbmQgc3RvcHBpbmcgYW5pbWF0aW9ucyBhcyB3ZWxsIGFzIFxuICogY3JlYXRpbmcgbmV3IGFuaW1hdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XG4gICAgLyoqIFRoZSBvd25lciBvZiB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXG4gICAgcHJvdGVjdGVkIG93bmVyOiBDYW52YXNOb2RlO1xuICAgIFxuICAgIC8qKiBUaGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgb2YgdGhpcyBzcHJpdGUgKi9cbiAgICBwcm90ZWN0ZWQgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvZiB0aGlzIHNwcml0ZSAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50QW5pbWF0aW9uOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhpcyBhbmltYXRpb24gKi9cbiAgICBwcm90ZWN0ZWQgY3VycmVudEZyYW1lOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0aHJvdWdoIHRoZSBjdXJyZW50IGZyYW1lICovXG4gICAgcHJvdGVjdGVkIGZyYW1lUHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBsb29waW5nIG9yIG5vdCAqL1xuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBtYXAgb2YgYW5pbWF0aW9ucyAqL1xuICAgIHByb3RlY3RlZCBhbmltYXRpb25zOiBNYXA8QW5pbWF0aW9uRGF0YT47XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChpZiBhbnkpIHRvIHNlbmQgd2hlbiB0aGUgY3VycmVudCBhbmltYXRpb24gc3RvcHMgcGxheWluZy4gKi9cbiAgICBwcm90ZWN0ZWQgb25FbmRFdmVudDogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKiogQSBxdWV1ZWQgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdBbmltYXRpb246IHN0cmluZztcblxuICAgIC8qKiBUaGUgbG9vcCBzdGF0dXMgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBwZW5kaW5nTG9vcDogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgb25FbmQgZXZlbnQgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBwZW5kaW5nT25FbmQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQW5pbWF0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIEFuaW1hdGlvbk1hbmFnZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihvd25lcjogQ2FudmFzTm9kZSl7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYW5pbWF0aW9uIHRvIHRoaXMgc3ByaXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIGRhdGFcbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIGFuaW1hdGlvbjogQW5pbWF0aW9uRGF0YSk6IHZvaWQge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMuYWRkKGtleSwgYW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBzcGVjaWZpZWQgYnkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBjdXJyZW50IGZyYW1lXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IGluIHRoZSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAqL1xuICAgIGdldEluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBjdXJyZW50IGFuaW1hdGlvbiwgd2FybiB0aGUgdXNlclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbmltYXRpb24gaW5kZXggd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbjogJHt0aGlzLmN1cnJlbnRBbmltYXRpb259IHdhcyBpbnZhbGlkYCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcGxheWluZ1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBwbGF5aW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1BsYXlpbmcoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9PT0ga2V5ICYmIHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZXMgdGhlIGFuaW1hdGlvbiBmcmFtZVxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBwbGF5aW5nLCB3ZSB3b24ndCBiZSBhZHZhbmNpbmcgdGhlIGFuaW1hdGlvblxuICAgICAgICBpZighKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpe1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbik7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XG5cbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzICs9IDE7XG4gICAgICAgICAgICBpZih0aGlzLmZyYW1lUHJvZ3Jlc3MgPj0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gb24gdGhpcyBmcmFtZSBmb3IgaXRzIHdob2xlIGR1cmF0aW9uLCBnbyB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRGcmFtZSA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGlzIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ3VycmVudEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCBjYW4ndCBhZHZhbmNlLiBXYXJuIHRoZSB1c2VyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZSB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICgke3RoaXMuY3VycmVudEFuaW1hdGlvbn0pIGluIG5vZGUgd2l0aCBpZDogJHt0aGlzLm93bmVyLmlkfSB3YXMgaW52YWxpZGApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRW5kcyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGZpcmVzIGFueSBuZWNlc3NhcnkgZXZlbnRzLCBhcyB3ZWxsIGFzIHN0YXJ0aW5nIGFueSBuZXcgYW5pbWF0aW9ucyAqL1xuICAgIHByb3RlY3RlZCBlbmRDdXJyZW50QW5pbWF0aW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgIGlmKHRoaXMub25FbmRFdmVudCAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbmRFdmVudCwge293bmVyOiB0aGlzLm93bmVyLmlkLCBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxuICAgICAgICBpZih0aGlzLnBlbmRpbmdBbmltYXRpb24gIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5wbGF5KHRoaXMucGVuZGluZ0FuaW1hdGlvbiwgdGhpcy5wZW5kaW5nTG9vcCwgdGhpcy5wZW5kaW5nT25FbmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb24uIERvZXMgbm90IHJlc3RhcnQgaXQgaWYgaXQgaXMgYWxyZWFkeSBwbGF5aW5nXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxuICAgICAqL1xuICAgIHBsYXlJZk5vdEFscmVhZHkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmN1cnJlbnRBbmltYXRpb24gIT09IGFuaW1hdGlvbil7XG4gICAgICAgICAgICB0aGlzLnBsYXkoYW5pbWF0aW9uLCBsb29wLCBvbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgYW5pbWF0aW9uLiBGYWxzZSBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBuYW1lIG9mIGFuIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIGFuaW1hdGlvbiBuYXR1cmFsbHkgc3RvcHMgcGxheWluZy4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgbG9vcCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBwbGF5KGFuaW1hdGlvbjogc3RyaW5nLCBsb29wPzogYm9vbGVhbiwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuXG4gICAgICAgIC8vIElmIGxvb3AgYXJnIHdhcyBwcm92aWRlZCwgdXNlIHRoYXRcbiAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB3aGF0IHRoZSBqc29uIGZpbGUgc3BlY2lmaWVkXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KGFuaW1hdGlvbikucmVwZWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBvbkVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBwZW5kaW5nIGFuaW1hdGlvblxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIHNpbmdsZSBhbmltYXRpb24gdG8gYmUgcGxheWVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZS4gRG9lcyBOT1Qgc3RhY2suXG4gICAgICogUXVldWVpbmcgYWRkaXRpb25hbCBhbmltYXRpb25zIHBhc3QgMSB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgcXVldWVkIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBldmVudCB0byBmaXJlIHdoZW4gdGhlIHF1ZXVlZCBhbmltYXRpb24gZW5kc1xuICAgICAqL1xuICAgIHF1ZXVlKGFuaW1hdGlvbjogc3RyaW5nLCBsb29wOiBib29sZWFuID0gZmFsc2UsIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9vcCA9IGxvb3A7XG4gICAgICAgIGlmKG9uRW5kICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBvbkVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQYXVzZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICovXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgfVxuXG4gICAgLyoqIFJlc3VtZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlmIHBvc3NpYmxlICovXG4gICAgcmVzdW1lKCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpe1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU3RvcHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIGNhbm5vdCBiZSByZXN1bWVkIGFmdGVyIHRoaXMuICovXG4gICAgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG4gICAgfVxufSIsImltcG9ydCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZW51bSBBbmltYXRpb25TdGF0ZSB7XG4gICAgU1RPUFBFRCA9IDAsXG4gICAgUEFVU0VEID0gMSxcbiAgICBQTEFZSU5HID0gMixcbn1cblxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkRhdGEge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBmcmFtZXM6IEFycmF5PHtpbmRleDogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyfT47XG4gICAgcmVwZWF0OiBib29sZWFuID0gZmFsc2U7XG59XG5cbmV4cG9ydCBjbGFzcyBUd2VlbkVmZmVjdCB7XG4gICAgLyoqIFRoZSBwcm9wZXJ0eSB0byB0d2VlbiAqL1xuICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBUd2VlbiBzaG91bGQgcmVzZXQgdGhlIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhZnRlciBwbGF5aW5nICovXG4gICAgcmVzZXRPbkNvbXBsZXRlOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXG4gICAgc3RhcnQ6IGFueTtcblxuICAgIC8qKiBUaGUgZW5kaW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cbiAgICBlbmQ6IGFueTtcblxuICAgIC8qKiBUaGUgZWFzZSBmdW5jdGlvbiB0byB1c2UgKi9cbiAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlO1xuXG4gICAgLyoqIERPIE5PVCBNT0RJRlkgLSBUaGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IC0gc2V0IGF1dG9tYXRpY2FsbHkgKi9cbiAgICBpbml0aWFsVmFsdWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFR3ZWVuRGF0YSB7XG4gICAgLy8gTWVtYmVycyBmb3IgaW5pdGlhbGl6YXRpb24gYnkgdGhlIHVzZXJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgdHdlZW4gKi9cbiAgICBzdGFydERlbGF5OiBudW1iZXI7XG4gICAgLyoqIFRoZSBkdXJhdGlvbiBvZiB0aW1lIG92ZXIgd2hpY2ggdGhlIHZhbHVlIHdpdGggY2hhbmdlIGZyb20gc3RhcnQgdG8gZW5kICovXG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIGVmZmVjdHMgb24gdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCAqL1xuICAgIGVmZmVjdHM6IEFycmF5PFR3ZWVuRWZmZWN0PjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgcmV2ZXJzZSBmcm9tIGVuZCB0byBzdGFydCBmb3IgZWFjaCBwcm9wZXJ0eSB3aGVuIGl0IGZpbmlzaGVzICovXG4gICAgcmV2ZXJzZU9uQ29tcGxldGU6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gc2hvdWxkIGxvb3Agd2hlbiBpdCBjb21wbGV0ZXMgKi9cbiAgICBsb29wOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCAoaWYgYW55KSB3aGVuIHRoZSB0d2VlbiBmaW5pc2hlcyBwbGF5aW5nICovXG4gICAgb25FbmQ6IHN0cmluZ1xuICAgIFxuICAgIC8vIE1lbWJlcnMgZm9yIG1hbmFnZW1lbnQgYnkgdGhlIHR3ZWVuIG1hbmFnZXJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoaXMgdHdlZW4gdGhyb3VnaCBpdHMgZWZmZWN0cyAqL1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGlzIHR3ZWVuICovXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gaXMgY3VycmVudGx5IHJldmVyc2luZyAqL1xuICAgIHJldmVyc2luZzogYm9vbGVhbjtcblxuICAgIC8vIEFkZGVkIGJ5IEFsZXggRi4gQWxsb3dzIHlvdSB0byBjYWxsIGEgY2FsbGJhY2sgb24gZW5kIG9mIHR3ZWVuIGR1cmF0aW9uXG4gICAgb25FbmRDYWxsYmFjazogKCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcblxuLyoqXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cbiAqIFR3ZWVucyBhcmUgc2hvcnQgYW5pbWF0aW9ucyBwbGF5ZWQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHR3byBwcm9wZXJ0aWVzIHVzaW5nIGFuIGVhc2luZyBmdW5jdGlvbi5cbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxuICogVGhpcyBhbGxvd3MgZm9yIHNvbWUgaW50ZXJlc3RpbmcgcG9saXNoZXMgb3IgYW5pbWF0aW9ucyB0aGF0IG1heSBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBkbyB3aXRoIHNwcml0ZSB3b3JrIGFsb25lXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5Db250cm9sbGVyIHtcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG4gICAgLyoqIFRoZSBsaXN0IG9mIGNyZWF0ZWQgdHdlZW5zICovXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdlZW5Db250cm9sbGVyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEdhbWVOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICAvLyBHaXZlIG91cnNlbHZlcyB0byB0aGUgVHdlZW5NYW5hZ2VyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgZGVzdHJveSgpe1xuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xuICAgICAgICBkZWxldGUgdGhpcy5vd25lci50d2VlbnM7XG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlblxuICAgICAqIEBwYXJhbSB0d2VlbiBUaGUgZGF0YSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIHR3ZWVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgVHdlZW5EYXRhKTogdm9pZCB7XG4gICAgICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcblxuICAgICAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXG4gICAgICAgIHR5cGVkVHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHR3ZWVuIHdpdGggYSBjZXJ0YWluIG5hbWVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXG4gICAgICovXG4gICAgcGxheShrZXk6IHN0cmluZywgbG9vcD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5pbml0aWFsVmFsdWUgPSB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBwbGF5aW5nIHR3ZWVuLiBEb2VzIG5vdCBhZmZlY3QgdHdlZW5zIHRoYXQgYXJlIHN0b3BwZWQuXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXG4gICAgICovXG4gICAgcGF1c2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgdGhpcy50d2VlbnMuZ2V0KGtleSkuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHJlc3VtZVxuICAgICAqL1xuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXG4gICAgICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3Aoa2V5KTtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxuICAgICAgICAgICAgaWYodHdlZW4ub25FbmQpe1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIHtrZXk6IGtleSwgbm9kZTogdGhpcy5vd25lci5pZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR3ZWVuLm9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0d2Vlbi5vbkVuZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbGwgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5zXG4gICAgICovXG4gICAgc3RvcEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4gdGhpcy5zdG9wKGtleSkpO1xuICAgIH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORyl7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSArPSBkZWx0YVQqMTAwMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHBhc3QgdGhlIHN0YXJ0RGVsYXksIGRvIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkpe1xuICAgICAgICAgICAgICAgICAgICBpZighdHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyB0d2Vlbi5kdXJhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUsIHN0b3AgdGhlIHR3ZWVuLCBsb29wLCBvciByZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNlT25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lIGFuZCBjYW4gcmV2ZXJzZSwgZG8gc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHR3ZWVuLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJldmVyc2UgYW5kIGNhbiBsb29wLCBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgbG9vcGluZyBhbmQgY2FuJ3QgcmV2ZXJzZSwgc28gc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGVuZCBvZiByZXZlcnNpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyAyKnR3ZWVuLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IDIqdHdlZW4uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzLCBtYWtlIHN1cmUgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLiBFcnJvcnMgZnJvbSB0aGlzIHNob3VsZCBuZXZlciBiZSBsYXJnZVxuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgoMip0d2Vlbi5kdXJhdGlvbiAtICh0d2Vlbi5lbGFwc2VkVGltZS0gdHdlZW4uc3RhcnREZWxheSkpL3R3ZWVuLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gTWF0aFV0aWxzLmNsYW1wMDEoKHR3ZWVuLmVsYXBzZWRUaW1lIC0gdHdlZW4uc3RhcnREZWxheSkvdHdlZW4uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgZWFzZSBmdW5jdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIG91ciBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVhc2UgPSBFYXNlRnVuY3Rpb25zW2VmZmVjdC5lYXNlXSh0d2Vlbi5wcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdmFsdWUgdG8gbGVycCB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IE1hdGhVdGlscy5sZXJwKGVmZmVjdC5zdGFydCwgZWZmZWN0LmVuZCwgZWFzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuL1R3ZWVuQ29udHJvbGxlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2Vlbk1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBUd2Vlbk1hbmFnZXIgPSBudWxsO1xuICAgIFxuICAgIHByb3RlY3RlZCB0d2VlbkNvbnRyb2xsZXJzOiBBcnJheTxUd2VlbkNvbnRyb2xsZXI+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVHdlZW5NYW5hZ2VyIHtcbiAgICAgICAgaWYoVHdlZW5NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKXtcbiAgICAgICAgICAgIFR3ZWVuTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBUd2Vlbk1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBUd2Vlbk1hbmFnZXIuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKXtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgZGVyZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xlYXJUd2VlbkNvbnRyb2xsZXJzKCl7XG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBmb3IobGV0IHR3ZWVuQ29udHJvbGxlciBvZiB0aGlzLnR3ZWVuQ29udHJvbGxlcnMpe1xuICAgICAgICAgICAgdHdlZW5Db250cm9sbGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBHcmFwaGljUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlclwiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiXG5pbXBvcnQgVGlsZW1hcFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXJcIjtcbmltcG9ydCBVSUVsZW1lbnRSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXJcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFJlbmRlcmluZ01hbmFnZXIgY2xhc3MgdXNpbmcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICBwcm90ZWN0ZWQgZ3JhcGhpY1JlbmRlcmVyOiBHcmFwaGljUmVuZGVyZXI7XG4gICAgcHJvdGVjdGVkIHRpbGVtYXBSZW5kZXJlcjogVGlsZW1hcFJlbmRlcmVyO1xuICAgIHByb3RlY3RlZCB1aUVsZW1lbnRSZW5kZXJlcjogVUlFbGVtZW50UmVuZGVyZXI7XG5cbiAgICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xuICAgIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XG5cbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xuICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIgPSBuZXcgR3JhcGhpY1JlbmRlcmVyKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIgPSBuZXcgVGlsZW1hcFJlbmRlcmVyKHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlciA9IG5ldyBVSUVsZW1lbnRSZW5kZXJlcih0aGlzLmN0eClcblxuICAgICAgICAvLyBGb3IgY3Jpc3AgcGl4ZWwgYXJ0XG4gICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmN0eDtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICByZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XG4gICAgICAgIC8vIFNvcnQgYnkgZGVwdGgsIHRoZW4gYnkgdmlzaWJsZSBzZXQgYnkgeS12YWx1ZVxuICAgICAgICB2aXNpYmxlU2V0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmKGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpID09PSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmJvdW5kYXJ5LmJvdHRvbSkgLSAoYi5ib3VuZGFyeS5ib3R0b20pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRMYXllcigpLmdldERlcHRoKCkgLSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHRpbGVtYXBJbmRleCA9IDA7XG4gICAgICAgIGxldCB0aWxlbWFwTGVuZ3RoID0gdGlsZW1hcHMubGVuZ3RoO1xuXG4gICAgICAgIGxldCB2aXNpYmxlU2V0SW5kZXggPSAwO1xuICAgICAgICBsZXQgdmlzaWJsZVNldExlbmd0aCA9IHZpc2libGVTZXQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlKHRpbGVtYXBJbmRleCA8IHRpbGVtYXBMZW5ndGggfHwgdmlzaWJsZVNldEluZGV4IDwgdmlzaWJsZVNldExlbmd0aCl7XG4gICAgICAgICAgICAvLyBDaGVjayBjb25kaXRpb25zIHdoZXJlIHdlJ3ZlIGFscmVhZHkgcmVhY2hlZCB0aGUgZWRnZSBvZiBvbmUgbGlzdFxuICAgICAgICAgICAgaWYodGlsZW1hcEluZGV4ID49IHRpbGVtYXBMZW5ndGgpe1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRoZSByZW1haW5pbmcgdmlzaWJsZSBzZXRcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZpc2libGVTZXRJbmRleCA+PSB2aXNpYmxlU2V0TGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aWxlbWFwc1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW5kZXIgd2hpY2hldmVyIGlzIGZ1cnRoZXIgZG93blxuICAgICAgICAgICAgaWYodGlsZW1hcHNbdGlsZW1hcEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkgPD0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlbWFwKHRpbGVtYXBzW3RpbGVtYXBJbmRleCsrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYobm9kZS52aXNpYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgdWlMYXllcnMgb24gdG9wIG9mIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsZXQgc29ydGVkVUlMYXllcnMgPSBuZXcgQXJyYXk8VUlMYXllcj4oKTtcblxuICAgICAgICB1aUxheWVycy5mb3JFYWNoKGtleSA9PiBzb3J0ZWRVSUxheWVycy5wdXNoKHVpTGF5ZXJzLmdldChrZXkpKSk7XG5cbiAgICAgICAgc29ydGVkVUlMYXllcnMgPSBzb3J0ZWRVSUxheWVycy5zb3J0KCh1aTEsIHVpMikgPT4gdWkxLmdldERlcHRoKCkgLSB1aTIuZ2V0RGVwdGgoKSk7XG5cbiAgICAgICAgc29ydGVkVUlMYXllcnMuZm9yRWFjaCh1aUxheWVyID0+IHtcblx0XHRcdGlmKCF1aUxheWVyLmlzSGlkZGVuKCkpXG5cdFx0XHRcdHVpTGF5ZXIuZ2V0SXRlbXMoKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZigoPENhbnZhc05vZGU+bm9kZSkudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG5cdFx0fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHNwZWNpZmllZCBDYW52YXNOb2RlXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0aGUgY2FudmFzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbmQgcm90YXRlXG4gICAgICAgIGxldCB4U2NhbGUgPSAxO1xuICAgICAgICBsZXQgeVNjYWxlID0gMTtcbiAgICAgICAgXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuICAgICAgICAgICAgeFNjYWxlID0gbm9kZS5pbnZlcnRYID8gLTEgOiAxO1xuICAgICAgICAgICAgeVNjYWxlID0gbm9kZS5pbnZlcnRZID8gLTEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHhTY2FsZSwgMCwgMCwgeVNjYWxlLCAobm9kZS5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAobm9kZS5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jdHgucm90YXRlKC1ub2RlLnJvdGF0aW9uKTtcbiAgICAgICAgbGV0IGdsb2JhbEFscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBSZWN0KXtcbiAgICAgICAgICAgIERlYnVnLmxvZyhcIm5vZGVcIiArIG5vZGUuaWQsIFwiTm9kZVwiICsgbm9kZS5pZCArIFwiIEFscGhhOiBcIiArIG5vZGUuYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbm9kZS5hbHBoYTtcbiAgICAgICAgXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKDxBbmltYXRlZFNwcml0ZT5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTcHJpdGUoPFNwcml0ZT5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JhcGhpYyg8R3JhcGhpYz5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJVSUVsZW1lbnQoPFVJRWxlbWVudD5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcblxuICAgICAgICBsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xuXG4gICAgICAgIGxldCBhbmltYXRpb25PZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGQgKGdpdmVuIHdlIG1vdmVkKVxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4gLXcvMiwgLWgvMlxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCArIGFuaW1hdGlvbk9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSArIGFuaW1hdGlvbk9mZnNldC55LFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcbiAgICAgICAgICAgICgtc3ByaXRlLnNpemUueCpzcHJpdGUuc2NhbGUueC8yKSp0aGlzLnpvb20sICgtc3ByaXRlLnNpemUueSpzcHJpdGUuc2NhbGUueS8yKSp0aGlzLnpvb20sXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XG4gICAgICAgIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJQb2ludCg8UG9pbnQ+Z3JhcGhpYywgdGhpcy56b29tKTtcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBMaW5lKXtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlckxpbmUoPExpbmU+Z3JhcGhpYywgdGhpcy5vcmlnaW4sIHRoaXMuem9vbSk7XG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJSZWN0KDxSZWN0PmdyYXBoaWMsIHRoaXMuem9vbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG4gICAgICAgIGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5yZW5kZXJPcnRob2dvbmFsVGlsZW1hcCg8T3J0aG9nb25hbFRpbGVtYXA+dGlsZW1hcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbil7XG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyU2xpZGVyKHVpRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBUZXh0SW5wdXQpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbR3JhcGhpY11zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XG4gICAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1wb2ludC5zaXplLngvMikqem9vbSwgKC1wb2ludC5zaXplLnkvMikqem9vbSxcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcbiAgICB9XG5cbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGluZS5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCkqem9vbSwgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpKnpvb20pO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHJlY3RcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERyYXcgdGhlIGludGVyaW9yIG9mIHRoZSByZWN0XG4gICAgICAgIGlmKHJlY3QuY29sb3IuYSAhPT0gMCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgb2YgdGhlIHJlY3QgaWYgaXQgaXNuJ3QgdHJhbnNwYXJlbnRcbiAgICAgICAgaWYocmVjdC5ib3JkZXJDb2xvci5hICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwUmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyT3J0aG9nb25hbFRpbGVtYXAodGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXApOiB2b2lkIHtcbiAgICAgICAgbGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aWxlbWFwLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aWxlbWFwKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNjZW5lLmdldFZpZXdwb3J0KCkuZ2V0SGFsZlNpemUoKTtcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuICAgICAgICBsZXQgYm90dG9tUmlnaHQgPSBvcmlnaW4uY2xvbmUoKS5hZGQoc2l6ZS5zY2FsZWQoMip6b29tKSk7XG5cbiAgICAgICAgaWYodGlsZW1hcC52aXNpYmxlKXtcbiAgICAgICAgICAgIGxldCBtaW5Db2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KG9yaWdpbik7XG4gICAgICAgICAgICBsZXQgbWF4Q29sUm93ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChib3R0b21SaWdodCk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgeCA9IG1pbkNvbFJvdy54OyB4IDw9IG1heENvbFJvdy54OyB4Kyspe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IG1pbkNvbFJvdy55OyB5IDw9IG1heENvbFJvdy55OyB5Kyspe1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbGUgYXQgdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRpbGVtYXAuZ2V0VGlsZUF0Um93Q29sKG5ldyBWZWMyKHgsIHkpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSByb3QvZmxpcCBwYXJhbWV0ZXJzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgweEUgPDwgMjgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3RGbGlwID0gKChtYXNrICYgdGlsZSkgPj4gMjgpICYgMHhGO1xuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZSAmIH5tYXNrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRpbGVzZXQgdGhhdCBvd25zIHRoaXMgdGlsZSBpbmRleCBhbmQgcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwLmdldFRpbGVzZXRzKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKHRpbGUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZXNldCwgdGlsZSwgeCwgeSwgb3JpZ2luLCB0aWxlbWFwLnNjYWxlLCB6b29tLCByb3RGbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGlsZVxuICAgICAqIEBwYXJhbSB0aWxlc2V0IFRoZSB0aWxlc2V0IHRoaXMgdGlsZSBiZWxvbmdzIHRvIFxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBSb3cgVGhlIHJvdyBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB0aWxlbWFwQ29sIFRoZSBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlKHRpbGVzZXQ6IFRpbGVzZXQsIHRpbGVJbmRleDogbnVtYmVyLCB0aWxlbWFwUm93OiBudW1iZXIsIHRpbGVtYXBDb2w6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyLCByb3RGbGlwOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGlsZXNldC5nZXRTdGFydEluZGV4KCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSByb3cgYW5kIGNvbCBvZiB0aGUgdGlsZSBpbiBpbWFnZSBzcGFjZVxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRpbGVzZXQuZ2V0TnVtQ29scygpKTtcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGlsZXNldC5nZXROdW1Db2xzKCk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS54O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKHRpbGVtYXBSb3cgKiB3aWR0aCAqIHNjYWxlLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IodGlsZW1hcENvbCAqIGhlaWdodCAqIHNjYWxlLnkpO1xuXG4gICAgICAgIGxldCB3b3JsZFggPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pO1xuICAgICAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKTtcbiAgICAgICAgbGV0IHdvcmxkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSk7XG4gICAgICAgIGxldCB3b3JsZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSk7XG5cbiAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMTtcbiAgICAgICAgICAgIGxldCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgbGV0IHNoZWFyWCA9IDA7XG4gICAgICAgICAgICBsZXQgc2hlYXJZID0gMDtcblxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeC1heGlzXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgOCl7XG4gICAgICAgICAgICAgICAgc2NhbGVYID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHktYXhpc1xuICAgICAgICAgICAgaWYocm90RmxpcCAmIDQpe1xuICAgICAgICAgICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGlwIG92ZXIgdGhlIGxpbmUgeT14XG4gICAgICAgICAgICBpZihyb3RGbGlwICYgMil7XG4gICAgICAgICAgICAgICAgc2hlYXJYID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHNoZWFyWSA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAwO1xuICAgICAgICAgICAgICAgIHNjYWxlWSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIHNoZWFyWCwgc2hlYXJZLCBzY2FsZVksIHdvcmxkWCArIHdvcmxkV2lkdGgvMiwgd29ybGRZICsgd29ybGRIZWlnaHQvMik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgLXdvcmxkV2lkdGgvMiwgLXdvcmxkSGVpZ2h0LzIsXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZihyb3RGbGlwICE9PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyByb3RhdGlvbnMsIGRvbid0IGRvIHRoZSBjYWxjdWxhdGlvbnMsIGp1c3QgcmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICB3b3JsZFgsIHdvcmxkWSxcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XG4gICAgICAgIH1cblxuXG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbVUlFbGVtZW50XXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlFbGVtZW50UmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBVSUVsZW1lbnRSZW5kZXJlclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxuICAgICAqL1xuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGxhYmVsXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJMYWJlbChsYWJlbDogTGFiZWwpOiB2b2lkIHtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgdW5hc3NpZ25lZCAoYnkgdGhlIHVzZXIgb3IgYXV0b21hdGljYWxseSkgYXNzaWduIGl0XG4gICAgICAgIGxhYmVsLmhhbmRsZUluaXRpYWxTaXppbmcodGhpcy5jdHgpO1xuXHRcdFxuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmb250IGFuZCB0ZXh0IHBvc2l0aW9uIGluIGxhYmVsXG5cdFx0dGhpcy5jdHguZm9udCA9IGxhYmVsLmdldEZvbnRTdHJpbmcoKTtcblx0XHRsZXQgb2Zmc2V0ID0gbGFiZWwuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLmN0eCk7XG5cblx0XHQvLyBTdHJva2UgYW5kIGZpbGwgYSByb3VuZGVkIHJlY3QgYW5kIGdpdmUgaXQgdGV4dFxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYmFja2dyb3VuZENvbG9yLmE7XG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCkudG9TdHJpbmdSR0JBKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1sYWJlbC5zaXplLngvMiwgLWxhYmVsLnNpemUueS8yLFxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XG5cdFx0XG5cdFx0dGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYm9yZGVyQ29sb3IuYTtcblx0XHR0aGlzLmN0eC5saW5lV2lkdGggPSBsYWJlbC5ib3JkZXJXaWR0aDtcblx0XHR0aGlzLmN0eC5zdHJva2VSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xuXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlVGV4dENvbG9yKCk7XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC50ZXh0Q29sb3IuYTtcblx0XHR0aGlzLmN0eC5maWxsVGV4dChsYWJlbC50ZXh0LCBvZmZzZXQueCAtIGxhYmVsLnNpemUueC8yLCBvZmZzZXQueSAtIGxhYmVsLnNpemUueS8yKTtcblx0XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBidXR0b25cbiAgICAgKiBAcGFyYW0gYnV0dG9uIFRoZSBidXR0b24gdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyQnV0dG9uKGJ1dHRvbjogQnV0dG9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwoYnV0dG9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc2xpZGVyXG4gICAgICogQHBhcmFtIHNsaWRlciBUaGUgc2xpZGVyIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlclNsaWRlcihzbGlkZXI6IFNsaWRlcik6IHZvaWQge1xuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBzbGlkZXIuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xuXG4gICAgICAgIC8vIENhbGN1YWxhdGUgdGhlIHNsaWRlciBzaXplXG4gICAgICAgIGxldCBzbGlkZXJTaXplID0gbmV3IFZlYzIoc2xpZGVyLnNpemUueCwgMik7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgc2xpZGVyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLnNsaWRlckNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1zbGlkZXJTaXplLngvMiwgLXNsaWRlclNpemUueS8yLFxuICAgICAgICAgICAgc2xpZGVyU2l6ZS54LCBzbGlkZXJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmliIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgICAgIGxldCB4ID0gTWF0aFV0aWxzLmxlcnAoLXNsaWRlci5zaXplLngvMiwgc2xpZGVyLnNpemUueC8yLCBzbGlkZXIuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgbmliXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLm5pYkNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KHgtc2xpZGVyLm5pYlNpemUueC8yLCAtc2xpZGVyLm5pYlNpemUueS8yLFxuICAgICAgICAgICAgc2xpZGVyLm5pYlNpemUueCwgc2xpZGVyLm5pYlNpemUueSwgc2xpZGVyLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGFscGhhXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGV4dElucHV0XG4gICAgICogQHBhcmFtIHRleHRJbnB1dCBUaGUgdGV4dElucHV0IHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlclRleHRJbnB1dCh0ZXh0SW5wdXQ6IFRleHRJbnB1dCk6IHZvaWQge1xuICAgICAgICAvLyBTaG93IGEgY3Vyc29yIHNvbWV0aW1lc1xuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCAmJiB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApe1xuICAgICAgICAgICAgdGV4dElucHV0LnRleHQgKz0gXCJ8XCI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKHRleHRJbnB1dCk7XG5cbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQpe1xuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCA9IHRleHRJbnB1dC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0SW5wdXQudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID49IDYwKXtcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IGZyYW1ld29yayB0byBwdXQgYWxsIHJlbmRlcmluZyBpbiBvbmNlIHBsYWNlIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJpbmdNYW5hZ2VyIHtcbiAgICAvKiogVGhlIFJlc291cmNlTWFuYWdlciAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IFNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGFic3RyYWN0IGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBhbmQgdmlzaWJsZSBwb3J0aW9ucyBvZiB0aWxlbWFwcywgYXMgd2VsbCBhcyBhbnkgVUlFbGVtZW50IGluIFVJTGF5ZXJzXG4gICAgICogQHBhcmFtIHZpc2libGVTZXQgVGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzXG4gICAgICogQHBhcmFtIHRpbGVtYXBzIFRoZSB0aWxlbWFwcyB1c2VkIGluIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB1aUxheWVycyBUaGUgdXNlciBpbnRlcmZhY2UgbGF5ZXJzXG4gICAgICovXG4gICAgYWJzdHJhY3QgcmVuZGVyKHZpc2libGVTZXQ6IEFycmF5PENhbnZhc05vZGU+LCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkO1xuXG4gICAgLyoqIENsZWFycyB0aGUgY2FudmFzICovXG4gICAgYWJzdHJhY3QgY2xlYXIoY29sb3I6IENvbG9yKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBzcHJpdGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIGFuaW1hdGVkIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIGFuaW1hdGVkIHNwcml0ZSB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgZ3JhcGhpY1xuICAgICAqIEBwYXJhbSBncmFwaGljIFRoZSBncmFwaGljIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIFVJRWxlbWVudFxuICAgICAqIEBwYXJhbSB1aUVsZW1lbnQgVGhlIFVJRWxlbWVudCB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZDtcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4vV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyaW5nTWFuYWdlciB7XG5cblx0cHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcblx0cHJvdGVjdGVkIHpvb206IG51bWJlcjtcblx0cHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcblxuXHRwcm90ZWN0ZWQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcblx0cHJvdGVjdGVkIHRleHRDdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuXHRpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHtcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMud29ybGRTaXplID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMud29ybGRTaXplLnggPSB3aWR0aDtcblx0XHR0aGlzLndvcmxkU2l6ZS55ID0gaGVpZ2h0O1xuXG5cdFx0Ly8gR2V0IHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuXG5cdFx0dGhpcy5nbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICB0aGlzLmdsLmJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xuXG5cdFx0Ly8gVGVsbCB0aGUgcmVzb3VyY2UgbWFuYWdlciB3ZSdyZSB1c2luZyBXZWJHTFxuXHRcdFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVzZVdlYkdMKHRydWUsIHRoaXMuZ2wpO1xuXG5cdFx0Ly8gU2hvdyB0aGUgdGV4dCBjYW52YXMgYW5kIGdldCBpdHMgY29udGV4dFxuXHRcdGxldCB0ZXh0Q2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jYW52YXNcIik7XG5cdFx0dGV4dENhbnZhcy5oaWRkZW4gPSBmYWxzZTtcblx0XHR0aGlzLnRleHRDdHggPSB0ZXh0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRcdC8vIFNpemUgdGhlIHRleHQgY2FudmFzIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBnYW1lIGNhbnZhc1xuXHRcdHRleHRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRleHRDYW52YXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICByZXR1cm4gdGhpcy5nbDtcblx0fVxuXG5cdHJlbmRlcih2aXNpYmxlU2V0OiBDYW52YXNOb2RlW10sIHRpbGVtYXBzOiBUaWxlbWFwW10sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkIHtcblx0XHRmb3IobGV0IG5vZGUgb2YgdmlzaWJsZVNldCl7XG5cdFx0XHR0aGlzLnJlbmRlck5vZGUobm9kZSk7XG5cdFx0fVxuXG5cdFx0dWlMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYoIXVpTGF5ZXJzLmdldChrZXkpLmlzSGlkZGVuKCkpXG5cdFx0XHRcdHVpTGF5ZXJzLmdldChrZXkpLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKSlcblx0XHR9KTtcblx0fVxuXG5cdGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMuZ2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcblx0XHR0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cblx0XHR0aGlzLnRleHRDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdC8vIENhbGN1bGF0ZSB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhpcyBzcHJpdGVcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cdFx0XG5cdFx0aWYobm9kZS5oYXNDdXN0b21TaGFkZXIpe1xuXHRcdFx0Ly8gSWYgdGhlIG5vZGUgaGFzIGEgY3VzdG9tIHNoYWRlciwgcmVuZGVyIHVzaW5nIHRoYXRcblx0XHRcdHRoaXMucmVuZGVyQ3VzdG9tKG5vZGUpO1xuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XG5cdFx0XHR0aGlzLnJlbmRlckdyYXBoaWMobm9kZSk7XG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xuXHRcdFx0aWYobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcblx0XHRcdFx0dGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZShub2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyU3ByaXRlKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcblx0XHRcdHRoaXMucmVuZGVyVUlFbGVtZW50KG5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XG5cblx0XHRpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIpO1xuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0XHR9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3QpIHtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIpO1xuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0XHR9IFxuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQge1xuXHRcdGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHVpRWxlbWVudCksIHVpRWxlbWVudCk7XG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXG5cdFx0XHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsICh1aUVsZW1lbnQucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKHVpRWxlbWVudC5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcblx0XHRcdHRoaXMudGV4dEN0eC5yb3RhdGUoLXVpRWxlbWVudC5yb3RhdGlvbik7XG5cdFx0XHRsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGE7XG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQuYWxwaGE7XG5cblx0XHRcdC8vIFJlbmRlciB0ZXh0XG5cdFx0XHR0aGlzLnRleHRDdHguZm9udCA9IHVpRWxlbWVudC5nZXRGb250U3RyaW5nKCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy50ZXh0Q3R4KTtcblx0XHRcdHRoaXMudGV4dEN0eC5maWxsU3R5bGUgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dENvbG9yKCk7XG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQudGV4dENvbG9yLmE7XG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFRleHQodWlFbGVtZW50LnRleHQsIG9mZnNldC54IC0gdWlFbGVtZW50LnNpemUueC8yLCBvZmZzZXQueSAtIHVpRWxlbWVudC5zaXplLnkvMik7XG5cblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgICAgICBcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlckN1c3RvbShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChub2RlLmN1c3RvbVNoYWRlcktleSk7XG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMobm9kZSksIG5vZGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgYWRkT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0Ly8gR2l2ZSB0aGUgc2hhZGVyIGFjY2VzcyB0byB0aGUgd29ybGQgc2l6ZVxuXHRcdG9wdGlvbnMud29ybGRTaXplID0gdGhpcy53b3JsZFNpemU7XG5cblx0XHQvLyBBZGp1c3QgdGhlIG9yaWdpbiBwb3NpdGlvbiB0byB0aGUgcGFyYWxsYXhcblx0XHRsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XG5cdFx0bGV0IHBhcmFsbGF4ID0gbmV3IFZlYzIoMSwgMSk7XG5cdFx0aWYobGF5ZXIgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyKXtcblx0XHRcdHBhcmFsbGF4ID0gKDxQYXJhbGxheExheWVyPmxheWVyKS5wYXJhbGxheDtcblx0XHR9XG5cblx0XHRvcHRpb25zLm9yaWdpbiA9IHRoaXMub3JpZ2luLmNsb25lKCkubXVsdChwYXJhbGxheCk7XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxuXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcblxuLyoqXG4gKiBBIHdyYXBwZXIgY2xhc3MgZm9yIFdlYkdMIHNoYWRlcnMuXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2luZ2xldG9uLCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZm9yIGVhY2ggc2hhZGVyIHR5cGUuXG4gKiBBbGwgb2JqZWN0cyB0aGF0IHVzZSB0aGlzIHNoYWRlciB0eXBlIHdpbGwgcmVmZXIgdG8gYW5kIG1vZGlmeSB0aGlzIHNhbWUgdHlwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVHlwZSB7XG5cdC8qKiBUaGUgbmFtZSBvZiB0aGlzIHNoYWRlciAqL1xuXHRwcm90ZWN0ZWQgbmFtZTogc3RyaW5nO1xuXG5cdC8qKiBUaGUga2V5IHRvIHRoZSBXZWJHTFByb2dyYW0gaW4gdGhlIFJlc291cmNlTWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcHJvZ3JhbUtleTogc3RyaW5nO1xuXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVzb3VyY2UgbWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHR0aGlzLnByb2dyYW1LZXkgPSBwcm9ncmFtS2V5O1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW55IGJ1ZmZlciBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNoYWRlciB0eXBlLlxuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRhYnN0cmFjdCBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIExvYWRzIGFueSB1bmlmb3Jtc1xuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3Qgd2UncmUgY3VycmVudGx5IHJlbmRlcmluZ1xuXHQgKi9cblx0YWJzdHJhY3QgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlIGFuZCBnaXZlcyB0aGVtIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gZ2V0IG9wdGlvbnMgZnJvbVxuXHQgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlciBmdW5jdGlvblxuXHQgKi9cblx0Z2V0T3B0aW9ucyhub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7cmV0dXJuIHt9O31cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwibGFiZWxcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XG5cdFx0Y29uc3QgYm9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yLnRvV2ViR0woKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQmFja2dyb3VuZENvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9CYWNrZ3JvdW5kQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0JhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZENvbG9yKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlckNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJDb2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yKTtcblxuICAgICAgICBjb25zdCB1X01heFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X01heFNpemVcIik7XG4gICAgICAgIGdsLnVuaWZvcm0yZih1X01heFNpemUsIC12ZXJ0ZXhEYXRhWzBdLCB2ZXJ0ZXhEYXRhWzFdKTtcblxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cbiAgICAgICAgY29uc3QgdV9Cb3JkZXJXaWR0aCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyV2lkdGhcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlclJhZGl1cyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyUmFkaXVzXCIpO1xuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcblx0ICovXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgeCwgeTtcblxuXHRcdGlmKGggPiB3KXtcblx0XHRcdHkgPSAwLjU7XG5cdFx0XHR4ID0gdy8oMipoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IDAuNTtcblx0XHRcdHkgPSBoLygyKncpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSxcblx0XHRcdC14LCAteSxcblx0XHRcdCB4LCAgeSxcblx0XHRcdCB4LCAteVxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogcmVjdC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IHJlY3QuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxuXHRcdFx0c2l6ZTogcmVjdC5zaXplLFxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50U2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xuXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicG9pbnRcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XG5cdFx0bGV0IGNvbG9yID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvbG9yKG9wdGlvbnMuY29sb3IpO1xuXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSBwb3NpdGlvbjtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcblxuXHRcdGNvbnN0IHVfUG9pbnRTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Qb2ludFNpemVcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfUG9pbnRTaXplLCBvcHRpb25zLnBvaW50U2l6ZSk7XG5cblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHBvaW50OiBQb2ludCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxuXHRcdFx0Y29sb3I6IHBvaW50LmNvbG9yLFxuXHRcdFx0cG9pbnRTaXplOiBwb2ludC5zaXplLFxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlclR5cGVcIjtcblxuLyoqIFJlcHJlc2VudHMgYW55IFdlYkdMIG9iamVjdHMgdGhhdCBoYXZlIGEgcXVhZCBtZXNoIChpLmUuIGEgcmVjdGFuZ3VsYXIgZ2FtZSBvYmplY3QgY29tcG9zZWQgb2Ygb25seSB0d28gdHJpYW5nbGVzKSAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUXVhZFNoYWRlclR5cGUgZXh0ZW5kcyBTaGFkZXJUeXBlIHtcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xuXHRwcm90ZWN0ZWQgc2NhbGU6IE1hdDR4NDtcblxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgcm90YXRpb246IE1hdDR4NDtcblxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgdHJhbnNsYXRpb246IE1hdDR4NDtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xuXHRcdHRoaXMudHJhbnNsYXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicmVjdFwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvci50b1dlYkdMKCk7XG5cblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcblxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xuXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZVkgPSAtKG9wdGlvbnMucG9zaXRpb24ueSAtIG9wdGlvbnMub3JpZ2luLnkgLSBvcHRpb25zLndvcmxkU2l6ZS55LzIpL21heERpbWVuc2lvbjtcblxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0dGhpcy50cmFuc2xhdGlvbi50cmFuc2xhdGUobmV3IEZsb2F0MzJBcnJheShbdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0pKTtcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xuXHRcdGxldCB0cmFuc2Zvcm1hdGlvbiA9IE1hdDR4NC5NVUxUKHRoaXMudHJhbnNsYXRpb24sIHRoaXMuc2NhbGUsIHRoaXMucm90YXRpb24pO1xuXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcblx0XHRjb25zdCB1X1RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfVHJhbnNmb3JtXCIpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xuXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHR9XG5cblxuXHQvKlxuXHRcdFNvIGFzIGl0IHR1cm5zIG91dCwgV2ViR0wgaGFzIGFuIGlzc3VlIHdpdGggbm9uLXNxdWFyZSBxdWFkcy5cblx0XHRJdCBkb2Vzbid0IGxpa2Ugd2hlbiB5b3UgZG9uJ3QgaGF2ZSBhIDEtMSBzY2FsZSwgYW5kIHJvdGF0aW9ucyBhcmUgZW50aXJlbHkgbWVzc2VkIHVwIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuXHRcdFRvIHNvbHZlIHRoaXMsIEkgdXNlZCB0aGUgc2NhbGUgb2YgdGhlIExBUkdFU1QgZGltZW5zaW9uIG9mIHRoZSBxdWFkIHRvIG1ha2UgYSBzcXVhcmUsIHRoZW4gYWRqdXN0ZWQgdGhlIHZlcnRleCBjb29yZGluYXRlcyBpbnNpZGUgb2YgdGhhdC5cblx0XHRBIGRpYWdyYW0gb2YgdGhlIHNvbHV0aW9uIGZvbGxvd3MuXG5cblx0XHRUaGVyZSBpcyBhIGJvdW5kaW5nIHNxdWFyZSBmb3IgdGhlIHF1YWQgd2l0aCBkaW1lbnNpb25zIGh4aCAoaW4gdGhpcyBjYXNlLCBzaW5jZSBoZWlnaHQgaXMgdGhlIGxhcmdlc3QgZGltZW5zaW9uKS5cblx0XHRUaGUgb2Zmc2V0IGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24gaXMgdGhlcmVmb3JlIDAuNSwgYXMgaXQgaXMgbm9ybWFsbHkuXG5cdFx0SG93ZXZlciwgdGhlIG9mZnNldCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gaXMgbm90IHNvIHN0cmFpZ2h0Zm9yd2FyZCwgYnV0IGlzbid0IGNvbmNlcHR1YWxseSBoYXJkLlxuXHRcdEFsbCB3ZSByZWFsbHkgaGF2ZSB0byBkbyBpcyBhIHJhbmdlIGNoYW5nZSBmcm9tIFswLCBoZWlnaHQvMl0gdG8gWzAsIDAuNV0sIHdoZXJlIG91ciB2YWx1ZSBpcyB0ID0gd2lkdGgvMiwgYW5kIDAgPD0gdCA8PSBoZWlnaHQvMi5cblxuXHRcdFNvIG5vdyB3ZSBoYXZlIG91ciByZWN0LCBpbiBhIHNwYWNlIHNjYWxlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uLlxuXHRcdFJvdGF0aW9ucyB3b3JrIGFzIHlvdSB3b3VsZCBleHBlY3QsIGV2ZW4gZm9yIGxvbmcgcmVjdGFuZ2xlcy5cblxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0X18gX18gX18gX18gX18gX18gX19cblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHQtMC41fF8gX3w4ODg4ODg4ODg4OHxfIF98MC41XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdCAgXHRcdHxfX198ODg4ODg4ODg4ODh8X19ffFxuXHRcdFx0ICBcdFx0LTAuNVxuXG5cdFx0VGhlIGdldFZlcnRpY2VzIGZ1bmN0aW9uIGJlbG93IGRvZXMgYXMgZGVzY3JpYmVkLCBhbmQgY29udmVydHMgdGhlIHJhbmdlXG5cdCovXG5cdC8qKlxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxuXHQgKi9cblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdGxldCB4LCB5O1xuXG5cdFx0aWYoaCA+IHcpe1xuXHRcdFx0eSA9IDAuNTtcblx0XHRcdHggPSB3LygyKmgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0eSA9IGgvKDIqdyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0LXgsICB5LFxuXHRcdFx0LXgsIC15LFxuXHRcdFx0IHgsICB5LFxuXHRcdFx0IHgsIC15XG5cdFx0XSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHJlY3Q6IFJlY3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxuXHRcdFx0Y29sb3I6IHJlY3QuY29sb3IsXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXG5cdFx0XHRyb3RhdGlvbjogcmVjdC5yb3RhdGlvblxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqIEEgc2hhZGVyIGZvciBzcHJpdGVzIGFuZCBhbmltYXRlZCBzcHJpdGVzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJzcHJpdGVcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRleHR1cmUob3B0aW9ucy5pbWFnZUtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNjYWxlKTtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Y29uc3QgYV9UZXhDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9UZXhDb29yZFwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfVGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAyKkZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1RleENvb3JkKTtcblxuXHRcdC8vIFVuaWZvcm1zXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBTZXQgdXAgb3VyIHNhbXBsZXIgd2l0aCBvdXIgYXNzaWduZWQgdGV4dHVyZSB1bml0XG5cdFx0Y29uc3QgdV9TYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9TYW1wbGVyXCIpO1xuXHRcdGdsLnVuaWZvcm0xaSh1X1NhbXBsZXIsIHRleHR1cmUpO1xuXG5cdFx0Ly8gUGFzcyBpbiB0ZXhTaGlmdFxuXHRcdGNvbnN0IHVfdGV4U2hpZnQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleFNoaWZ0XCIpO1xuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTaGlmdCwgb3B0aW9ucy50ZXhTaGlmdCk7XG5cblx0XHQvLyBQYXNzIGluIHRleFNjYWxlXG5cdFx0Y29uc3QgdV90ZXhTY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2NhbGVcIik7XG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNjYWxlLCBvcHRpb25zLnRleFNjYWxlKTtcblxuXHRcdC8vIERyYXcgdGhlIHF1YWRcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxuXHQgKi9cblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIsIHNjYWxlOiBGbG9hdDMyQXJyYXkpOiBGbG9hdDMyQXJyYXkge1xuXHRcdGxldCB4LCB5O1xuXG5cdFx0aWYoaCA+IHcpe1xuXHRcdFx0eSA9IDAuNTtcblx0XHRcdHggPSB3LygyKmgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0eSA9IGgvKDIqdyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgdGhlIHJlbmRlcmluZyBzcGFjZSBpZiBuZWVkZWRcblx0XHR4ICo9IHNjYWxlWzBdO1xuXHRcdHkgKj0gc2NhbGVbMV07XG5cblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQteCwgIHksIDAuMCwgMC4wLFxuXHRcdFx0LXgsIC15LCAwLjAsIDEuMCxcblx0XHRcdCB4LCAgeSwgMS4wLCAwLjAsXG5cdFx0XHQgeCwgLXksIDEuMCwgMS4wXG5cdFx0XSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHNwcml0ZTogU3ByaXRlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0bGV0IHRleFNoaWZ0O1xuXHRcdGxldCB0ZXhTY2FsZTtcblxuXHRcdGlmKHNwcml0ZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcblx0XHRcdGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoW29mZnNldC54IC8gKHNwcml0ZS5jb2xzICogc3ByaXRlLnNpemUueCksIG9mZnNldC55IC8gKHNwcml0ZS5yb3dzICogc3ByaXRlLnNpemUueSldKTtcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMS8oc3ByaXRlLmNvbHMpLCAxLyhzcHJpdGUucm93cyldKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSk7XG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKTtcblx0XHR9XG5cblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiBzcHJpdGUucG9zaXRpb24sXG5cdFx0XHRyb3RhdGlvbjogc3ByaXRlLnJvdGF0aW9uLFxuXHRcdFx0c2l6ZTogc3ByaXRlLnNpemUsXG5cdFx0XHRzY2FsZTogc3ByaXRlLnNjYWxlLnRvQXJyYXkoKSxcblx0XHRcdGltYWdlS2V5OiBzcHJpdGUuaW1hZ2VJZCxcblx0XHRcdHRleFNoaWZ0LFxuXHRcdFx0dGV4U2NhbGVcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvU3RyaW5nVXRpbHNcIjtcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcbmltcG9ydCBXZWJHTFByb2dyYW1UeXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGVcIjtcblxuLyoqXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBmb3IgdGhlIGdhbWUgZW5naW5lLlxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgaW50ZXJmYWNlcyB3aXRoIHRoZSBsb2FkYWJsZSBhc3NldHMgb2YgYSBnYW1lIHN1Y2ggYXMgaW1hZ2VzLCBkYXRhIGZpbGVzLFxuICogYW5kIHNvdW5kcywgd2hpY2ggYXJlIGFsbCBmb3VuZCBpbiB0aGUgZGlzdCBmb2xkZXIuXG4gKiBUaGlzIGNsYXNzIGNvbnRyb2xzIGxvYWRpbmcgYW5kIHVwZGF0ZXMgdGhlIEByZWZlcmVuY2VbU2NlbmVdIHdpdGggdGhlIGxvYWRpbmcgcHJvZ3Jlc3MsIHNvIHRoYXQgdGhlIHNjZW5lIGRvZXMgXG4gKiBub3Qgc3RhcnQgYmVmb3JlIGFsbCBuZWNlc3NhcnkgYXNzZXRzIGFyZSBsb2FkZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlTWFuYWdlciB7XG4gICAgLy8gSW5zdGFuY2UgZm9yIHRoZSBzaW5nbGV0b24gY2xhc3NcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIFxuICAgIC8vIEJvb2xlYW5zIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBvciBub3QgdGhlIFJlc291cmNlTWFuYWdlciBpcyBjdXJyZW50bHkgbG9hZGluZyBzb21ldGhpbmdcbiAgICAvKiogV2hldGhlciBvciBub3QgYW55IHJlc291cmNlcyBhcmUgbG9hZGluZyAqL1xuICAgIHByaXZhdGUgbG9hZGluZzogYm9vbGVhbjtcbiAgICAvKiogQSBib29sZWFuIHRvIGluZGljYXRlIHRoYXQgdGhlIGFzc2V0cyBqdXN0IGZpbmlzaGVkIGxvYWRpbmcgKi9cbiAgICBwcml2YXRlIGp1c3RMb2FkZWQ6IGJvb2xlYW47XG5cbiAgICAvLyBGdW5jdGlvbnMgdG8gZG8gc29tZXRoaW5nIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzIG9yIGlzIGNvbXBsZXRlZCBzdWNoIGFzIHJlbmRlciBhIGxvYWRpbmcgc2NyZWVuXG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgKi9cbiAgICBwdWJsaWMgb25Mb2FkUHJvZ3Jlc3M6IEZ1bmN0aW9uO1xuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBjb21wbGV0ZXMgKi9cbiAgICBwdWJsaWMgb25Mb2FkQ29tcGxldGU6IEZ1bmN0aW9uO1xuXG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaW1hZ2VzIG5lZWQgdG8gYmUgbG9hZGVkKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VzVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBpbWFnZXMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgaW1hZ2VzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lLiBUaGUgcmVmZXJlbmNlIHRvIHRoZXNlIGltYWdlcyBvbmx5IGV4aXN0IGhlcmUgZm9yIGVhc3kgY2xlYW51cC4gKi9cbiAgICBwcml2YXRlIGltYWdlczogTWFwPEhUTUxJbWFnZUVsZW1lbnQ+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cbiAgICBwcml2YXRlIHNwcml0ZXNoZWV0czogTWFwPFNwcml0ZXNoZWV0PjtcblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgdGlsZW1hcHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXG4gICAgcHJpdmF0ZSB0aWxlbWFwczogTWFwPFRpbGVkVGlsZW1hcERhdGE+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHNvdW5kcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIGFyZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBzb3VuZHMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgc291bmRzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgYXVkaW9CdWZmZXJzOiBNYXA8QXVkaW9CdWZmZXI+O1xuXG4gICAgLyoqIFRoZSB0b3RhbCBudW1iZXIgb2YgXCJ0eXBlc1wiIG9mIHRoaW5ncyB0aGF0IG5lZWQgdG8gYmUgbG9hZGVkIChpLmUuIGltYWdlcyBhbmQgdGlsZW1hcHMpICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90eXBlc1RvTG9hZDogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGVkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uVG9Mb2FkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgcHJpdmF0ZSBqc29uT2JqZWN0czogTWFwPFJlY29yZDxzdHJpbmcsIGFueT4+O1xuXG4gICAgLyogIyMjIyMjIyMjIyBJTkZPUk1BVElPTiBTUEVDSUFMIFRPIFdFQkdMICMjIyMjIyMjIyMgKi9cbiAgICBwcml2YXRlIGdsX1dlYkdMQWN0aXZlOiBib29sZWFuO1xuXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aF9TaGFkZXI+O1xuXG4gICAgcHJpdmF0ZSBnbF9TaGFkZXJQcm9ncmFtczogTWFwPFdlYkdMUHJvZ3JhbVR5cGU+O1xuXG4gICAgcHJpdmF0ZSBnbF9UZXh0dXJlczogTWFwPG51bWJlcj47XG4gICAgcHJpdmF0ZSBnbF9OZXh0VGV4dHVyZUlEOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBnbF9CdWZmZXJzOiBNYXA8V2ViR0xCdWZmZXI+OyBcblxuICAgIHByaXZhdGUgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcblxuICAgIC8qICMjIyMjIyMjIyMgVU5MT0FESU5HIEFORCBFWENMVVNJT04gTElTVCAjIyMjIyMjIyMjICovXG4gICAgLyoqIEEgbGlzdCBvZiByZXNvdXJjZXMgdGhhdCB3aWxsIGJlIHVubG9hZGVkIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcml2YXRlIHJlc291cmNlc1RvVW5sb2FkOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XG5cbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0byBrZWVwIHVudGlsIGZ1cnRoZXIgbm90aWNlICovXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb0tlZXA6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLmpzb25PYmplY3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcblxuICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCA9IDA7XG4gICAgICAgIHRoaXMuZ2xfQnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwID0gbmV3IEFycmF5KCk7XG4gICAgfTtcblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgU0lOR0xFVE9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIGV4aXN0XG4gICAgICogQHJldHVybnMgVGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUmVzb3VyY2VNYW5hZ2VyIHtcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUFVCTElDIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyBvciBkZWFjdGl2YXRlcyB0aGUgdXNlIG9mIFdlYkdMXG4gICAgICogQHBhcmFtIGZsYWcgVHJ1ZSBpZiBXZWJHTCBzaG91bGQgYmUgdXNlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIGdsIFRoZSBpbnN0YW5jZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dCwgaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyB1c2VXZWJHTChmbGFnOiBib29sZWFuLCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2xfV2ViR0xBY3RpdmUgPSBmbGFnO1xuXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIGltYWdlIHdpdGhcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBpbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgcHVibGljIGtlZXBJbWFnZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2UgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SW1hZ2Uoa2V5OiBzdHJpbmcpOiBIVE1MSW1hZ2VFbGVtZW50IHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5pbWFnZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmKGltYWdlID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgYFRoZXJlIGlzIG5vIGltYWdlIGFzc29jaWF0ZWQgd2l0aCBrZXkgXCIke2tleX1cImBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzcHJpdGVzaGVldCBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgc3ByaXRlc2hlZXQgd2l0aFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIHNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMga2VlcFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgc3ByaXRlc2hlZXRcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIFNwcml0ZXNoZWV0XG4gICAgICovXG4gICAgcHVibGljIGdldFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogU3ByaXRlc2hlZXQge1xuICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzaGVldHMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIGF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBBdWRpbyhrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5BVURJTyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEByZXR1cm5zIFRoZSBBdWRpb0J1ZmZlciBjcmVhdGVkIGZyb20gdGhlIGxvYWRlZCBhdWRpbyBmbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXVkaW8oa2V5OiBzdHJpbmcpOiBBdWRpb0J1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvQnVmZmVycy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgdGlsZW1hcCBmcm9tIGEganNvbiBmaWxlLiBBdXRvbWF0aWNhbGx5IGxvYWRzIHJlbGF0ZWQgaW1hZ2VzXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdGlsZW1hcChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBUaWxlbWFwKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlbWFwIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGlsZW1hcChrZXk6IHN0cmluZyk6IFRpbGVkVGlsZW1hcERhdGEge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlbWFwcy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBvYmplY3QgZnJvbSBhIGpzb24gZmlsZS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUganNvbiBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgIHB1YmxpYyBrZWVwT2JqZWN0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0T2JqZWN0KGtleTogc3RyaW5nKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk9iamVjdHMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBMT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCByZXNvdXJjZXMgY3VycmVudGx5IGluIHRoZSBxdWV1ZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsIHdoZW4gdGhlIHJlc291cmNlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIGxvYWRSZXNvdXJjZXNGcm9tUXVldWUoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQgPSA1O1xuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gTG9hZCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZXMuIFRpbGVtYXBzIGhhdmUgdG8gY29tZSBiZWZvcmUgaW1hZ2VzIGJlY2F1c2UgdGhleSB3aWxsIGFkZCBuZXcgaW1hZ2VzIHRvIHRoZSBxdWV1ZVxuICAgICAgICB0aGlzLmxvYWRUaWxlbWFwc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBUaWxlbWFwc1wiKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU3ByaXRlc2hlZXRzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEltYWdlc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEltYWdlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW9Gcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgQXVkaW9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRPYmplY3RzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBPYmplY3RzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFNoYWRlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgLy8gRG9uZSBsb2FkaW5nXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgVU5MT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIFxuICAgIHByaXZhdGUga2VlcFJlc291cmNlKGtleTogc3RyaW5nLCB0eXBlOiBSZXNvdXJjZVR5cGUpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJLZWVwIHJlc291cmNlLi4uXCIpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkW2ldO1xuICAgICAgICAgICAgaWYocmVzb3VyY2Uua2V5ID09PSBrZXkgJiYgcmVzb3VyY2UucmVzb3VyY2VUeXBlID09PSB0eXBlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIHJlc291cmNlIFwiICsga2V5ICsgXCIgb2YgdHlwZSBcIiArIHR5cGUgKyBcIi4gS2VlcGluZy5cIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlVG9Nb3ZlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb0tlZXAucHVzaCguLi5yZXNvdXJjZVRvTW92ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcmVmZXJlbmNlcyB0byBhbGwgcmVzb3VyY2VzIGluIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICovXG4gICAgdW5sb2FkQWxsUmVzb3VyY2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yKGxldCByZXNvdXJjZSBvZiB0aGlzLnJlc291cmNlc1RvVW5sb2FkKXtcbiAgICAgICAgICAgIC8vIFVubG9hZCB0aGUgcmVzb3VyY2VcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UocmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bmxvYWRSZXNvdXJjZShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBpdHNlbGZcbiAgICAgICAgc3dpdGNoKHJlc291cmNlLnJlc291cmNlVHlwZSl7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5JTUFHRTpcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbF9UZXh0dXJlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5USUxFTUFQOlxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVDpcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkFVRElPOlxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSlNPTjpcbiAgICAgICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuU0hBREVSOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KHJlc291cmNlLmtleSkuZGVsZXRlKHRoaXMuZ2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgYW55IGRlcGVuZGVuY2llc1xuICAgICAgICBmb3IobGV0IGRlcGVuZGVuY3kgb2YgcmVzb3VyY2UuZGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UoZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdPUksgRlVOQ1RJT05TICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCB0aWxlbWFwcyBjdXJyZW50bHkgaW4gdGhlIHRpbGVtYXAgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGVtYXAodGlsZW1hcC5rZXksIHRpbGVtYXAucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgdGlsZW1hcCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gcGF0aFRvVGlsZW1hcEpTT04gVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgSlNPTiBmaWxlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcChrZXk6IHN0cmluZywgcGF0aFRvVGlsZW1hcEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1RpbGVtYXBKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbGVtYXBPYmplY3QgPSA8VGlsZWRUaWxlbWFwRGF0YT5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5hZGQoa2V5LCB0aWxlbWFwT2JqZWN0KTtcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgdGlsZXNldCBpbWFnZXMgd2UgbmVlZCB0byBsb2FkIGFuZCBhZGQgdGhlbSB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cyl7XG4gICAgICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlc2V0LmltYWdlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGlsZXNldC50aWxlcyl7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiB0aWxlc2V0LnRpbGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVzb3VyY2UgcmVmZXJlbmNlIHRvIHRoZSBsaXN0IG9mIHJlc291cmNlIHRvIHVubG9hZFxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHRpbGVtYXAuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nVGlsZW1hcChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHNwcml0ZXNoZWV0cyBjdXJyZW50bHkgaW4gdGhlIHNwcml0ZXNoZWV0IGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNwcml0ZXNoZWV0cyBhcmUgZG9uZSBsb2FkaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBzcHJpdGVzaGVldCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aFRvU3ByaXRlc2hlZXRKU09OIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCBKU09OIGZpbGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoVG9TcHJpdGVzaGVldEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTiwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IDxTcHJpdGVzaGVldD5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuYWRkKGtleSwgc3ByaXRlc2hlZXQpO1xuXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xuXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvU3ByaXRlc2hlZXRKU09OKSArIHNwcml0ZXNoZWV0LnNwcml0ZVNoZWV0SW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleTogc3ByaXRlc2hlZXQubmFtZSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKHNwcml0ZXNoZWV0Lm5hbWUsIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSBzcHJpdGVzaGVldC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIGltYWdlcyBjdXJyZW50bHkgaW4gdGhlIGltYWdlIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaW1hZ2VzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRJbWFnZXNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGltYWdlID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShpbWFnZS5rZXksIGltYWdlLnBhdGgsIGltYWdlLmlzRGVwZW5kZW5jeSwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgaW1hZ2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXG4gICAgICovXG4gICAgcHVibGljIGxvYWRJbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBZGQgdG8gbG9hZGVkIGltYWdlc1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMuYWRkKGtleSwgaW1hZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3QgYSBkZXBlbmRlbmN5LCBwdXNoIGl0IHRvIHRoZSB1bmxvYWQgbGlzdC4gT3RoZXJ3aXNlIGl0J3MgbWFuYWdlZCBieSBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgaWYoIWlzRGVwZW5kZW5jeSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcbiAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2ViR0xUZXh0dXJlKGtleSwgaW1hZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1hZ2UgbG9hZFxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBpbWFnZS4gSWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZSwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBpbWFnZXNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgYXVkaW8gY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGlsZW1hcHMgYXJlIGRvbmUgbG9hZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgc2luZ3VsYXIgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgYXVkaW9DdHggPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpb0NvbnRleHQoKTtcblxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGF1ZGlvIGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nIHNvdW5kXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIGxvYWRpbmcgc291bmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGF1ZGlvIGZpbGUuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdG9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gc2FtcGxlIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBvYmplY3QgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBvYmplY3RzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRPYmplY3RzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxuICAgICAqL1xuICAgIHB1YmxpYyBsb2FkT2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xuICAgICAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5hZGQoa2V5LCBvYmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pKTtcblxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gb2JqZWN0LiBJZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdCwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgb2JqZWN0c1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgV0VCR0wgU1BFQ0lGSUMgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNoYWRlclByb2dyYW0oa2V5OiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xuICAgICAgICByZXR1cm4gdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQoa2V5KS5wcm9ncmFtO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsX0J1ZmZlcnMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0dXJlIElEXG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IHRoaXMuZ2V0VGV4dHVyZUlEKHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIHRleHR1cmVcbiAgICAgICAgLy8gRW5hYmxlIHRleHR1cmUwXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEJpbmQgb3VyIHRleHR1cmUgdG8gdGV4dHVyZSAwXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBpbWFnZVxuICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0ZXh0dXJlIHRvIG91ciBtYXAgd2l0aCB0aGUgc2FtZSBrZXkgYXMgdGhlIGltYWdlXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUga2V5XG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCArPSAxO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBTdGFydCB3aXRoIDkgY2FzZXMgLSB0aGlzIGNhbiBiZSBleHBhbmRlZCBpZiBuZWVkZWQsIGJ1dCBmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIFRleHR1cmVzIHNob3VsZCBiZSBzdGl0Y2hlZCBpbnRvIGFuIGF0bGFzXG4gICAgICAgIHN3aXRjaChpZCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNDtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTU7XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xuICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNztcbiAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTg7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVCdWZmZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyBsb2FkaW5nIG9mIGEgbmV3IHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGggXG4gICAgICogQHBhcmFtIGZTaGFkZXJGaWxlcGF0aCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2hhZGVyKGtleTogc3RyaW5nLCB2U2hhZGVyRmlsZXBhdGg6IHN0cmluZywgZlNoYWRlckZpbGVwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNwbGl0UGF0aCA9IHZTaGFkZXJGaWxlcGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIGxldCBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJ2c2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdFBhdGggPSBmU2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJmc2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0aHMgPSBuZXcgS2V5UGF0aF9TaGFkZXIoKTtcbiAgICAgICAgcGF0aHMua2V5ID0ga2V5O1xuICAgICAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcbiAgICAgICAgcGF0aHMuZnBhdGggPSBmU2hhZGVyRmlsZXBhdGg7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZW5xdWV1ZShwYXRocyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcFNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIHdlYkdMIGlzbidhY3RpdmUgb3IgdGhlcmUgYXJlIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXIoc2hhZGVyLmtleSwgc2hhZGVyLnZwYXRoLCBzaGFkZXIuZnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXIoa2V5OiBzdHJpbmcsIHZwYXRoOiBzdHJpbmcsIGZwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2U2hhZGVyID0gdkZpbGVUZXh0O1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZlNoYWRlciA9IGZGaWxlVGV4dFxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSA9IHRoaXMuY3JlYXRlU2hhZGVyUHJvZ3JhbSh2U2hhZGVyLCBmU2hhZGVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyYW1XcmFwcGVyID0gbmV3IFdlYkdMUHJvZ3JhbVR5cGUoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBvdXIgbWFwXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5hZGQoa2V5LCBwcm9ncmFtV3JhcHBlcik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUikpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNoYWRlcnNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpe1xuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmxvYWRWZXJ0ZXhTaGFkZXIodlNoYWRlclNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5sb2FkRnJhZ21lbnRTaGFkZXIoZlNoYWRlclNvdXJjZSk7XG4gICAgXG4gICAgICAgIGlmKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYSBwcm9ibGVtIGludGlhbGl6aW5nIC0gZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgaWYoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIC8vIEVycm9yIGNyZWF0aW5nXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBdHRhY2ggb3VyIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTGlua1xuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBpZighdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKXtcbiAgICAgICAgICAgIC8vIEVycm9yIGxpbmtpbmdcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBsaW5rIHByb2dyYW06IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBXZSBzdWNjZXNzZnVsbHkgY3JlYXRlIGEgcHJvZ3JhbVxuICAgICAgICByZXR1cm4gW3Byb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRWZXJ0ZXhTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIsIHNoYWRlclNvdXJjZSk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgbG9hZEZyYWdtZW50U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcdFxuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRTaGFkZXIodHlwZTogbnVtYmVyLCBzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xuICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXG4gICAgICAgIGlmKHNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY3JlYXRlIHNoYWRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGVcbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIHdlcmUgbm8gZXJyb3JzIGR1cmluZyB0aGlzIHByb2Nlc3NcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpe1xuICAgICAgICAgICAgLy8gTm90IGNvbXBpbGVkIC0gZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyBHRU5FUkFMIExPQURJTkcgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHByaXZhdGUgbG9hZFRleHRGaWxlKHRleHRGaWxlUGF0aDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgbGV0IHhvYmo6IFhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhvYmoub3ZlcnJpZGVNaW1lVHlwZShcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHhvYmoub3BlbignR0VUJywgdGV4dEZpbGVQYXRoLCB0cnVlKTtcbiAgICAgICAgeG9iai5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHhvYmoucmVhZHlTdGF0ZSA9PSA0KSAmJiAoeG9iai5zdGF0dXMgPT0gMjAwKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeG9iai5zZW5kKG51bGwpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXG5cbiAgICBwcml2YXRlIGdldExvYWRQZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZC90aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkL3RoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkL3RoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQvdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZClcbiAgICAgICAgICAgIC8gdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZDtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5sb2FkaW5nKXtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkUHJvZ3Jlc3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkUHJvZ3Jlc3ModGhpcy5nZXRMb2FkUGVyY2VudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuanVzdExvYWRlZCl7XG4gICAgICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkQ29tcGxldGUpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHJlZmVyZW5jZSB0byBhIHJlc291cmNlLlxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxuICogZGVzdHJveWVkIGlmIHRoZXkgYXJlIHN0aWxsIG5lZWRlZC5cbiAqL1xuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlO1xuICAgIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcsIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlKXtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VUeXBlID0gcmVzb3VyY2VUeXBlO1xuICAgICAgICB0aGlzLiBkZXBlbmRlbmNpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBhZGREZXBlbmRlbmN5KHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHJlc291cmNlKTtcbiAgICB9XG59XG5cblxuZW51bSBSZXNvdXJjZVR5cGUge1xuICAgIElNQUdFID0gXCJJTUFHRVwiLFxuICAgIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcbiAgICBTUFJJVEVTSEVFVCA9IFwiU1BSSVRFU0hFRVRcIixcbiAgICBBVURJTyA9IFwiQVVESU9cIixcbiAgICBKU09OID0gXCJKU09OXCIsXG4gICAgU0hBREVSID0gXCJTSEFERVJcIlxufVxuXG4vKipcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXG4gKi9cbmNsYXNzIEtleVBhdGhQYWlyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgaXNEZXBlbmRlbmN5PzogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5jbGFzcyBLZXlQYXRoX1NoYWRlciB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgdnBhdGg6IHN0cmluZztcbiAgICBmcGF0aDogc3RyaW5nO1xufSIsImltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IGludGVyZmFjZSBvZiBhIFNjZW5lR3JhcGguXG4gKiBFeHBvc2VzIG1ldGhvZHMgZm9yIHVzZSBieSBvdGhlciBjb2RlLCBidXQgbGVhdmVzIHRoZSBpbXBsZW1lbnRhdGlvbiB1cCB0byB0aGUgc3ViY2xhc3Nlcy5cbiAqIFRoZSBTY2VuZUdyYXBoIG1hbmFnZXMgdGhlIHBvc2l0aW9ucyBvZiBhbGwgR2FtZU5vZGVzLCBhbmQgY2FuIGVhc2lseSBwcnVuZSBhIHZpc2libGUgc2V0IGZvciByZW5kZXJpbmcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNjZW5lR3JhcGgge1xuXHQvKipcdEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCAqL1xuXHRwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXHQvKipcdEEgbWFwIG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuXHRwcm90ZWN0ZWQgbm9kZU1hcDogQXJyYXk8Q2FudmFzTm9kZT47XG5cdC8qKiBBIGNvdW50ZXIgb2YgSURzIGZvciBub2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvICovXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0XG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cblx0ICovXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5ub2RlTWFwID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xuICAgIH1cblxuXHQvKipcblx0ICogQWRkIGEgbm9kZSB0byB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byBhZGQgdG8gdGhlIFNjZW5lR3JhcGhcblx0ICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGggSUQgb2YgdGhpcyBuZXdseSBhZGRlZCBDYW52YXNOb2RlXG5cdCAqL1xuICAgIGFkZE5vZGUobm9kZTogQ2FudmFzTm9kZSk6IG51bWJlciB7XG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcblx0XHR0aGlzLmFkZE5vZGVTcGVjaWZpYyhub2RlLCB0aGlzLmlkQ291bnRlcik7XG5cdFx0dGhpcy5pZENvdW50ZXIgKz0gMTtcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIgLSAxO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBvdmVycmlkYWJsZSBtZXRob2QgdG8gYWRkIGEgQ2FudmFzTm9kZSB0byB0aGUgc3BlY2lmaWMgZGF0YSBzdHJ1Y3R1cmUgb2YgdGhlIFNjZW5lR3JhcGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoZSBkYXRhIHN0cnVjdHVyZVxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKi9cbiAgICByZW1vdmVOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcblx0XHQvLyBGaW5kIGFuZCByZW1vdmUgbm9kZSBpbiBPKG4pXG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVtb3ZlTm9kZVNwZWNpZmljKG5vZGUsIG5vZGUuaWQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgcmVtb3ZpbmcgYSBub2RlXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IHJlbW92ZU5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogR2V0IGEgc3BlY2lmaWMgbm9kZSB1c2luZyBpdHMgaWRcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgQ2FudmFzTm9kZSB0byByZXRyaWV2ZVxuXHQgKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoaXMgSURcblx0ICovXG5cdGdldE5vZGUoaWQ6IG51bWJlcik6IENhbnZhc05vZGUge1xuXHRcdHJldHVybiB0aGlzLm5vZGVNYXBbaWRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIGF0IHNwZWNpZmljIGNvb3JkaW5hdGVzXG5cdCAqIEBwYXJhbSB2ZWNPclggVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24sIG9yIHRoZSBjb29yZGluYXRlcyBpbiBhIFZlYzJcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb25cblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgZm91bmQgYXQgdGhlIHBvc2l0aW9uIHByb3ZpZGVkXG5cdCAqL1xuICAgIGdldE5vZGVzQXQodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgueCwgdmVjT3JYLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXROb2Rlc0F0Q29vcmRzKHZlY09yWCwgeSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIHRoYXQgb3ZlcmxhcCBhIHNwZWNpZmljIGJvdW5kYXJ5XG5cdCAqIEBwYXJhbSBib3VuZGFyeSBUaGUgcmVnaW9uIHRvIGNoZWNrXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIG92ZXJsYXBwaW5nIHRoZSBwcm92aWRlZCBib3VuZGFyeVxuXHQgKi9cblx0YWJzdHJhY3QgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEByZXR1cm5zIEFuIEFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqL1xuXHRnZXRBbGxOb2RlcygpOiBBcnJheTxDYW52YXNOb2RlPiB7XG5cdFx0bGV0IGFyciA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVNYXAubGVuZ3RoOyBpKyspe1xuXHRcdFx0aWYodGhpcy5ub2RlTWFwW2ldICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRhcnIucHVzaCh0aGlzLm5vZGVNYXBbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBnZXR0aW5nIGEgbm9kZSBhdCBjZXJ0YWluIGNvb3JkaW5hdGVzXG5cdCAqIEBwYXJhbSB4IFRoZSB4LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXG5cdCAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXG5cdCAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT47XG5cblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcblx0XG5cdGFic3RyYWN0IHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGJhc2VkIG9uIHRoZSBAcmVmZXJlbmNlW1ZpZXdwb3J0XVxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB2aXNpYmxlIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqL1xuICAgIGFic3RyYWN0IGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT47XG59IiwiaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4vU2NlbmVHcmFwaFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgU2NlbmVHcmFwaCB0aGF0IHNpbXBseSBzdG9yZWQgQ2FudmFzTm9kZXMgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lR3JhcGhBcnJheSBleHRlbmRzIFNjZW5lR3JhcGgge1xuICAgIC8qKiBUaGUgbGlzdCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cbiAgICBwcml2YXRlIG5vZGVMaXN0OiBBcnJheTxDYW52YXNOb2RlPjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaEFycmF5XG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydFxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSl7XG4gICAgICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZSk7XG5cbiAgICAgICAgdGhpcy5ub2RlTGlzdCA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLm5vZGVMaXN0LnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbW92ZU5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZUxpc3QuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYoaW5kZXggPiAtMSl7XG4gICAgICAgICAgICB0aGlzLm5vZGVMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKG5vZGUuY29udGFpbnMoeCwgeSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldE5vZGVzSW5SZWdpb24oYm91bmRhcnk6IEFBQkIpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKGJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpKXtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFN0YXRzLmxvZyhcInNncXVlcnlcIiwgKHQxLXQwKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XG4gICAgICAgICAgICBpZighbm9kZS5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFN0YXRzLmxvZyhcInNndXBkYXRlXCIsICh0MS10MCkpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge31cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNIaWRkZW4oKSAmJiBub2RlLnZpc2libGUgJiYgdGhpcy52aWV3cG9ydC5pbmNsdWRlcyhub2RlKSl7XG4gICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGVTZXQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XG5cbi8qKlxuICogVGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lLiBDb3JyZXNwb25kcyB0byB0aGUgdmlzaWJsZSB3aW5kb3cgZGlzcGxheWVkIGluIHRoZSBicm93c2VyLlxuICogVGhlIHZpZXdwb3J0IGtlZXBzIHRyYWNrIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCwgYW5kIGNhbiBhY3QgYXMgYSBjYW1lcmEgdG8gZm9sbG93IG9iamVjdHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgICAvKiogVGhlIEFBQkIgdGhhdCBjb250YWlucyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHZpZXdwb3J0IHZpZXcgKi9cbiAgICBwcml2YXRlIHZpZXc6IEFBQkI7XG4gICAgLyoqIFRoZSBib3VuZGFyeSBmb3IgdGhlIHZpZXdwb3J0LiBUaGlzIHJlcHJlc2VudHMgdGhlIGxpbWl0cyB0byB3aGVyZSB0aGUgdmlld3BvcnQgY2FuIGdvICovXG4gICAgcHJpdmF0ZSBib3VuZGFyeTogQUFCQjtcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoZSBWaWV3cG9ydCBpcyBmb2xsb3dpbmcgKi9cbiAgICBwcml2YXRlIGZvbGxvd2luZzogR2FtZU5vZGU7XG4gICAgLyoqIFRoZSBwb3NpdGlvbiB0aGUgR2FtZU5vZGUgaXMgZm9jdXNpbmcgb24uIFRoaXMgaXMgb3ZlcnJpZGRlbiBpZiBcImZvbGxvd2luZ1wiIGlzIHNldC4gKi9cbiAgICBwcml2YXRlIGZvY3VzOiBWZWMyO1xuXG4gICAgLyoqIEEgcXVldWUgb2YgcHJldmlvdXMgcG9zaXRpb25zIG9mIHdoYXQgdGhpcyB2aWV3cG9ydCBpcyBmb2xsb3dpbmcuIFVzZWQgZm9yIHNtb290aGluZyB2aWV3cG9ydCBtb3ZlbWVudCAqL1xuICAgIHByaXZhdGUgbGFzdFBvc2l0aW9uczogUXVldWU8VmVjMj47XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBwcmV2aW91cyBwb3NpdGlvbnMgdGhpcyB2aWV3cG9ydCB0cmFja3MgKi9cbiAgICBwcml2YXRlIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyO1xuXG4gICAgLyoqIEEgYm9vbGVhbiB0aGEgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHpvb20gYnkgc2Nyb2xsaW5nIHdpdGggdGhlIG1vdXNlIHdoZWVsICovXG4gICAgcHJpdmF0ZSBzY3JvbGxab29tRW5hYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgYW1vdW50IHRoYXQgaXMgem9vbWVkIGluIG9yIG91dC4gKi9cbiAgICBwcml2YXRlIFpPT01fRkFDVE9SOiBudW1iZXIgPSAxLjI7XG5cbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGNhbnZhcyAqL1xuICAgIHByaXZhdGUgY2FudmFzU2l6ZTogVmVjMjtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhc1NpemU6IFZlYzIsIHpvb21MZXZlbDogbnVtYmVyKXtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IEFBQkIoVmVjMi5aRVJPLCBWZWMyLlpFUk8pO1xuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gbmV3IEFBQkIoVmVjMi5aRVJPLCBWZWMyLlpFUk8pO1xuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSAxMDtcbiAgICAgICAgdGhpcy5zY3JvbGxab29tRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhc1NpemUgPSBWZWMyLlpFUk87XG4gICAgICAgIHRoaXMuZm9jdXMgPSBWZWMyLlpFUk87XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy5zZXRDYW52YXNTaXplKGNhbnZhc1NpemUpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgdGhpcy5zZXRTaXplKGNhbnZhc1NpemUpO1xuICAgICAgICB0aGlzLnNldFpvb21MZXZlbCh6b29tTGV2ZWwpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgY2VudGVyIChhbmQgbWFrZSB0aGUgdmlld3BvcnQgc3RheSB0aGVyZSlcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIodGhpcy52aWV3LmhhbGZTaXplLmNsb25lKCkpO1xuICAgICAgICB0aGlzLnNldEZvY3VzKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcbiAgICB9XG5cbiAgICAvKiogRW5hYmxlcyB0aGUgdmlld3BvcnQgdG8gem9vbSBpbiBhbmQgb3V0ICovXG4gICAgZW5hYmxlWm9vbSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY3JvbGxab29tRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXG4gICAgICovXG4gICAgZ2V0Q2VudGVyKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmNlbnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlYzIgd2l0aCB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSB0b3AgbGVmdCBjb3JuZGVyIG9mIHRoZSBWaWVwb3J0IGFzIGEgVmVjMlxuICAgICAqL1xuICAgIGdldE9yaWdpbigpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMudmlldy5sZWZ0LCB0aGlzLnZpZXcudG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGlzIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIEFBQkIgY29udGFpbmluZyB0aGUgcmVnaW9uIHZpc2libGUgdG8gdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgZ2V0VmlldygpOiBBQUJCIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyBwb3NpdGlvbiBvciB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRDZW50ZXIodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XG4gICAgICAgIGxldCBwb3M6IFZlYzI7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG4gICAgICAgICAgICBwb3MgPSB2ZWNPclg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IHBvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcbiAgICAgKiBAcmV0dXJucyBUaGUgaGFsZi1zaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyB3aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBzaXplIGFzIGEgVmVjMlxuICAgICAqIEBwYXJhbSB5IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldFNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUodmVjT3JYLnNjYWxlZCgxLzIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKG5ldyBWZWMyKHZlY09yWC8yLCB5LzIpKTtcblx0XHR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFsZi1zaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyBoYWxmLXdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IGhhbGYtc2l6ZSBhcyBhIFZlYzJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRIYWxmU2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguY2xvbmUoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgsIHkpKTtcblx0XHR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlld3BvcnQgd2l0aCB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCBDYW52YXNcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzLCBvciB0aGUgY2FudmFzIHNpemUgYXMgYSBWZWMyXG4gICAgICogQHBhcmFtIHkgVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXG4gICAgICovXG4gICAgc2V0Q2FudmFzU2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IHZlY09yWC5jbG9uZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgc2V0Wm9vbUxldmVsKHpvb206IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnZpZXcuaGFsZlNpemUuY29weSh0aGlzLmNhbnZhc1NpemUuc2NhbGVkKDEvem9vbS8yKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIGdldFpvb21MZXZlbCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNTaXplLngvdGhpcy52aWV3Lmh3LzJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnQgbW92ZW1lbnQuXG4gICAgICogQHBhcmFtIHNtb290aGluZ0ZhY3RvciBUaGUgc21vb3RoaW5nIGZhY3RvciBmb3IgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0U21vb3RoaW5nRmFjdG9yKHNtb290aGluZ0ZhY3RvcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmKHNtb290aGluZ0ZhY3RvciA8IDEpIHNtb290aGluZ0ZhY3RvciA9IDE7XG4gICAgICAgIHRoaXMuc21vb3RoaW5nRmFjdG9yID0gc21vb3RoaW5nRmFjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSB2aWV3cG9ydCB0byBmb2N1cyBvbiBhIHBvaW50LiBPdmVyaWRkZW4gYnkgXCJmb2xsb3dpbmdcIi5cbiAgICAgKiBAcGFyYW0gZm9jdXMgVGhlIHBvaW50IHRoZSAgdmlld3BvcnQgc2hvdWxkIGZvY3VzIG9uXG4gICAgICovXG4gICAgc2V0Rm9jdXMoZm9jdXM6IFZlYzIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1cy5jb3B5KGZvY3VzKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBDYW52YXNOb2RlIGlzIGluc2lkZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBpbmNsdWRlcyhub2RlOiBDYW52YXNOb2RlKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBwYXJhbGxheCA9IG5vZGUuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIgfHwgbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgVUlMYXllciA/ICg8UGFyYWxsYXhMYXllcj5ub2RlLmdldExheWVyKCkpLnBhcmFsbGF4IDogbmV3IFZlYzIoMSwgMSk7XG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXcuY2VudGVyLmNsb25lKCk7XG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIubXVsdChwYXJhbGxheCk7XG4gICAgICAgIGxldCBvdmVybGFwcyA9IHRoaXMudmlldy5vdmVybGFwcyhub2RlLmJvdW5kYXJ5KTtcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IGNlbnRlclxuICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XG4gICAgfVxuXG5cdC8vIFRPRE86IFB1dCBzb21lIGVycm9yIGhhbmRsaW5nIG9uIHRoaXMgZm9yIHRyeWluZyB0byBtYWtlIHRoZSBib3VuZHMgdG9vIHNtYWxsIGZvciB0aGUgdmlld3BvcnRcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIGF1dG9tYXRpY2FsbHksIG9yIHNob3VsZCBjb25zaWRlciB0aGUgYXNwZWN0IHJhdGlvIG9yIHNvbWV0aGluZ1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gbG93ZXJYIFRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIGxvd2VyWSBUaGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHVwcGVyWCBUaGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdXBwZXJZIFRoZSBib3R0b20gZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRCb3VuZHMobG93ZXJYOiBudW1iZXIsIGxvd2VyWTogbnVtYmVyLCB1cHBlclg6IG51bWJlciwgdXBwZXJZOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGh3aWR0aCA9ICh1cHBlclggLSBsb3dlclgpLzI7XG4gICAgICAgIGxldCBoaGVpZ2h0ID0gKHVwcGVyWSAtIGxvd2VyWSkvMjtcbiAgICAgICAgbGV0IHggPSBsb3dlclggKyBod2lkdGg7XG4gICAgICAgIGxldCB5ID0gbG93ZXJZICsgaGhlaWdodDtcbiAgICAgICAgdGhpcy5ib3VuZGFyeS5jZW50ZXIuc2V0KHgsIHkpO1xuICAgICAgICB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLnNldChod2lkdGgsIGhoZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIHZpZXdwb3J0IGZvbGxvdyB0aGUgc3BlY2lmaWVkIEdhbWVOb2RlXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlIHRvIGZvbGxvd1xuICAgICAqL1xuICAgIGZvbGxvdyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvbGxvd2luZyA9IG5vZGU7XG4gICAgfVxuXG4gICAgdXBkYXRlVmlldygpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSA+IHRoaXMuc21vb3RoaW5nRmFjdG9yKXtcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5kZXF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgYXZlcmFnZSBvZiB0aGUgbGFzdCAxMCBwb3NpdGlvbnNcbiAgICAgICAgbGV0IHBvcyA9IFZlYzIuWkVSTztcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zLmFkZChwb3NpdGlvbikpO1xuICAgICAgICBwb3Muc2NhbGUoMS90aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpKTtcblxuICAgICAgICAvLyBTZXQgdGhpcyBwb3NpdGlvbiBlaXRoZXIgdG8gdGhlIG9iamVjdCBvciB0byBpdHMgYm91bmRzXG4gICAgICAgIHBvcy54ID0gTWF0aFV0aWxzLmNsYW1wKHBvcy54LCB0aGlzLmJvdW5kYXJ5LmxlZnQgKyB0aGlzLnZpZXcuaHcsIHRoaXMuYm91bmRhcnkucmlnaHQgLSB0aGlzLnZpZXcuaHcpO1xuICAgICAgICBwb3MueSA9IE1hdGhVdGlscy5jbGFtcChwb3MueSwgdGhpcy5ib3VuZGFyeS50b3AgKyB0aGlzLnZpZXcuaGgsIHRoaXMuYm91bmRhcnkuYm90dG9tIC0gdGhpcy52aWV3LmhoKTtcblxuICAgICAgICAvLyBBc3N1cmUgdGhlcmUgYXJlIG5vIGxpbmVzIGluIHRoZSB0aWxlbWFwXG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCk7XG4gICAgICAgIHBvcy55ID0gTWF0aC5mbG9vcihwb3MueSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyLmNvcHkocG9zKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gSWYgem9vbSBpcyBlbmFibGVkXG4gICAgICAgIGlmKHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQpe1xuICAgICAgICAgICAgaWYoSW5wdXQuZGlkSnVzdFNjcm9sbCgpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmKElucHV0LmdldFNjcm9sbERpcmVjdGlvbigpIDwgMCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gaW5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUuc2NhbGUoMS90aGlzLlpPT01fRkFDVE9SKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBab29tIG91dFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSh0aGlzLlpPT01fRkFDVE9SKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS54ID4gdGhpcy5ib3VuZGFyeS5odyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWN0b3IgPSB0aGlzLmJvdW5kYXJ5Lmh3L2N1cnJlbnRTaXplLng7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggPSB0aGlzLmJvdW5kYXJ5Lmh3O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ICo9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS55ID4gdGhpcy5ib3VuZGFyeS5oaCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWN0b3IgPSB0aGlzLmJvdW5kYXJ5LmhoL2N1cnJlbnRTaXplLnk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgPSB0aGlzLmJvdW5kYXJ5LmhoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ICo9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0SGFsZlNpemUoY3VycmVudFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdmlld3BvcnQgaXMgZm9sbG93aW5nIGFuIG9iamVjdFxuICAgICAgICBpZih0aGlzLmZvbGxvd2luZyl7XG4gICAgICAgICAgICAvLyBVcGRhdGUgb3VyIGxpc3Qgb2YgcHJldmlvdXMgcG9zaXRpb25zXG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZW5xdWV1ZSh0aGlzLmZvbGxvd2luZy5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9jdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgfVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW0NhbnZhc05vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc05vZGVGYWN0b3J5IHtcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdGluaXQoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XG5cdCAqL1xuXHRhZGRVSUVsZW1lbnQgPSAodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50ID0+IHtcblx0XHQvLyBHZXQgdGhlIGxheWVyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXG5cdFx0bGV0IGluc3RhbmNlOiBVSUVsZW1lbnQ7XG5cblx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuQlVUVE9OOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRCdXR0b24ob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5MQUJFTDpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGFiZWwob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5TTElERVI6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFNsaWRlcihvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlRFWFRfSU5QVVQ6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFRleHRJbnB1dChvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgYFVJRWxlbWVudFR5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcblx0XHR9XG5cblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSlcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcblx0ICovXG5cdGFkZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUgPT4ge1xuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBTcHJpdGUoa2V5KTtcblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG5cblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXG5cdCAqL1xuXHRhZGRBbmltYXRlZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSA9PiB7XG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXHRcdGxldCBzcHJpdGVzaGVldCA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNwcml0ZXNoZWV0KGtleSk7XG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IEFuaW1hdGVkU3ByaXRlKHNwcml0ZXNoZWV0KTtcblxuXHRcdC8vIEFkZCBpbnN0YW5jZSBmbyBzY2VuZVxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG5cdFx0XG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBuZXcgZ3JhcGhpYyBlbGVtZW50IHRvIHRoZSBjdXJyZW50IFNjZW5lXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgZ3JhcGhpY1xuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgZ3JhcGhpYyBjb25zdHJ1Y3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXG5cdCAqL1xuXHRhZGRHcmFwaGljID0gKHR5cGU6IEdyYXBoaWNUeXBlIHwgc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHcmFwaGljID0+IHtcblx0XHQvLyBHZXQgdGhlIGxheWVyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXG5cdFx0bGV0IGluc3RhbmNlOiBHcmFwaGljO1xuXG5cdFx0c3dpdGNoKHR5cGUpe1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QT0lOVDpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUG9pbnQob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5MSU5FOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRMaW5lKG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUkVDVDpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUmVjdChvcHRpb25zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBgR3JhcGhpY1R5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLSBCVUlMREVSUyAtLS0tLS0tLS0tICovXG5cblx0YnVpbGRCdXR0b24ob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCdXR0b24ge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkJ1dHRvblwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XG5cblx0XHRyZXR1cm4gbmV3IEJ1dHRvbihvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpO1xuXHR9XG5cblx0YnVpbGRMYWJlbChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IExhYmVsIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGFiZWxcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcblxuXHRcdHJldHVybiBuZXcgTGFiZWwob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KVxuXHR9XG5cblx0YnVpbGRTbGlkZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNsaWRlciB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlNsaWRlclwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdGxldCBpbml0VmFsdWUgPSAwO1xuXHRcdGlmKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRpbml0VmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU2xpZGVyKG9wdGlvbnMucG9zaXRpb24sIGluaXRWYWx1ZSk7XG5cdH1cblxuXHRidWlsZFRleHRJbnB1dChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVGV4dElucHV0IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiVGV4dElucHV0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBUZXh0SW5wdXQob3B0aW9ucy5wb3NpdGlvbik7XG5cdH1cblxuXHRidWlsZFBvaW50KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQb2ludFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgUG9pbnQob3B0aW9ucy5wb3NpdGlvbik7XG5cdH1cblxuXHRidWlsZExpbmUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJzdGFydFwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJlbmRcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMaW5lKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcblx0fVxuXG5cdGJ1aWxkUmVjdChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY3Qge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFJlY3Qob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplKTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0gRVJST1IgSEFORExJTkcgLS0tLS0tLS0tLSAqL1xuXG5cdGNoZWNrSWZQcm9wRXhpc3RzPFQ+KG9iamVjdE5hbWU6IHN0cmluZywgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcDogc3RyaW5nLCB0eXBlOiAobmV3ICguLi5hcmdzOiBhbnkpID0+IFQpIHwgc3RyaW5nLCB0eXBlTmFtZT86IHN0cmluZyl7XG5cdFx0aWYoIW9wdGlvbnMgfHwgb3B0aW9uc1twcm9wXSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHlcblx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBub25lIHdhcyBwcm92aWRlZC5gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgdGhlIGNvcnJlY3QgdHlwZVxuXHRcdFx0aWYoKHR5cGVvZiB0eXBlKSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdGlmKCEodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09IHR5cGUpKXtcblx0XHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGV9LmA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZih0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuXHRcdFx0XHQvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxuXHRcdFx0XHRpZighKG9wdGlvbnNbcHJvcF0gaW5zdGFuY2VvZiB0eXBlKSl7XG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IHByb3ZpZGVkICR7cHJvcH0gd2FzIG5vdCBvZiB0eXBlICR7dHlwZU5hbWV9LmA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBDYW52YXNOb2RlRmFjdG9yeSBmcm9tIFwiLi9DYW52YXNOb2RlRmFjdG9yeVwiO1xuaW1wb3J0IFRpbGVtYXBGYWN0b3J5IGZyb20gXCIuL1RpbGVtYXBGYWN0b3J5XCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xuXG4vKipcbiAqIFRoZSBtYW5hZ2VyIG9mIGFsbCBmYWN0b3JpZXMgdXNlZCBmb3IgYWRkaW5nIEByZWZlcmVuY2VbR2FtZU5vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY3RvcnlNYW5hZ2VyIHtcblxuICAgIC8vIENvbnN0cnVjdG9ycyBhcmUgY2FsbGVkIGhlcmUgdG8gYWxsb3cgYXNzaWdubWVudCBvZiB0aGVpciBmdW5jdGlvbnMgdG8gZnVuY3Rpb25zIGluIHRoaXMgY2xhc3NcbiAgICBwcml2YXRlIGNhbnZhc05vZGVGYWN0b3J5OiBDYW52YXNOb2RlRmFjdG9yeSA9IG5ldyBDYW52YXNOb2RlRmFjdG9yeSgpO1xuICAgIHByaXZhdGUgdGlsZW1hcEZhY3Rvcnk6IFRpbGVtYXBGYWN0b3J5ID0gbmV3IFRpbGVtYXBGYWN0b3J5KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPil7XG4gICAgICAgIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuaW5pdChzY2VuZSk7XG4gICAgICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBhbGwgb2YgdGhlIGZhY3RvcmllcyB0aHJvdWdoIHRoZSBmYWN0b3J5IG1hbmFnZXJcbiAgICAvKipcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XG5cdCAqL1xuICAgIHVpRWxlbWVudCh0eXBlOiBzdHJpbmcgfCBVSUVsZW1lbnRUeXBlLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBVSUVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRVSUVsZW1lbnQodHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgU3ByaXRlXG5cdCAqL1xuXHRzcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcblx0ICovXG5cdGFuaW1hdGVkU3ByaXRlKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IEFuaW1hdGVkU3ByaXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkQW5pbWF0ZWRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xuXHQgKi9cblx0Z3JhcGhpYyh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEdyYXBoaWModHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVzaXJlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cbiAgICAgKi9cblx0dGlsZW1hcChrZXk6IHN0cmluZywgc2NhbGU/OiBWZWMyKTogQXJyYXk8TGF5ZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcEZhY3RvcnkuYWRkKGtleSwgc2NhbGUpO1xuICAgIH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkQ29sbGVjdGlvblRpbGUgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZtZXNoXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW1RpbGVtYXBdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBGYWN0b3J5IHtcbiAgICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcbiAgICBwcml2YXRlIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIFxuICAgIGluaXQoc2NlbmU6IFNjZW5lLCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbGVtYXBzID0gdGlsZW1hcHM7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIFRoaXMgaXMgc3BlY2lmaWNhbGx5IGNhdGVyZWQgdG8gVGlsZWQgdGlsZW1hcHMgcmlnaHQgbm93LiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGl0IHdvdWxkIGJlIGdvb2QgdG8gaGF2ZSBhIFwicGFyc2VUaWxlbWFwXCIgZnVuY3Rpb24gdGhhdCB3b3VsZCBjb252ZXJ0IHRoZSB0aWxlbWFwXG4gICAgLy8gZGF0YSBpbnRvIGEgc3RhbmRhcmQgZm9ybWF0LiBUaGlzIGNvdWxkIGFsbG93IGZvciBzdXBwb3J0IGZyb20gb3RoZXIgcHJvZ3JhbXNcbiAgICAvLyBvciB0aGUgZGV2ZWxvcG1lbnQgb2YgYW4gaW50ZXJuYWwgbGV2ZWwgYnVpbGRlciB0b29sXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBMYXllcnMsIGVhY2ggb2Ygd2hpY2ggY29udGFpbnMgYSBsYXllciBvZiB0aGUgdGlsZW1hcCBhcyBpdHMgb3duIFRpbGVtYXAgaW5zdGFuY2UuXG4gICAgICovXG5cdGFkZCA9IChrZXk6IHN0cmluZywgc2NhbGU6IFZlYzIgPSBuZXcgVmVjMigxLCAxKSk6IEFycmF5PExheWVyPiA9PiB7XG4gICAgICAgIC8vIEdldCBUaWxlbWFwIERhdGFcbiAgICAgICAgbGV0IHRpbGVtYXBEYXRhID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGlsZW1hcChrZXkpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgY29uc3RydWN0b3IgZm9yIHRoaXMgdGlsZW1hcCB0byBlaXRoZXIgYmUgb3J0aG9ncmFwaGljIG9yIGlzb21ldHJpY1xuICAgICAgICBsZXQgY29uc3RyOiBuZXcoLi4uYXJnczogYW55KSA9PiBUaWxlbWFwO1xuICAgICAgICBpZih0aWxlbWFwRGF0YS5vcmllbnRhdGlvbiA9PT0gXCJvcnRob2dyYXBoaWNcIil7XG4gICAgICAgICAgICBjb25zdHIgPSBPcnRob2dvbmFsVGlsZW1hcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGlzb21ldHJpYyB0aWxlbWFwIHN1cHBvcnQgcmlnaHQgbm93LCBzbyBPcnRob2dyYXBoaWMgdGlsZW1hcFxuICAgICAgICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZXR1cm4gdmFsdWUgYXJyYXlcbiAgICAgICAgbGV0IHNjZW5lTGF5ZXJzID0gbmV3IEFycmF5PExheWVyPigpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgb2YgdGhlIHRpbGVzZXRzIGZvciB0aGlzIHRpbGVtYXBcbiAgICAgICAgbGV0IHRpbGVzZXRzID0gbmV3IEFycmF5PFRpbGVzZXQ+KCk7XG5cbiAgICAgICAgbGV0IGNvbGxlY3Rpb25UaWxlcyA9IG5ldyBBcnJheTxUaWxlZENvbGxlY3Rpb25UaWxlPigpO1xuXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XG4gICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgdGlsZXNldCBhbmQgbm90IGEgY29sbGVjdGlvbiwgY3JlYXRlIGEgdGlsZXNldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlb3JldGljYWxseSBzb21lb25lIGNvdWxkIHdhbnQgdG8gdXNlIG9uZSBmb3IgYSBzdGFuZGFyZCB0aWxlbWFwLiBXZSBhcmUgYXNzdW1pbmcgZm9yIG5vd1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugb25seSB3YW50IHRvIHVzZSB0aGVtIGZvciBvYmplY3QgbGF5ZXJzXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGVzZXQudGlsZXMuZm9yRWFjaCh0aWxlID0+IHRpbGUuaWQgKz0gdGlsZXNldC5maXJzdGdpZCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgdGlsZW1hcCBhbmQgY3JlYXRlIHRpbGVkbGF5ZXJzIG9yIG9iamVjdCBsYXllcnNcbiAgICAgICAgZm9yKGxldCBsYXllciBvZiB0aWxlbWFwRGF0YS5sYXllcnMpe1xuXG4gICAgICAgICAgICBsZXQgc2NlbmVMYXllcjtcbiAgICAgICAgICAgIGxldCBpc1BhcmFsbGF4TGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvcC5uYW1lID09PSBcIlBhcmFsbGF4XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXJhbGxheExheWVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XG4gICAgICAgICAgICAgICAgc2NlbmVMYXllciA9IHRoaXMuc2NlbmUuYWRkUGFyYWxsYXhMYXllcihsYXllci5uYW1lLCBuZXcgVmVjMigxLCAxKSwgZGVwdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0aWxlbWFwIG9iamVjdCBmb3IgdGhlIGxheWVyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSBuZXcgY29uc3RyKHRpbGVtYXBEYXRhLCBsYXllciwgdGlsZXNldHMsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMucHVzaCh0aWxlbWFwKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGlsZW1hcCB3aXRoIHBoeXNpY3MgaWYgaXQncyBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xuICAgICAgICAgICAgICAgICAgICB0aWxlbWFwLmFkZFBoeXNpY3MoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGxldCBpc05hdm1lc2hQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmF2bWVzaE5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xuICAgICAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05hdm1lc2hQb2ludHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJuYW1lXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiZWRnZXNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNOYXZtZXNoUG9pbnRzKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBuZXcgUG9zaXRpb25HcmFwaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihvYmoueCwgb2JqLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgZWRnZSBvZiBlZGdlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMYXllciBpcyBhbiBvYmplY3QgbGF5ZXIsIHNvIGFkZCBlYWNoIG9iamVjdCBhcyBhIHNwcml0ZSB0byBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzUGh5c2ljcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1RyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyaWdnZXJHcm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYob2JqLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIG9iai5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGh5c2ljcyA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUcmlnZ2VyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJHcm91cFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkVudGVyXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVudGVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhpdCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBhIHRpbGUgZnJvbSBhIHRpbGVzZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRpbGVzZXQuaGFzVGlsZShvYmouZ2lkKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBhIHRpbGUgZnJvbSB0aGlzIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGlsZXNldC5nZXRJbWFnZU9mZnNldEZvclRpbGUob2JqLmdpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgc2l6ZS54LzIpKnNjYWxlLngsIChvYmoueSAtIHNpemUueS8yKSpzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0SW1hZ2VPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gYSB0aWxlc2V0LCBtdXN0IGNvcnJlc3BvbmQgdG8gYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlIG9mIGNvbGxlY3Rpb25UaWxlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqLmdpZCA9PT0gdGlsZS5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgdGlsZS5pbWFnZXdpZHRoLzIpKnNjYWxlLngsIChvYmoueSAtIHRpbGUuaW1hZ2VoZWlnaHQvMikqc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgc3ByaXRlLiBBc3NvY2lhdGUgaXQgd2l0aCBvdXIgcGh5c2ljcyBvYmplY3QgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgc3ByaXRlIGEgc3RhdGljIHBoeXNpY3Mgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWRkUGh5c2ljcyhzcHJpdGUuYm91bmRhcnkuY2xvbmUoKSwgVmVjMi5aRVJPLCBpc0NvbGxpZGFibGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzVHJpZ2dlciAmJiB0cmlnZ2VyR3JvdXAgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRUcmlnZ2VyKHRyaWdnZXJHcm91cCwgb25FbnRlciwgb25FeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG5cbi8qKlxuICogQSBsYXllciBpbiB0aGUgc2NlbmUuIExheWVycyBhcmUgdXNlZCBmb3Igc29ydGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgYnkgZGVwdGguXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIHtcbiAgICAvKiogVGhlIHNjZW5lIHRoaXMgbGF5ZXIgYmVsb25ncyB0byAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKiogV2hldGhlciB0aGlzIGxheWVyIGlzIHBhdXNlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBoaWRkZW4gZnJvbSBiZWluZyByZW5kZXJlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBnbG9iYWwgYWxwaGEgbGV2ZWwgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBHYW1lTm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGF5ZXIgc2hvdWxkIGJlIHlzb3J0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIGRlcHRoIG9mIHRoaXMgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzICovXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdGhlIGxheWVyIHRvXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMueVNvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIHRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIGdldE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXG4gICAgICogQHBhcmFtIHBhdXNlVmFsdWUgVHJ1ZSBpZiB0aGUgbGF5ZXIgc2hvdWxkIGJlIHBhdXNlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBwYXVzZVZhbHVlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBwYXVzZWRcbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gICAgICogQHBhcmFtIGFscGhhIFRoZSBuZXcgb3BhY2l0eSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAgICovXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmFscGhhID0gTWF0aFV0aWxzLmNsYW1wKGFscGhhLCAwLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XG4gICAgICovXG4gICAgZ2V0QWxwaGEoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5ZXIncyBoaWRkZW4gdmFsdWUuIElmIGhpZGRlbiwgYSBsYXllciB3aWxsIG5vdCBiZSByZW5kZXJlZCwgYnV0IHdpbGwgc3RpbGwgdXBkYXRlXG4gICAgICogQHBhcmFtIGhpZGRlbiBUaGUgaGlkZGVuIHZhbHVlIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIHNldEhpZGRlbihoaWRkZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBoaWRkZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNjZW5lIGlzIGhpZGRlbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgICB9XG5cbiAgICAvKiogUGF1c2VzIHRoaXMgc2NlbmUgYW5kIGhpZGVzIGl0ICovXG4gICAgZGlzYWJsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIFVucGF1c2VzIHRoaXMgbGF5ZXIgYW5kIG1ha2VzIGl0IHZpc2libGUgKi9cbiAgICBlbmFibGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc2NlbmUgd2lsbCB5U29ydCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBpZiBhbiBvYmplY3QgaXMgXCJoaWdoZXJcIiBpbiB0aGUgc2NlbmUsIGl0IHdpbGwgc29ydCBiZWhpbmQgb2JqZWN0cyB0aGF0IGFyZSBcImxvd2VyXCIuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIDMvNCB2aWV3IGdhbWVzLCBvciBzaW1pbGFyIHNpdHVhdGlvbnMsIHdoZXJlIHlvdSBzb21ldGltZXMgd2FudCB0byBiZSBpbiBmcm9udCBvZiBvYmplY3RzLFxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB5U29ydCBUcnVlIGlmIHlTb3J0aW5nIHNob3VsZCBiZSBhY3RpdmUsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMueVNvcnQgPSB5U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB5U29ydCBzdGF0dXMgb2YgdGhlIHNjZW5lXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGdldFlTb3J0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzLiBBIGxhcmdlciBudW1iZXIgbWVhbnMgdGhlIGxheWVyIHdpbGwgYmUgY2xvc2VyIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICovXG4gICAgc2V0RGVwdGgoZGVwdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMgVGhlIGRlcHRoXG4gICAgICovXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgdG8gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGFkZE5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnNldExheWVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gRmluZCBhbmQgcmVtb3ZlIHRoZSBub2RlXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihub2RlKTtcblxuICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGFsbCBHYW1lTm9kZXMgZnJvbSB0aGlzIGxheWVyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGdldEl0ZW1zKCk6IEFycmF5PEdhbWVOb2RlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgIH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgYSBMYXllciB0aGF0IGhhcyBhIHBhcmFsbGF4IHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSBwYXJhbGxheCBvZiB0aGUgTGF5ZXIgKi9cblx0cGFyYWxsYXg6IFZlYzI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBQYXJhbGxheExheWVyLlxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgUGFyYWxsYXhMYXllciB0b1xuXHQgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgUGFyYWxsYXhMYXllclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIpe1xuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcblx0XHR0aGlzLnBhcmFsbGF4ID0gcGFyYWxsYXg7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL1BhcmFsbGF4TGF5ZXJcIjtcblxuLyoqXG4gKiBBIExheWVyIHN0cmljdGx5IHRvIGJlIHVzZWQgZm9yIG1hbmFnaW5nIFVJRWxlbWVudHMuXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXG4gKiBhbmQgdGh1cyByZW5kZXJzIHRoaW5ncyBsaWtlIGEgSFVEIG9yIGFuIGludmVudG9yeSB3aXRob3V0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIFxccmVmZXJlbmNlW1ZpZXdwb3J0XSBzY3JvbGwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVUlMYXllci5cblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRvIGFkZCB0aGlzIFVJTGF5ZXIgdG9cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFVJTGF5ZXJcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nKXtcblx0XHRzdXBlcihzY2VuZSwgbmFtZSwgVmVjMi5aRVJPKTtcblx0fVxufSIsImltcG9ydCBMYXllciBmcm9tIFwiLi9MYXllclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZUdyYXBoIGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lR3JhcGhBcnJheSBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoQXJyYXlcIjtcbmltcG9ydCBGYWN0b3J5TWFuYWdlciBmcm9tIFwiLi9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXJcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgR2FtZSBmcm9tIFwiLi4vTG9vcC9HYW1lXCI7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBOYXZpZ2F0aW9uTWFuYWdlciBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXJcIjtcbmltcG9ydCBBSU1hbmFnZXIgZnJvbSBcIi4uL0FJL0FJTWFuYWdlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuL0xheWVycy9VSUxheWVyXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IFNjZW5lT3B0aW9ucyBmcm9tIFwiLi9TY2VuZU9wdGlvbnNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi4vVGltaW5nL1RpbWVyTWFuYWdlclwiO1xuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XG5cbi8qKlxuICogU2NlbmVzIGFyZSB0aGUgbWFpbiBjb250YWluZXIgaW4gdGhlIGdhbWUgZW5naW5lLlxuICogWW91ciBtYWluIHNjZW5lIGlzIHRoZSBjdXJyZW50IGxldmVsIG9yIG1lbnUgb2YgdGhlIGdhbWUsIGFuZCB3aWxsIGNvbnRhaW4gYWxsIG9mIHRoZSBHYW1lTm9kZXMgbmVlZGVkLlxuICogU2NlbmVzIHByb3ZpZGUgYW4gZWFzeSB3YXkgdG8gbG9hZCBhc3NldHMsIGFkZCBhc3NldHMgdG8gdGhlIGdhbWUgd29ybGQsIGFuZCB1bmxvYWQgYXNzZXRzLFxuICogYW5kIGhhdmUgbGlmZWN5Y2xlIG1ldGhvZHMgZXhwb3NlZCBmb3IgdGhlc2UgZnVuY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZ2FtZSB3b3JsZC4gKi9cbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xuXG4gICAgLyoqIFRoZSB2aWV3cG9ydC4gKi9cbiAgICBwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXG4gICAgLyoqIEEgZmxhZyB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHNjZW5lIGlzIHJ1bm5pbmcgb3Igbm90LiAqL1xuICAgIHByb3RlY3RlZCBydW5uaW5nOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSByZWNlaXZlciBmb3IgdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXG4gICAgLyoqIFRoZSBlbWl0dGVyIGZvciB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuXG4gICAgLyoqIFRoaXMgbGlzdCBvZiB0aWxlbWFwcyBpbiB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XG5cbiAgICAvKiogQSBtYXAgZnJvbSBsYXllciBuYW1lcyB0byB0aGUgbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgbGF5ZXJzOiBNYXA8TGF5ZXI+O1xuXG4gICAgLyoqIEEgbWFwIGZyb20gcGFyYWxsYXggbGF5ZXIgbmFtZXMgdG8gdGhlIHBhcmFsbGF4IGxheWVycyB0aGVtc2VsdmVzICovXG4gICAgcHJvdGVjdGVkIHBhcmFsbGF4TGF5ZXJzOiBNYXA8UGFyYWxsYXhMYXllcj47XG5cbiAgICAvKiogQSBtYXAgZnJvbSB1aUxheWVyIG5hbWVzIHRvIHRoZSB1aUxheWVycyB0aGVtc2VsdmVzICovXG4gICAgcHJvdGVjdGVkIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj47XG5cbiAgICAvKiogVGhlIHNjZW5lIGdyYXBoIG9mIHRoZSBTY2VuZSovXG4gICAgcHJvdGVjdGVkIHNjZW5lR3JhcGg6IFNjZW5lR3JhcGg7XG5cbiAgICAvKiogVGhlIHBoeXNpY3MgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgcGh5c2ljc01hbmFnZXI6IFBoeXNpY3NNYW5hZ2VyO1xuICAgIFxuICAgIC8qKiBUaGUgbmF2aWdhdGlvbiBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBuYXZNYW5hZ2VyOiBOYXZpZ2F0aW9uTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgQUkgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgYWlNYW5hZ2VyOiBBSU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIHNjZW5lICovXG4gICAgcHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBhZGRpbmcgb2YgZGlmZmVyZW50IG5vZGVzIHRvIHRoZSBzY2VuZSAqL1xuICAgIHB1YmxpYyBhZGQ6IEZhY3RvcnlNYW5hZ2VyO1xuXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUuIEFuIGFsaWFzIGZvciByZXNvdXJjZU1hbmFnZXIgKi9cbiAgICBwdWJsaWMgbG9hZDogUmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZSAqL1xuICAgIHB1YmxpYyByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHNjZW5lICovXG4gICAgcHVibGljIHNjZW5lT3B0aW9uczogU2NlbmVPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZS4gVG8gYWRkIGEgbmV3IFNjZW5lIGluIHlvdXIgZ2FtZSwgdXNlIGNoYW5nZVRvU2NlbmUoKSBpbiBAcmVmZXJlbmNlW1NjZW5lTWFuYWdlcl1cbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIHNjZW5lTWFuYWdlciBUaGUgU2NlbmVNYW5hZ2VyIHRoYXQgb3ducyB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgdGhhdCB3aWxsIGhhbmRsZSB0aGlzIFNjZW5lJ3MgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIGdhbWUgVGhlIGluc3RhbmNlIG9mIHRoZSBHYW1lXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIFNjZW5lIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XG4gICAgICAgIHRoaXMuc2NlbmVPcHRpb25zID0gU2NlbmVPcHRpb25zLnBhcnNlKG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMig1MDAsIDUwMCk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgMjU2MCwgMTI4MCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IHNjZW5lTWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoID0gbmV3IFNjZW5lR3JhcGhBcnJheSh0aGlzLnZpZXdwb3J0LCB0aGlzKTtcblxuICAgICAgICB0aGlzLmxheWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy51aUxheWVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyID0gbmV3IEJhc2ljUGh5c2ljc01hbmFnZXIodGhpcy5zY2VuZU9wdGlvbnMucGh5c2ljcyk7XG4gICAgICAgIHRoaXMubmF2TWFuYWdlciA9IG5ldyBOYXZpZ2F0aW9uTWFuYWdlcigpO1xuICAgICAgICB0aGlzLmFpTWFuYWdlciA9IG5ldyBBSU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gcmVuZGVyaW5nTWFuYWdlcjtcblxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBGYWN0b3J5TWFuYWdlcih0aGlzLCB0aGlzLnRpbGVtYXBzKTtcblxuICAgICAgICB0aGlzLmxvYWQgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHRoaXMubG9hZDtcblxuICAgICAgICAvLyBHZXQgdGhlIHRpbWVyIG1hbmFnZXIgYW5kIGNsZWFyIGFueSBleGlzdGluZyB0aW1lcnNcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuY2xlYXJUaW1lcnMoKTtcbiAgICB9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBuZXcgc2NlbmUgaXMgY3JlYXRlZCwgYmVmb3JlIGFueXRoaW5nIGVsc2UuICovXG4gICAgaW5pdFNjZW5lKGluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLiBMb2FkIGFsbCBmaWxlcyB5b3Ugd2lzaCB0byBhY2Nlc3MgaW4gdGhlIHNjZW5lIGhlcmUuICovXG4gICAgbG9hZFNjZW5lKCk6IHZvaWQge31cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIHN0cmljdGx5IGFmdGVyIGxvYWRTY2VuZSgpLiBDcmVhdGUgYW55IGdhbWUgb2JqZWN0cyB5b3Ugd2lzaCB0byB1c2UgaW4gdGhlIHNjZW5lIGhlcmUuICovXG4gICAgc3RhcnRTY2VuZSgpOiB2b2lkIHt9XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIGV2ZXJ5IGZyYW1lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHdoZXJlIHlvdSBjYW4gZHluYW1pY2FsbHkgZG8gdGhpbmdzIGxpa2UgYWRkIGluIG5ldyBlbmVtaWVzXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHRoaXMgZnJhbWUgcmVwcmVzZW50c1xuICAgICAqL1xuICAgIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIHNjZW5lIGRlc3RydWN0aW9uLiBTcGVjaWZ5IHdoaWNoIGZpbGVzIHlvdSBubyBsb25nZXIgbmVlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiAqL1xuICAgIHVubG9hZFNjZW5lKCk6IHZvaWQge31cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZVNjZW5lKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gRG8gdGltZSB1cGRhdGVzXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIERvIGFsbCBBSSB1cGRhdGVzXG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgcGh5c2ljcyBvYmplY3RzXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBjYW52YXMgb2JqZWN0c1xuICAgICAgICB0aGlzLnNjZW5lR3JhcGgudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0aWxlbWFwc1xuICAgICAgICB0aGlzLnRpbGVtYXBzLmZvckVhY2godGlsZW1hcCA9PiB7XG4gICAgICAgICAgICBpZighdGlsZW1hcC5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xuICAgICAgICAgICAgICAgIHRpbGVtYXAudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgdHdlZW5zXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHJlbmRlcmFibGUgc2V0cyBhbmQgY29vcmRpbmF0ZXMgd2l0aCB0aGUgUmVuZGVyaW5nTWFuYWdlciB0byBkcmF3IHRoZSBTY2VuZVxuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIHNldCBvZiBub2Rlc1xuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IHRoaXMuc2NlbmVHcmFwaC5nZXRWaXNpYmxlU2V0KCk7XG5cbiAgICAgICAgLy8gQWRkIHBhcmFsbGF4IGxheWVyIGl0ZW1zIHRvIHRoZSB2aXNpYmxlIHNldCAod2UncmUgcmVuZGVyaW5nIHRoZW0gYWxsIGZvciBub3cpXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHBMYXllciA9IHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBmb3IobGV0IG5vZGUgb2YgcExheWVyLmdldEl0ZW1zKCkpe1xuICAgICAgICAgICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgdmlzaWJsZSBzZXQsIHRpbGVtYXBzLCBhbmQgdWlMYXllcnMgdG8gdGhlIHJlbmRlcmVyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XG5cbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHRpbGVtYXAudmlzaWJsZSA/IG5vZGVzLnB1c2godGlsZW1hcCkgOiAwKTtcbiAgICAgICAgRGVidWcuc2V0Tm9kZXMobm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIGFzIHJ1bm5pbmcgb3Igbm90XG4gICAgICogQHBhcmFtIHJ1bm5pbmcgVHJ1ZSBpZiB0aGUgU2NlbmUgc2hvdWxkIGJlIHJ1bm5pbmcsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFJ1bm5pbmcocnVubmluZzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBydW5uaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIFNjZW5lIGlzIHJ1bm5pbmdcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBzY2VuZSBncmFwaFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGgucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3lzIHRoaXMgc2NlbmUgYW5kIGFsbCBub2RlcyBpbiBpdCAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLnNjZW5lR3JhcGguZ2V0QWxsTm9kZXMoKSl7XG4gICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcbiAgICAgICAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVHcmFwaDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc01hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hdk1hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFpTWFuYWdlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjZWl2ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBsYXllciB0byB0aGUgc2NlbmUgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGxheWVyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBMYXllclxuICAgICAqL1xuICAgIGFkZExheWVyKG5hbWU6IHN0cmluZywgZGVwdGg/OiBudW1iZXIpOiBMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IExheWVyKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMubGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgaWYoZGVwdGgpe1xuICAgICAgICAgICAgbGF5ZXIuc2V0RGVwdGgoZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgcGFyYWxsYXggbGF5ZXIgdG8gdGhpcyBzY2VuZSBhbmQgcmV0dXJucyBpdFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbGxheCBsYXllclxuICAgICAqIEBwYXJhbSBwYXJhbGxheCBUaGUgcGFyYWxsYXggbGV2ZWxcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFBhcmFsbGF4TGF5ZXJcbiAgICAgKi9cbiAgICBhZGRQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIsIGRlcHRoPzogbnVtYmVyKTogUGFyYWxsYXhMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IFBhcmFsbGF4TGF5ZXIodGhpcywgbmFtZSwgcGFyYWxsYXgpO1xuXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcblxuICAgICAgICBpZihkZXB0aCl7XG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBVSUxheWVyIHRvIHRoZSBzY2VuZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgVUlsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFVJTGF5ZXJcbiAgICAgKi9cbiAgICBhZGRVSUxheWVyKG5hbWU6IHN0cmluZyk6IFVJTGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBVSUxheWVyKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMudWlMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxheWVyIGZyb20gdGhlIHNjZW5lIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICAgICAqIFRoaXMgY2FuIGJlIGEgTGF5ZXIgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIExheWVyIGZvdW5kIHdpdGggdGhhdCBuYW1lXG4gICAgICovXG4gICAgZ2V0TGF5ZXIobmFtZTogc3RyaW5nKTogTGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGBSZXF1ZXN0ZWQgbGF5ZXIgJHtuYW1lfSBkb2VzIG5vdCBleGlzdC5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBQYXJhbGxheExheWVyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxuICAgICAqL1xuICAgIGlzUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgVUlMYXllclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBQYXJhbGxheExheWVyXG4gICAgICovXG4gICAgaXNVSUxheWVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5oYXMobmFtZSk7XG4gICAgfSAgICBcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIHJlc3BlY3QgdG8gY2FtZXJhIHNwYWNlIChkdWUgdG8gdGhlIHZpZXdwb3J0IG1vdmluZykuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBhZmZlY3RlZCBieSB0aGUgcGFyYWxsYXggbGV2ZWwgb2YgdGhlIEByZWZlcmVuY2VbTGF5ZXJdIHRoZSBub2RlIGlzIG9uLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIHRoZSB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdHJhbnNsYXRpb24gb2Ygdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRWaWV3VHJhbnNsYXRpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcbiAgICAgICAgbGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuXG4gICAgICAgIGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBsYXllciBpbnN0YW5jZW9mIFVJTGF5ZXIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCkubXVsdChsYXllci5wYXJhbGxheCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKTtcbiAgICAgICAgfVxuXHR9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBsZXZlbCBvZiB0aGUgdmlld1xuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICovXG5cdGdldFZpZXdTY2FsZSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWaWV3cG9ydCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IFZpZXdwb3J0XG4gICAgICovXG4gICAgZ2V0Vmlld3BvcnQoKTogVmlld3BvcnQge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBzaXplIG9mIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgc2l6ZSBpbiBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRXb3JsZFNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTY2VuZUdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGhcbiAgICAgKi9cbiAgICBnZXRTY2VuZUdyYXBoKCk6IFNjZW5lR3JhcGgge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZUdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFBoeXNpY3NNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIFBoeXNpY3NNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0UGh5c2ljc01hbmFnZXIoKTogUGh5c2ljc01hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5waHlzaWNzTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBOYXZpZ2F0aW9uTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBOYXZpZ2F0aW9uTWFuYWdlclxuICAgICAqL1xuICAgIGdldE5hdmlnYXRpb25NYW5hZ2VyKCk6IE5hdmlnYXRpb25NYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2TWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBSU1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgQUlNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0QUlNYW5hZ2VyKCk6IEFJTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmFpTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSUQgZm9yIGEgR2FtZU5vZGVcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IElEXG4gICAgICovXG4gICAgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXIuZ2VuZXJhdGVJZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIFRpbGVtYXAgaW4gdGhpcyBTY2VuZVxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBUaWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIFRpbGVtYXAsIGlmIG9uZSB0aGlzIG5hbWUgZXhpc3RzLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIGdldFRpbGVtYXAobmFtZTogc3RyaW5nKTogVGlsZW1hcCB7XG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzIC50aWxlbWFwcyl7XG4gICAgICAgICAgICBpZih0aWxlbWFwLm5hbWUgPT09IG5hbWUpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBNZW1vcnlVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWVtb3J5VXRpbHNcIjtcblxuLyoqXG4gKiBUaGUgU2NlbmVNYW5hZ2VyIGFjdHMgYXMgYW4gaW50ZXJmYWNlIHRvIGNyZWF0ZSBTY2VuZXMsIGFuZCBoYW5kbGVzIHRoZSBsaWZlY3ljbGUgbWV0aG9kcyBvZiBTY2VuZXMuXG4gKiBJdCBnaXZlcyBTY2VuZXMgYWNjZXNzIHRvIGluZm9ybWF0aW9uIHRoZXkgbmVlZCBmcm9tIHRoZSBAcmVmZXJlbmNlW0dhbWVdIGNsYXNzIHdoaWxlIGtlZXBpbmcgYSBsYXllciBvZiBzZXBhcmF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU1hbmFnZXIge1xuXHQvKiogVGhlIGN1cnJlbnQgU2NlbmUgb2YgdGhlIGdhbWUgKi9cblx0cHJvdGVjdGVkIGN1cnJlbnRTY2VuZTogU2NlbmU7XG5cblx0LyoqIFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZSAqL1xuXHRwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuXHQvKiogQSBjb3VudGVyIHRvIGtlZXAgdHJhY2sgb2YgZ2FtZSBpZHMgKi9cblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xuXG5cdC8qKiBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZSAqL1xuXHRwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcblxuXHQvKiogRm9yIGNvbnNpc3RlbmN5LCBvbmx5IGNoYW5nZSBzY2VuZXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdXBkYXRlIGN5Y2xlICovXG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmU6IFNjZW5lO1xuXHRwcm90ZWN0ZWQgcGVuZGluZ1NjZW5lSW5pdDogUmVjb3JkPHN0cmluZywgYW55PjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZU1hbmFnZXJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZVxuXHQgKiBAcGFyYW0gZ2FtZSBUaGUgR2FtZSBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZVxuXHQgKi9cblx0Y29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyKXtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xuXHRcdHRoaXMuaWRDb3VudGVyID0gMDtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgc2NlbmUgYXMgdGhlIG1haW4gc2NlbmUuXG5cdCAqIFVzZSB0aGlzIG1ldGhvZCBpZiB5b3UndmUgY3JlYXRlZCBhIHN1YmNsYXNzIG9mIFNjZW5lLCBhbmQgeW91IHdhbnQgdG8gYWRkIGl0IGFzIHRoZSBtYWluIFNjZW5lLlxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2NlbmUgdG8gYWRkXG5cdCAqIEBwYXJhbSBpbml0IEFuIG9iamVjdCB0byBwYXNzIHRvIHRoZSBpbml0IGZ1bmN0aW9uIG9mIHRoZSBuZXcgc2NlbmVcblx0ICovXG5cdHB1YmxpYyBjaGFuZ2VUb1NjZW5lPFQgZXh0ZW5kcyBTY2VuZT4oY29uc3RyOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCwgaW5pdD86IFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0Y29uc29sZS5sb2coXCJDcmVhdGluZyB0aGUgbmV3IHNjZW5lIC0gY2hhbmdlIGlzIHBlbmRpbmcgdW50aWwgbmV4dCB1cGRhdGVcIik7XG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBuZXcgY29uc3RyKHRoaXMudmlld3BvcnQsIHRoaXMsIHRoaXMucmVuZGVyaW5nTWFuYWdlciwgb3B0aW9ucyk7XG5cdFx0dGhpcy5wZW5kaW5nU2NlbmVJbml0ID0gaW5pdDtcblx0fVxuXG5cdHByb3RlY3RlZCBkb1NjZW5lQ2hhbmdlKCl7XG5cdFx0Y29uc29sZS5sb2coXCJQZXJmb3JtaW5nIHNjZW5lIGNoYW5nZVwiKTtcblx0XHR0aGlzLnZpZXdwb3J0LnNldENlbnRlcih0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueCwgdGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLnkpO1xuXHRcdFxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiVW5sb2FkaW5nIG9sZCBzY2VuZVwiKVxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudW5sb2FkU2NlbmUoKTtcblxuXHRcdFx0Y29uc29sZS5sb2coXCJEZXN0cm95aW5nIG9sZCBzY2VuZVwiKTtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgcmVzb3VyY2VzLi4uXCIpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVubG9hZEFsbFJlc291cmNlcygpO1xuXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSB0aGUgY3VycmVudCBvbmVcblx0XHR0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMucGVuZGluZ1NjZW5lO1xuXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSBudWxsXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xuXG5cdFx0Ly8gSW5pdCB0aGUgc2NlbmVcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5pbml0U2NlbmUodGhpcy5wZW5kaW5nU2NlbmVJbml0KTtcblxuXHRcdC8vIEVucXVldWUgYWxsIHNjZW5lIGFzc2V0IGxvYWRzXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUubG9hZFNjZW5lKCk7XG5cblx0XHQvLyBMb2FkIGFsbCBhc3NldHNcblx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lIExvYWRcIik7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIubG9hZFJlc291cmNlc0Zyb21RdWV1ZSgoKSA9PiB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lXCIpO1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc3RhcnRTY2VuZSgpO1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc2V0UnVubmluZyh0cnVlKTtcblx0XHR9KTtcblxuXHRcdHRoaXMucmVuZGVyaW5nTWFuYWdlci5zZXRTY2VuZSh0aGlzLmN1cnJlbnRTY2VuZSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSURcblx0ICogQHJldHVybnMgQSBuZXcgSURcblx0ICovXG5cdHB1YmxpYyBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuaWRDb3VudGVyKys7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgY3VycmVudCBTY2VuZVxuXHQgKi9cblx0cHVibGljIHJlbmRlcigpOiB2b2lkIHtcblx0XHRpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5yZW5kZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY3VycmVudCBTY2VuZVxuXHQgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgU2NlbmVcblx0ICovXG5cdHB1YmxpYyB1cGRhdGUoZGVsdGFUOiBudW1iZXIpe1xuXHRcdGlmKHRoaXMucGVuZGluZ1NjZW5lICE9PSBudWxsKXtcblx0XHRcdHRoaXMuZG9TY2VuZUNoYW5nZSgpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmlzUnVubmluZygpKXtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVwZGF0ZShkZWx0YVQpO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBBcnJheVV0aWxzIGZyb20gXCIuLi9VdGlscy9BcnJheVV0aWxzXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogVGhlIG9wdGlvbnMgdG8gZ2l2ZSBhIEByZWZlcmVuY2VbU2NlbmVdIGZvciBpbml0aWFsaXphdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU9wdGlvbnMge1xuICAgIHBoeXNpY3M6IHtcbiAgICAgICAgZ3JvdXBzOiBBcnJheTxzdHJpbmc+LFxuICAgICAgICBjb2xsaXNpb25zOiBBcnJheTxBcnJheTxudW1iZXI+PjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNjZW5lT3B0aW9uc3tcbiAgICAgICAgbGV0IHNPcHQgPSBuZXcgU2NlbmVPcHRpb25zKCk7XG5cbiAgICAgICAgaWYob3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgc09wdC5waHlzaWNzID0ge2dyb3VwczogdW5kZWZpbmVkLCBjb2xsaXNpb25zOiB1bmRlZmluZWR9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc09wdC5waHlzaWNzID0gb3B0aW9ucy5waHlzaWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNPcHQ7XG4gICAgfVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XG5cbi8qKlxuICogTWFuYWdlcyBhbnkgc291bmRzIG9yIG11c2ljIG5lZWRlZCBmb3IgdGhlIGdhbWUuXG4gKiBUaHJvdWdoIHRoZSBFdmVudFF1ZXVlLCBleHBvc2VzIGludGVyZmFjZSB0byBwbGF5IHNvdW5kcyBzbyBHYW1lTm9kZXMgY2FuIGFjdGl2YXRlIHNvdW5kcyB3aXRob3V0XG4gKiBuZWVkaW5nIGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBhdWRpbyBzeXN0ZW1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9NYW5hZ2VyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogQXVkaW9NYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBldmVudCByZWNlaXZlciBvZiB0aGlzIEF1ZGlvTWFuYWdlciAqL1xuICAgIHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXG4gICAgLyoqIEEgTWFwIG9mIHRoZSBuYW1lcyBvZiBjdXJyZW50bHkgcGxheWluZyAob3IgcGF1c2VkKSBzb3VuZHMgdG8gdGhlaXIgQXVkaW9CdWZmZXJzICovXG4gICAgcHJpdmF0ZSBjdXJyZW50U291bmRzOiBNYXA8QXVkaW9CdWZmZXJTb3VyY2VOb2RlPjtcblxuICAgIHByaXZhdGUgYXVkaW9DdHg6IEF1ZGlvQ29udGV4dDtcblxuICAgIHByaXZhdGUgZ2Fpbk5vZGVzOiBBcnJheTxHYWluTm9kZT47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuaW5pdEF1ZGlvKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoW1xuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX1NPVU5ELFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5TVE9QX1NPVU5ELFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDLFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMLFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U291bmRzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzID0gbmV3IEFycmF5PEdhaW5Ob2RlPihNQVhfQVVESU9fQ0hBTk5FTFMpO1xuICAgICAgICB0aGlzLmluaXRHYWluTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoZSBBdWRpb01hbmFnZXIgY2xhc3Mgb3IgY3JlYXRlIGEgbmV3IG9uZSBpZiBub25lIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIFRoZSBBdWRpb01hbmFnZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEF1ZGlvTWFuYWdlciB7XG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQXVkaW9NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHdlYkF1ZGlvIGNvbnRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRBdWRpbygpOiB2b2lkIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0Oy8vIHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7IFxuICAgICAgICAgICAgdGhpcy5hdWRpb0N0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTsgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2ViIEF1ZGlvIEFQSSBzdWNjZXNzZnVsbHkgbG9hZGVkJyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWIgQXVkaW8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7IFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0R2Fpbk5vZGVzKCk6IHZvaWQge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgTUFYX0FVRElPX0NIQU5ORUxTOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5nYWluTm9kZXNbaV0gPSB0aGlzLmF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXVkaW8gY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoZSBBdWRpb0NvbnRleHRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXVkaW9Db250ZXh0KCk6IEF1ZGlvQ29udGV4dCB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvQ3R4O1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgIEFjY29yZGluZyB0byB0aGUgTUROLCBjcmVhdGUgYSBuZXcgc291bmQgZm9yIGV2ZXJ5IGNhbGw6XG5cbiAgICAgICAgQW4gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGNhbiBvbmx5IGJlIHBsYXllZCBvbmNlOyBhZnRlciBlYWNoIGNhbGwgdG8gc3RhcnQoKSwgeW91IGhhdmUgdG8gY3JlYXRlIGEgbmV3IG5vZGVcbiAgICAgICAgaWYgeW91IHdhbnQgdG8gcGxheSB0aGUgc2FtZSBzb3VuZCBhZ2Fpbi4gRm9ydHVuYXRlbHksIHRoZXNlIG5vZGVzIGFyZSB2ZXJ5IGluZXhwZW5zaXZlIHRvIGNyZWF0ZSwgYW5kIHRoZVxuICAgICAgICBhY3R1YWwgQXVkaW9CdWZmZXJzIGNhbiBiZSByZXVzZWQgZm9yIG11bHRpcGxlIHBsYXlzIG9mIHRoZSBzb3VuZC4gSW5kZWVkLCB5b3UgY2FuIHVzZSB0aGVzZSBub2RlcyBpbiBhXG4gICAgICAgIFwiZmlyZSBhbmQgZm9yZ2V0XCIgbWFubmVyOiBjcmVhdGUgdGhlIG5vZGUsIGNhbGwgc3RhcnQoKSB0byBiZWdpbiBwbGF5aW5nIHRoZSBzb3VuZCwgYW5kIGRvbid0IGV2ZW4gYm90aGVyIHRvXG4gICAgICAgIGhvbGQgYSByZWZlcmVuY2UgdG8gaXQuIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBnYXJiYWdlLWNvbGxlY3RlZCBhdCBhbiBhcHByb3ByaWF0ZSB0aW1lLCB3aGljaCB3b24ndCBiZVxuICAgICAgICB1bnRpbCBzb21ldGltZSBhZnRlciB0aGUgc291bmQgaGFzIGZpbmlzaGVkIHBsYXlpbmcuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNvdW5kIGZyb20gdGhlIGtleSBvZiBhIGxvYWRlZCBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgYXVkaW8gZmlsZSB0byBjcmVhdGUgYSBuZXcgc291bmQgZm9yXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgQXVkaW9CdWZmZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlU291bmQoa2V5OiBzdHJpbmcsIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4sIGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIG9wdGlvbnM6IE1hcDxhbnk+KTogQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHtcbiAgICAgICAgLy8gR2V0IGF1ZGlvIGJ1ZmZlclxuICAgICAgICBsZXQgYnVmZmVyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW8oa2V5KTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzb3VuZCBzb3VyY2VcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlQnVmZmVyU291cmNlKCk7IFxuICAgICAgXG4gICAgICAgIC8vIFRlbGwgdGhlIHNvdXJjZSB3aGljaCBzb3VuZCB0byBwbGF5XG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7ICAgICAgICAgICAgICAgXG4gICAgICBcbiAgICAgICAgLy8gQWRkIGFueSBhZGRpdGlvbmFsIG5vZGVzXG4gICAgICAgIGNvbnN0IG5vZGVzOiBBcnJheTxBdWRpb05vZGU+ID0gW3NvdXJjZV07XG5cbiAgICAgICAgLy8gRG8gYW55IGFkZGl0aW9uYWwgbm9kZXMgaGVyZT9cbiAgICAgICAgLy8gT2YgY291cnNlLCB0aGVyZSBhcmVuJ3QgYW55IHN1cHBvcnRlZCB5ZXQuLi5cblxuICAgICAgICAvLyBBZGQgdGhlIGdhaW4gbm9kZSBmb3IgdGhpcyBjaGFubmVsXG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nYWluTm9kZXNbY2hhbm5lbF0pO1xuXG4gICAgICAgIC8vIENvbm5lY3QgYW55IG5vZGVzIGFsb25nIHRoZSBwYXRoXG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBub2Rlc1tpLTFdLmNvbm5lY3Qobm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgc291cmNlIHRvIHRoZSBjb250ZXh0J3MgZGVzdGluYXRpb25cbiAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmF1ZGlvQ3R4LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNvdW5kIHRvIHBsYXlcbiAgICAgKiBAcGFyYW0gbG9vcCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIHNvdW5kXG4gICAgICogQHBhcmFtIGhvbGRSZWZlcmVuY2UgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB3ZSB3YW50IHRvIGhvbGQgb24gdG8gYSByZWZlcmVuY2Ugb2YgdGhlIGF1ZGlvIG5vZGUuIFRoaXMgaXMgZ29vZCBmb3IgcGxheWluZyBtdXNpYyBvbiBhIGxvb3AgdGhhdCB3aWxsIGV2ZW50dWFsbHkgbmVlZCB0byBiZSBzdG9wcGVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwbGF5U291bmQoa2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4sIGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIG9wdGlvbnM6IE1hcDxhbnk+KTogdm9pZCB7XG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3JlYXRlU291bmQoa2V5LCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZihsb29wKXtcbiAgICAgICAgICAgIHNvdW5kLmxvb3AgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGEgcmVmZXJlbmNlIG9mIHRoZSBuZXcgc291bmQgdG8gYSBtYXAuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBzdG9wIGEgbG9vcGluZyBvciBsb25nIHNvdW5kIGF0IGEgbGF0ZXIgdGltZVxuICAgICAgICBpZihob2xkUmVmZXJlbmNlKXtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5hZGQoa2V5LCBzb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNvdW5kLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RvcFNvdW5kKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3VycmVudFNvdW5kcy5nZXQoa2V5KTtcbiAgICAgICAgaWYoc291bmQpe1xuICAgICAgICAgICAgc291bmQuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG11dGVDaGFubmVsKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xuICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB1bm11dGVDaGFubmVsKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xuICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiBhIGNoYW5uZWwgdXNpbmcgdGhlIEdhaW5Ob2RlIGZvciB0aGF0IGNoYW5uZWwuIEZvciBtb3JlXG4gICAgICogaW5mb3JtYXRpb24gb24gR2Fpbk5vZGVzLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dhaW5Ob2RlXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGF1ZGlvIGNoYW5uZWwgdG8gc2V0IHRoZSB2b2x1bWUgZm9yXG4gICAgICogQHBhcmFtIHZvbHVtZSBUaGUgdm9sdW1lIG9mIHRoZSBjaGFubmVsLiAwIGlzIG11dGVkLiBWYWx1ZXMgYmVsb3cgemVybyB3aWxsIGJlIHNldCB0byB6ZXJvLlxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRWb2x1bWUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgdm9sdW1lOiBudW1iZXIpe1xuICAgICAgICBpZih2b2x1bWUgPCAwKXtcbiAgICAgICAgICAgIHZvbHVtZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbSA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBhbS5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIGFtLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBHYWluTm9kZSBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgR2Fpbk5vZGVzIGhlcmUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dhaW5Ob2RlXG4gICAgICogRE9OJ1QgVVNFIFRISVMgVU5MRVNTIFlPVSBLTk9XIFdIQVQgWU9VJ1JFIERPSU5HXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWxcbiAgICAgKiBAcmV0dXJucyBUaGUgR2Fpbk5vZGUgZm9yIHRoZSBzcGVjaWZpZWQgY2hhbm5lbFxuICAgICAqL1xuICAgIGdldENoYW5uZWxHYWluTm9kZShjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdO1xuICAgIH1cbiAgICBcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gUGxheSBlYWNoIGF1ZGlvIGNsaXAgcmVxdWVzdGVkXG4gICAgICAgIC8vIFRPRE8gLSBBZGQgbG9naWMgdG8gbWVyZ2Ugc291bmRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBvZiB0aGUgc2FtZSBrZXlcbiAgICAgICAgd2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1NPVU5EIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyB8fCBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKXtcbiAgICAgICAgICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9vcCA9IGV2ZW50LmRhdGEuZ2V0KFwibG9vcFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9sZFJlZmVyZW5jZSA9IGV2ZW50LmRhdGEuZ2V0KFwiaG9sZFJlZmVyZW5jZVwiKTtcblxuICAgICAgICAgICAgICAgIGxldCBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5ERUZBVUxUO1xuXG4gICAgICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDKXtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuTVVTSUM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5TRlg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEuaGFzKFwiY2hhbm5lbFwiKSl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBldmVudC5kYXRhLmdldChcImNoYW5uZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5U291bmQoc291bmRLZXksIGxvb3AsIGhvbGRSZWZlcmVuY2UsIGNoYW5uZWwsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQpe1xuICAgICAgICAgICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNvdW5kKHNvdW5kS2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwpe1xuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTCl7XG4gICAgICAgICAgICAgICAgdGhpcy51bm11dGVDaGFubmVsKGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEF1ZGlvQ2hhbm5lbFR5cGUge1xuICAgIERFRkFVTFQgPSAwLFxuICAgIFNGWCA9IDEsXG4gICAgTVVTSUMgPSAyLFxuICAgIENVU1RPTV8xID0gMyxcbiAgICBDVVNUT01fMiA9IDQsXG4gICAgQ1VTVE9NXzMgPSA1LFxuICAgIENVU1RPTV80ID0gNixcbiAgICBDVVNUT01fNSA9IDcsXG4gICAgQ1VTVE9NXzYgPSA4LFxuICAgIENVU1RPTV83ID0gOSxcbiAgICBDVVNUT01fOCA9IDEwLFxuICAgIENVU1RPTV85ID0gMTEsXG59XG5cbmV4cG9ydCBjb25zdCBNQVhfQVVESU9fQ0hBTk5FTFMgPSAxMjsiLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuL1RpbWVyTWFuYWdlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgdGltZXIgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGU6IFRpbWVyU3RhdGU7XG4gICAgXG4gICAgLyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyB0aW1lciBlbmRzICovXG4gICAgcHJvdGVjdGVkIG9uRW5kOiBGdW5jdGlvbjtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIHNob3VsZCBsb29wICovXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHRvdGFsIGFtb3VudCBvZiB0aW1lIHRoaXMgdGltZXIgcnVucyBmb3IgKi9cbiAgICBwcm90ZWN0ZWQgdG90YWxUaW1lOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGxlZnQgb24gdGhlIGN1cnJlbnQgcnVuICovXG4gICAgcHJvdGVjdGVkIHRpbWVMZWZ0OiBudW1iZXI7XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIHRpbWVyIGhhcyBiZWVuIHJ1biAqL1xuICAgIHByb3RlY3RlZCBudW1SdW5zOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcih0aW1lOiBudW1iZXIsIG9uRW5kPzogRnVuY3Rpb24sIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSl7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoaXMgdGltZXJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuYWRkVGltZXIodGhpcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSAwO1xuICAgICAgICB0aGlzLm9uRW5kID0gb25FbmQ7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMubnVtUnVucyA9IDA7XG4gICAgfVxuXG4gICAgaXNTdG9wcGVkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuXG4gICAgaXNQYXVzZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuUEFVU0VEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyB0aW1lciBoYXMgYmVlbiBydW4gYmVmb3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBpdCBoYXMgYmVlbiBydW4gYXQgbGVhc3Qgb25jZSAoYWZ0ZXIgdGhlIGxhdGVzdCByZXNldCksIGFuZCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBoYXNSdW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVJ1bnMgPiAwO1xuICAgIH1cblxuICAgIHN0YXJ0KHRpbWU/OiBudW1iZXIpe1xuICAgICAgICBpZih0aW1lICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xuICAgIH1cblxuICAgIC8qKiBSZXNldHMgdGhpcyB0aW1lci4gU2V0cyB0aGUgcHJvZ3Jlc3MgYmFjayB0byB6ZXJvLCBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHJ1bnMgYmFjayB0byB6ZXJvICovXG4gICAgcmVzZXQoKXtcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xuICAgICAgICB0aGlzLm51bVJ1bnMgPSAwO1xuICAgIH1cblxuICAgIHBhdXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5QQVVTRUQ7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcbiAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5BQ1RJVkUpe1xuICAgICAgICAgICAgdGhpcy50aW1lTGVmdCAtPSBkZWx0YVQqMTAwMDtcblxuICAgICAgICAgICAgaWYodGhpcy50aW1lTGVmdCA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gTWF0aFV0aWxzLmNsYW1wTG93MCh0aGlzLnRpbWVMZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGVuZCgpe1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMubnVtUnVucyArPSAxO1xuXG4gICAgICAgIC8vIENhbGwgdGhlIGVuZCBmdW5jdGlvbiBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgaWYodGhpcy5vbkVuZCl7XG4gICAgICAgICAgICB0aGlzLm9uRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIGlmIHdlIHdhbnQgdG9cbiAgICAgICAgaWYodGhpcy5sb29wKXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcbiAgICAgICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ3tcbiAgICAgICAgcmV0dXJuIFwiVGltZXI6IFwiICsgdGhpcy5zdGF0ZSArIFwiIC0gVGltZSBMZWZ0OiBcIiArIHRoaXMudGltZUxlZnQgKyBcIm1zIG9mIFwiICsgdGhpcy50b3RhbFRpbWUgKyBcIm1zXCI7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBUaW1lclN0YXRlIHtcbiAgICBBQ1RJVkUgPSBcIkFDVElWRVwiLFxuICAgIFBBVVNFRCA9IFwiUEFVU0VEXCIsXG4gICAgU1RPUFBFRCA9IFwiU1RPUFBFRFwiXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi9UaW1lclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIHByb3RlY3RlZCB0aW1lcnM6IEFycmF5PFRpbWVyPjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudGltZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbnN0YW5jZTogVGltZXJNYW5hZ2VyO1xuXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFRpbWVyTWFuYWdlciB7XG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xuICAgICAgICB0aGlzLnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVycygpe1xuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi9NYXRoVXRpbHNcIjtcblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGRhdGF0eXBlcyBmb2xkZXJcbi8qKlxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yIHtcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cblx0cHVibGljIHI6IG51bWJlcjtcblx0LyoqIFRoZSBncmVlbiB2YWx1ZSAqL1xuXHRwdWJsaWMgZzogbnVtYmVyO1xuXHQvKiogVGhlIGJsdWUgdmFsdWUgKi9cblx0cHVibGljIGI6IG51bWJlcjtcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xuXHRwdWJsaWMgYTogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGNvbG9yXG5cdCAqIEBwYXJhbSByIFJlZFxuXHQgKiBAcGFyYW0gZyBHcmVlblxuXHQgKiBAcGFyYW0gYiBCbHVlXG5cdCAqIEBwYXJhbSBhIEFscGhhXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihyOiBudW1iZXIgPSAwLCBnOiBudW1iZXIgPSAwLCBiOiBudW1iZXIgPSAwLCBhOiBudW1iZXIgPSAxKXtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hID0gYTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYmEoMCwgMCwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdH1cblx0XG5cdC8qKlx0XG5cdCAqIFJlZCBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBSRUQoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIEdyZWVuIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAyNTUsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IEdSRUVOKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBCbHVlIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IEJMVUUoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMjU1LCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIFllbGxvdyBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFlFTExPVygpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBNYWdlbnRhIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigyNTUsIDAsIDI1NSlcblx0ICovXG5cdHN0YXRpYyBnZXQgTUFHRU5UQSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDAsIDI1NSwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBDeWFuIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAyNTUsIDI1NSlcblx0ICovXG5cdHN0YXRpYyBnZXQgQ1lBTigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDI1NSwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBXaGl0ZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDI1NSlcblx0ICovXG5cdHN0YXRpYyBnZXQgV0hJVEUoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMSk7XG5cdH0gXG5cblx0LyoqXHRcblx0ICogQmxhY2sgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IEJMQUNLKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogT3JhbmdlIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigyNTUsIDEwMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMTAwLCAwLCAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xvciB0byB0aGUgdmFsdWVzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSByIFJlZFxuXHQgKiBAcGFyYW0gZyBHcmVlblxuXHQgKiBAcGFyYW0gYiBCbHVlXG5cdCAqIEBwYXJhbSBhIEFscGhhXG5cdCAqL1xuXHRzZXQocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlciwgYTogbnVtYmVyID0gMSk6IHZvaWQge1xuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYSA9IGE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBjb2xvciBzbGlnaHRseSBsaWdodGVyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3Jcblx0ICogQHJldHVybnMgQSBuZXcgbGlnaHRlciBDb2xvclxuXHQgKi9cblx0bGlnaHRlbigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3Jcblx0ICogQHJldHVybnMgQSBuZXcgZGFya2VyIENvbG9yXG5cdCAqL1xuXHRkYXJrZW4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhpcyBjb2xvciBhcyBhbiBhcnJheVxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cblx0ICovXG5cdHRvQXJyYXkoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtICNSUkdHQkJcblx0ICogQHJldHVybnMgI1JSR0dCQlxuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIjXCIgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5yLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmcsIDIpICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuYiwgMik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXG5cdCAqIEByZXR1cm5zIHJnYihyLCBnLCBiKVxuXHQgKi9cblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJyZ2IoXCIgKyB0aGlzLnIudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZy50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5iLnRvU3RyaW5nKCkgKyBcIilcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSByZ2JhKHIsIGcsIGIsIGEpXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcblx0ICovXG5cdHRvU3RyaW5nUkdCQSgpOiBzdHJpbmcge1xuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZ1JHQigpO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgdGhpcyBjb2xvciBpbnRvIGEgZmxvYXQzMkFycmF5IGFuZCBjaGFuZ2VzIGNvbG9yIHJhbmdlIHRvIFswLjAsIDEuMF1cblx0ICogQHJldHVybnMgYSBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgY29sb3Jcblx0ICovXG5cdHRvV2ViR0woKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHR0aGlzLnIvMjU1LFxuXHRcdFx0dGhpcy5nLzI1NSxcblx0XHRcdHRoaXMuYi8yNTUsXG5cdFx0XHR0aGlzLmFcblx0XHRdKTtcblx0fVxuXG5cdHN0YXRpYyBmcm9tU3RyaW5nSGV4KHN0cjogc3RyaW5nKTogQ29sb3Ige1xuXHRcdGxldCBpID0gMDtcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcblx0XHRsZXQgciA9IE1hdGhVdGlscy5mcm9tSGV4KHN0ci5zdWJzdHJpbmcoaSwgaSsyKSk7XG5cdFx0bGV0IGcgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrMiwgaSs0KSk7XG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiKTtcblx0fVxufSIsIi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVhc2VGdW5jdGlvbnMge1xuXG4gICAgc3RhdGljIGVhc2VJbk91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5jb3MoTWF0aC5QSSAqIHgpIC0gMSkgLyAyO1xuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlT3V0SW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKCh4ICogTWF0aC5QSSkgLyAyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZUluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKCh4ICogTWF0aC5QSSkgLyAyKTsgXG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VJbk91dFF1aW50KHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMiAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDIpIC8gMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dEluUXVhZCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IHRoaXMuZWFzZU91dEluX091dFBvdyh4LCAyKSA6IHRoaXMuZWFzZU91dEluX0luUG93KHgsIDIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGVhc2VPdXRJbl9PdXRQb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAwLjUgKyBNYXRoLnBvdygyICogeCAtIDEsIHBvdykgLyAyO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gRWFzZUZ1bmN0aW9uVHlwZSB7XG4gICAgLy8gU0lORVxuICAgIElOX09VVF9TSU5FID0gXCJlYXNlSW5PdXRTaW5lXCIsXG4gICAgT1VUX0lOX1NJTkUgPSBcImVhc2VPdXRJblNpbmVcIixcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXG4gICAgT1VUX1NJTkUgPSBcImVhc2VPdXRTaW5lXCIsXG5cbiAgICAvLyBRVUFEXG4gICAgSU5fT1VUX1FVQUQgPSBcImVhc2VJbk91dFF1YWRcIixcbiAgICBPVVRfSU5fUVVBRCA9IFwiZWFzZU91dEluUXVhZFwiLFxuXG4gICAgLy8gUVVJTlRcbiAgICBJTl9PVVRfUVVJTlQgPSBcImVhc2VJbk91dFF1aW50XCJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcbmltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZVwiO1xuXG4vKiogQSBjbGFzcyB0byBwcm92aWRlcyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBncmFwaHMgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoVXRpbHMge1xuXG5cdC8qKlxuXHQgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBEamlrc3RyYSdzIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtIGJhc2VkIG9uIHRoZSBvbmUgZGVzY3JpYmVkIGluIFRoZSBBbGdvcml0aG0gRGVzaWduIE1hbnVhbC5cblx0ICogQHBhcmFtIGcgVGhlIGdyYXBoXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgbnVtYmVyIHRvIHN0YXJ0IHRoZSBzaG9ydGVzdCBwYXRoIGZyb21cblx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGFyZW50IG9mIGVhY2ggbm9kZSBvZiB0aGUgR3JhcGggaW4gdGhlIHNob3J0ZXN0IHBhdGguXG5cdCAqL1xuXHRzdGF0aWMgZGppa3N0cmEoZzogR3JhcGgsIHN0YXJ0OiBudW1iZXIpOiBBcnJheTxudW1iZXI+IHtcblx0XHRsZXQgaTogbnVtYmVyO1x0XHQvLyBDb3VudGVyXG5cdFx0bGV0IHA6IEVkZ2VOb2RlO1x0Ly8gUG9pbnRlciB0byBlZGdlbm9kZVxuXHRcdGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xuXHRcdGxldCBkaXN0YW5jZTogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcblx0XHRsZXQgcGFyZW50OiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xuXHRcdGxldCB2OiBudW1iZXI7XHRcdC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3Ncblx0XHRsZXQgdzogbnVtYmVyOyBcdFx0Ly8gQ2FuZGlkYXRlIGZvciBuZXh0IHZlcnRleFxuXHRcdGxldCB3ZWlnaHQ6IG51bWJlcjtcdC8vIEVkZ2Ugd2VpZ2h0XG5cdFx0bGV0IGRpc3Q7XHRcdFx0Ly8gQmVzdCBjdXJyZW50IGRpc3RhbmNlIGZyb20gc3RhcnRcblxuXHRcdGZvcihpID0gMDsgaSA8IGcubnVtVmVydGljZXM7IGkrKyl7XG5cdFx0XHRpblRyZWVbaV0gPSBmYWxzZTtcblx0XHRcdGRpc3RhbmNlW2ldID0gSW5maW5pdHk7XG5cdFx0XHRwYXJlbnRbaV0gPSAtMTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVtzdGFydF0gPSAwO1xuXHRcdHYgPSBzdGFydDtcblxuXHRcdHdoaWxlKCFpblRyZWVbdl0pe1xuXHRcdFx0aW5UcmVlW3ZdID0gdHJ1ZTtcblx0XHRcdHAgPSBnLmVkZ2VzW3ZdO1xuXG5cdFx0XHR3aGlsZShwICE9PSBudWxsKXtcblx0XHRcdFx0dyA9IHAueTtcblx0XHRcdFx0d2VpZ2h0ID0gcC53ZWlnaHQ7XG5cblx0XHRcdFx0aWYoZGlzdGFuY2Vbd10gPiBkaXN0YW5jZVt2XSArIHdlaWdodCl7XG5cdFx0XHRcdFx0ZGlzdGFuY2Vbd10gPSBkaXN0YW5jZVt2XSArIHdlaWdodDtcblx0XHRcdFx0XHRwYXJlbnRbd10gPSB2O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cCA9IHAubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0diA9IDA7XG5cblx0XHRcdGRpc3QgPSBJbmZpbml0eTtcblxuXHRcdFx0Zm9yKGkgPSAwOyBpIDw9IGcubnVtVmVydGljZXM7IGkrKyl7XG5cdFx0XHRcdGlmKCFpblRyZWVbaV0gJiYgZGlzdCA+IGRpc3RhbmNlW2ldKXtcblx0XHRcdFx0XHRkaXN0ID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0diA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyZW50O1xuXG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqIEEgY2xhc3MgY29udGFpbmluZyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBtYXRoIG9wZXJhdGlvbnMgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgdmFsdWUgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXG4gICAgICogQHJldHVybnMgLTEgaWYgdGhlIG51bWJlciBpcyBsZXNzIHRoYW4gMCwgMSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB4IGlzIGJldHdlZW4gYSBhbmQgYlxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcbiAgICAgKiBAcGFyYW0gYiBUaGUgbWF4IGJvdW5kXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB4IGlzIGJldHdlZW4gYSBhbmQgYiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgICAgICBpZihleGNsdXNpdmUpe1xuICAgICAgICAgICAgcmV0dXJuIChhIDwgeCkgJiYgKHggPCBiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYSA8PSB4KSAmJiAoeCA8PSBiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEBwYXJhbSBtaW4gVGhlIG1pbiBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgYmV0d2VlbiBtaW4gYW5kIG1heCwgb3IgbWluL21heCBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGlmKHggPCBtaW4pIHJldHVybiBtaW47XG4gICAgICAgIGlmKHggPiBtYXgpIHJldHVybiBtYXg7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcDAxKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gdGhlIHJhbmdlIHRvIG1pblxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gbWluLCBvdGhlcndpc2UgbWluXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IG1pbiA/IG1pbiA6IHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSBsb3dlciBlbmQgb2YgdGhlIHZhbHVlIG9mIHggdG8gemVyb1xuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDAsIG90aGVyd2lzZSAwXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wTG93KHgsIDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGFtcE1hZ25pdHVkZSh2OiBWZWMyLCBtOiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgaWYodi5tYWdTcSgpID4gbSptKXtcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XG4gICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXJwKG5ld01pbiwgbmV3TWF4LCB0aGlzLmludkxlcnAobWluLCBtYXgsIHgpKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogTGluZWFyIEludGVycG9sYXRpb25cblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSB3ZSBhcmUgaW50ZXJwb2xhdGluZyB0b1xuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XG5cdCAqL1xuXHRzdGF0aWMgbGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIExpbmVhciBJbnRlcnBvbGF0aW9uLiBGaW5kcyB0aGUgdGltZSBhdCB3aGljaCBhIHZhbHVlIGJldHdlZW4gYSBhbmQgYiB3b3VsZCBvY2N1clxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBjdXJyZW50IHZhbHVlIG9jY3VycyBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBzdGF0aWMgaW52TGVycChhOiBudW1iZXIsIGI6IG51bWJlciwgdmFsdWU6IG51bWJlcil7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBhKS8oYiAtIGEpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBmbG9vclxuICAgICAqIEBwYXJhbSBwbGFjZSBUaGUgbGFzdCBkZWNpbWFsIHBsYWNlIG9mIHRoZSBuZXcgbnVtYmVyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXG4gICAgICovXG4gICAgc3RhdGljIGZsb29yVG9QbGFjZShudW06IG51bWJlciwgcGxhY2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmFjdG9yID0gMTA7XG4gICAgICAgIHdoaWxlKHBsYWNlID4gMSl7XG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XG4gICAgICAgICAgICBwbGFjZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKmZhY3RvcikvZmFjdG9yO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xuICAgICAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBoZXggbnVtYmVyXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciBpbiBkZWNpbWFsIHJlcHJlc2VudGVkIGJ5IHRoZSBoZXggc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBoZXhcbiAgICAgKiBAcGFyYW0gbWluTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGhleCBzdHJpbmcgKGFkZHMgemVybyBwYWRkaW5nIGlmIG5lZWRlZClcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9IZXgobnVtOiBudW1iZXIsIG1pbkxlbmd0aDogbnVtYmVyID0gbnVsbCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xuICAgICAgICB3aGlsZShmYWN0b3IqMTYgPCBudW0pe1xuICAgICAgICAgICAgZmFjdG9yICo9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZXhTdHIgPSBcIlwiO1xuICAgICAgICB3aGlsZShmYWN0b3IgPj0gMSl7XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xuICAgICAgICAgICAgaGV4U3RyICs9IE1hdGhVdGlscy50b0hleERpZ2l0KGRpZ2l0KTtcbiAgICAgICAgICAgIG51bSAtPSBkaWdpdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcblx0XHR9XG5cdFx0XG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcblx0XHRcdHdoaWxlKGhleFN0ci5sZW5ndGggPCBtaW5MZW5ndGgpe1xuXHRcdFx0XHRoZXhTdHIgPSBcIjBcIiArIGhleFN0cjtcblx0XHRcdH1cblx0XHR9XG5cbiAgICAgICAgcmV0dXJuIGhleFN0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0IHRvIGhleGFkZWNpbWFsLiBJbiB0aGlzIGNhc2UsIGEgZGlnaXQgaXMgYmV0d2VlbiAwIGFuZCAxNSBpbmNsdXNpdmVcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBkaWdpdCB0byBjb252ZXJ0IHRvIGhleGFkZWNpbWFsXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9IZXhEaWdpdChudW06IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGlmKG51bSA8IDEwKXtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4vQ29sb3JcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmluZ1V0aWxzIHtcblx0c3RhdGljIHRvV2ViR0xDb29yZHMocG9pbnQ6IFZlYzIsIG9yaWdpbjogVmVjMiwgd29ybGRTaXplOiBWZWMyKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueCwgb3JpZ2luLngsIG9yaWdpbi54ICsgd29ybGRTaXplLngsIC0xLCAxKSxcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC55LCBvcmlnaW4ueSwgb3JpZ2luLnkgKyB3b3JsZFNpemUueSwgMSwgLTEpXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgdG9XZWJHTFNjYWxlKHNpemU6IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0MipzaXplLngvd29ybGRTaXplLngsXG5cdFx0XHQyKnNpemUueS93b3JsZFNpemUueSxcblx0XHRdKTtcblx0fVxuXG5cdHN0YXRpYyB0b1dlYkdMQ29sb3IoY29sb3I6IENvbG9yKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuciwgMCwgMjU1LCAwLCAxKSxcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5nLCAwLCAyNTUsIDAsIDEpLFxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmIsIDAsIDI1NSwgMCwgMSksXG5cdFx0XHRjb2xvci5hXG5cdFx0XSk7XG5cdH1cbn0iLCIvKiogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIHN0cmluZ3MgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ1V0aWxzIHtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCB0aGUgZmlsZXBhdGggdG8gZXh0cmFjdCB0aGUgcGF0aCBmcm9tXG4gICAgICogQHJldHVybnMgVGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgZmlsZXBhdGggcHJvdmlkZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF0aEZyb21GaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHNwbGl0UGF0aCA9IGZpbGVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgc3BsaXRQYXRoLnBvcCgpO1xuICAgICAgICBzcGxpdFBhdGgucHVzaChcIlwiKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aC5qb2luKFwiL1wiKTtcbiAgICB9XG59IiwiaW1wb3J0IFN0YXRlTWFjaGluZUFJIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9BSS9TdGF0ZU1hY2hpbmVBSVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFdlYXBvbiBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uXCI7XHJcbmltcG9ydCB7IGh3M19FdmVudHMgfSBmcm9tIFwiLi4vaHczX2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgQWxlcnQgZnJvbSBcIi4vRW5lbXlTdGF0ZXMvQWxlcnRcIjtcclxuaW1wb3J0IEF0dGFjayBmcm9tIFwiLi9FbmVteVN0YXRlcy9BdHRhY2tcIjtcclxuaW1wb3J0IEd1YXJkIGZyb20gXCIuL0VuZW15U3RhdGVzL0d1YXJkXCI7XHJcbmltcG9ydCBQYXRyb2wgZnJvbSBcIi4vRW5lbXlTdGF0ZXMvUGF0cm9sXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmVteUFJIGV4dGVuZHMgU3RhdGVNYWNoaW5lQUkgaW1wbGVtZW50cyBCYXR0bGVyQUkge1xyXG4gICAgLyoqIFRoZSBvd25lciBvZiB0aGlzIEFJICovXHJcbiAgICBvd25lcjogQW5pbWF0ZWRTcHJpdGU7XHJcblxyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgaGVhbHRoIHRoaXMgZW50aXR5IGhhcyAqL1xyXG4gICAgaGVhbHRoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBkZWZhdWx0IG1vdmVtZW50IHNwZWVkIG9mIHRoaXMgQUkgKi9cclxuICAgIHNwZWVkOiBudW1iZXIgPSAyMDtcclxuXHJcbiAgICAvKiogVGhlIHdlYXBvbiB0aGlzIEFJIGhhcyAqL1xyXG4gICAgd2VhcG9uOiBXZWFwb247XHJcblxyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgb2JqZWN0ICovXHJcbiAgICBwbGF5ZXI6IEdhbWVOb2RlO1xyXG5cclxuICAgIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcblxyXG4gICAgICAgIGlmKG9wdGlvbnMuZGVmYXVsdE1vZGUgPT09IFwiZ3VhcmRcIil7XHJcbiAgICAgICAgICAgIC8vIEd1YXJkIG1vZGVcclxuICAgICAgICAgICAgdGhpcy5hZGRTdGF0ZShFbmVteVN0YXRlcy5ERUZBVUxULCBuZXcgR3VhcmQodGhpcywgb3duZXIsIG9wdGlvbnMuZ3VhcmRQb3NpdGlvbikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFBhdHJvbCBtb2RlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkU3RhdGUoRW5lbXlTdGF0ZXMuREVGQVVMVCwgbmV3IFBhdHJvbCh0aGlzLCBvd25lciwgb3B0aW9ucy5wYXRyb2xSb3V0ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShFbmVteVN0YXRlcy5BTEVSVCwgbmV3IEFsZXJ0KHRoaXMsIG93bmVyKSk7XHJcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShFbmVteVN0YXRlcy5BVFRBQ0tJTkcsIG5ldyBBdHRhY2sodGhpcywgb3duZXIpKTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcclxuXHJcbiAgICAgICAgdGhpcy53ZWFwb24gPSBvcHRpb25zLndlYXBvbjtcclxuXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBvcHRpb25zLnBsYXllcjtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGV2ZW50c1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKGh3M19FdmVudHMuU0hPVF9GSVJFRCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdWJzY3JpYmVkIHRvIGV2ZW50XCIpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIHRoZSBkZWZhdWx0IHN0YXRlXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG5cclxuICAgICAgICB0aGlzLmdldFBsYXllclBvc2l0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIGRhbWFnZShkYW1hZ2U6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9vayBkYW1hZ2VcIik7XHJcbiAgICAgICAgdGhpcy5oZWFsdGggLT0gZGFtYWdlO1xyXG4gICAgXHJcbiAgICAgICAgaWYodGhpcy5oZWFsdGggPD0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuc2V0QUlBY3RpdmUoZmFsc2UsIHt9KTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5pc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuZGlzYWJsZVBoeXNpY3MoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKE1hdGgucmFuZG9tKCkgPCAwLjIpe1xyXG4gICAgICAgICAgICAgICAgLy8gU3Bhd24gYSBoZWFsdGhwYWNrXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFwiaGVhbHRocGFja1wiLCB7cG9zaXRpb246IHRoaXMub3duZXIucG9zaXRpb259KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGxheWVyUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucGxheWVyLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG5ldyBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm93bmVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9zLmNsb25lKCkuc3ViKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBwb3MueSk7XHJcbiAgICAgICAgbGV0IG1heFkgPSBNYXRoLm1heChzdGFydC55LCBwb3MueSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHdhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXRMYXllcihcIldhbGxcIikuZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWluWCwgbWluWSkpO1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1heFgsIG1heFkpKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih3YWxscy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29sbGlkZXIuaW50ZXJzZWN0U2VnbWVudChzdGFydCwgZGVsdGEsIFZlYzIuWkVSTyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhpdCAhPT0gbnVsbCAmJiBzdGFydC5kaXN0YW5jZVNxVG8oaGl0LnBvcykgPCBzdGFydC5kaXN0YW5jZVNxVG8ocG9zKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCBhIHdhbGwsIHdlIGNhbid0IHNlZSB0aGUgcGxheWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0ZSBtYWNoaW5lIGRlZmVycyB1cGRhdGVzIGFuZCBldmVudCBoYW5kbGluZyB0byBpdHMgY2hpbGRyZW5cclxuICAgIC8vIENoZWNrIHN1cGVyIGNsYXNzZXMgZm9yIGRldGFpbHNcclxufVxyXG5cclxuZXhwb3J0IGVudW0gRW5lbXlTdGF0ZXMge1xyXG4gICAgREVGQVVMVCA9IFwiZGVmYXVsdFwiLFxyXG4gICAgQUxFUlQgPSBcImFsZXJ0XCIsXHJcbiAgICBBVFRBQ0tJTkcgPSBcImF0dGFja2luZ1wiLFxyXG4gICAgUFJFVklPVVMgPSBcInByZXZpb3VzXCJcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5pbXBvcnQgeyBodzNfTmFtZXMgfSBmcm9tIFwiLi4vLi4vaHczX2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgRW5lbXlBSSwgeyBFbmVteVN0YXRlcyB9IGZyb20gXCIuLi9FbmVteUFJXCI7XHJcbmltcG9ydCBFbmVteVN0YXRlIGZyb20gXCIuL0VuZW15U3RhdGVcIjtcclxuXHJcbi8qKiBXaGVuIGFuIGVuZW15IGhlYXJzIGEgZ3Vuc2hvdCwgaXQgd2lsbCBydXNoIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ3Vuc2hvdCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydCBleHRlbmRzIEVuZW15U3RhdGUge1xyXG4gICAgLyoqIFRoZSBwYXRoIHRvIG1vdmUgdG93YXJkcyB0aGUgYWxlcnQgcG9zaXRpb24gb24gKi9cclxuICAgIHByaXZhdGUgcGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblxyXG4gICAgLyoqIEEgdGltZXIgdG8gdGVsbCB1cyBob3cgbG9uZyB0byBiZSBhbGVydGVkIGZvciAqL1xyXG4gICAgcHJpdmF0ZSBhbGVydFRpbWVyOiBUaW1lcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEVuZW15QUksIG93bmVyOiBHYW1lTm9kZSl7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBvd25lcik7XHJcblxyXG4gICAgICAgIHRoaXMuYWxlcnRUaW1lciA9IG5ldyBUaW1lcigxMDAwMCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlY2VpdmVzIG9wdGlvbnMudGFyZ2V0XHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLm93bmVyLmdldFNjZW5lKCkuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5nZXRQYXRoKGh3M19OYW1lcy5OQVZNRVNILCB0aGlzLm93bmVyLnBvc2l0aW9uLCBvcHRpb25zLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5hbGVydFRpbWVyLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoaWxlIGluIHRoZSBhbGVydCBzdGF0ZSwgYW4gZW5lbXkgc2hvdWxkIG1vdmUgdG93YXJkcyB0aGUgdGFyZ2V0IHBvc2l0aW9uIHJlY2VpdmVkIGluIG9uRW50ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIFlvdXIgam9iIGlzIHRvIG1ha2Ugc3VyZSB0aGF0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGFsZXJ0IHN0YXRlLCB0aGUgZW5lbXkgbW92ZXMgdG93YXJkcyB0aGlzXHJcbiAgICAgKiB0YXJnZXQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuYWxlcnRUaW1lci5pc1N0b3BwZWQoKSl7XHJcbiAgICAgICAgICAgIC8vIFRoZSB0aW1lciBpcyB1cCwgcmV0dXJuIHRvIHRoZSBkZWZhdWx0IHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoRW5lbXlTdGF0ZXMuREVGQVVMVCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXRoaXMucGF0aC5pc0RvbmUoKSl7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIubW92ZU9uUGF0aCh0aGlzLnBhcmVudC5zcGVlZCAqIGRlbHRhVCwgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyh0aGlzLnBhdGguZ2V0TW92ZURpcmVjdGlvbih0aGlzLm93bmVyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5BVFRBQ0tJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBFbmVteUFJLCB7IEVuZW15U3RhdGVzIH0gZnJvbSBcIi4uL0VuZW15QUlcIjtcclxuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0YWNrIGV4dGVuZHMgRW5lbXlTdGF0ZSB7XHJcbiAgICAvLyBUaW1lcnMgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGVcclxuICAgIHBvbGxUaW1lcjogVGltZXI7XHJcbiAgICBleGl0VGltZXI6IFRpbWVyO1xyXG5cclxuICAgIC8vIFRoZSBjdXJyZW50IGtub3duIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXJcclxuICAgIHBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBUaGUgbGFzdCBrbm93biBwb3NpdGlvbiBvZiB0aGUgcGxheWVyXHJcbiAgICBsYXN0UGxheWVyUG9zOiBWZWMyO1xyXG5cclxuICAgIC8vIFRoZSByZXR1cm4gb2JqZWN0IGZvciB0aGlzIHN0YXRlXHJcbiAgICByZXRPYmo6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xyXG5cclxuICAgICAgICAvLyBSZWd1bGFybHkgdXBkYXRlIHRoZSBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICB0aGlzLnBvbGxUaW1lciA9IG5ldyBUaW1lcigxMDApO1xyXG5cclxuICAgICAgICB0aGlzLmV4aXRUaW1lciA9IG5ldyBUaW1lcigxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGF5ZXJQb3MgPSB0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICAvLyBSZXNldCB0aGUgcmV0dXJuIG9iamVjdFxyXG4gICAgICAgIHRoaXMucmV0T2JqID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge31cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnBvbGxUaW1lci5pc1N0b3BwZWQoKSl7XHJcbiAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyXHJcbiAgICAgICAgICAgIHRoaXMucG9sbFRpbWVyLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBsYXllclBvcyA9IHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnBsYXllclBvcyAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzZWUgYSBuZXcgcGxheWVyIHBvc2l0aW9uLCB1cGRhdGUgdGhlIGxhc3QgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFBsYXllclBvcyA9IHRoaXMucGxheWVyUG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnBsYXllclBvcyAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vIFBsYXllciBpcyB2aXNpYmxlLCByZXN0YXJ0IHRoZSBleGl0VGltZXJcclxuICAgICAgICAgICAgdGhpcy5leGl0VGltZXIuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgYXQgcGxheWVyXHJcbiAgICAgICAgICAgIGxldCBkaXIgPSB0aGlzLnBsYXllclBvcy5jbG9uZSgpLnN1Yih0aGlzLm93bmVyLnBvc2l0aW9uKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgZGlyLnJvdGF0ZUNDVyhNYXRoLlBJIC8gNCAqIE1hdGgucmFuZG9tKCkgLSBNYXRoLlBJLzgpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnBhcmVudC53ZWFwb24udXNlKHRoaXMub3duZXIsIFwiZW5lbXlcIiwgZGlyKSl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmaXJlZCwgZmFjZSB0aGF0IGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyhkaXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5leGl0VGltZXIuaXNTdG9wcGVkKCkpe1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlbid0IHNlZW4gdGhlIHBsYXllciBpbiBhIHdoaWxlLCBnbyBjaGVjayBvdXQgd2hlcmUgd2UgbGFzdCBzYXcgdGhlbSwgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgaWYodGhpcy5sYXN0UGxheWVyUG9zICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucmV0T2JqID0ge3RhcmdldDogdGhpcy5sYXN0UGxheWVyUG9zfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5BTEVSVCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgRW5lbXlBSSBmcm9tIFwiLi4vRW5lbXlBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgRW5lbXlTdGF0ZSBleHRlbmRzIFN0YXRlIHtcclxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IEVuZW15QUk7XHJcbiAgICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRW5lbXlBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgc3VwZXIocGFyZW50KTtcclxuICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XHJcbmltcG9ydCB7IGh3M19FdmVudHMsIGh3M19OYW1lcyB9IGZyb20gXCIuLi8uLi9odzNfY29uc3RhbnRzXCI7XHJcbmltcG9ydCBFbmVteUFJLCB7IEVuZW15U3RhdGVzIH0gZnJvbSBcIi4uL0VuZW15QUlcIjtcclxuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3VhcmQgZXh0ZW5kcyBFbmVteVN0YXRlIHtcclxuICAgIHByaXZhdGUgZ3VhcmRQb3NpdGlvbjogVmVjMjtcclxuXHJcbiAgICBwcml2YXRlIGF3YXlGcm9tR3VhcmRQb3NpdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIHJvdXRlOiBOYXZpZ2F0aW9uUGF0aDtcclxuXHJcbiAgICBwcml2YXRlIHJldE9iajogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUsIGd1YXJkUG9zaXRpb246IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmd1YXJkUG9zaXRpb24gPSBndWFyZFBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIC8vIEdvIHRvIHRoZSBndWFyZCBwb3NpdGlvbiBpZiBub3QgYWxyZWFkeSB0aGVyZVxyXG4gICAgICAgIGlmKCEodGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ndWFyZFBvc2l0aW9uKSA8IDgqOCkpe1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIGEgbmV3IHJvdXRlXHJcbiAgICAgICAgICAgIHRoaXMuYXdheUZyb21HdWFyZFBvc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5wYXRoZmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSB0aGlzLm93bmVyLmdldFNjZW5lKCkuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5nZXRQYXRoKGh3M19OYW1lcy5OQVZNRVNILCB0aGlzLm93bmVyLnBvc2l0aW9uLCB0aGlzLmd1YXJkUG9zaXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXdheUZyb21HdWFyZFBvc2l0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIucGF0aGZpbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IGh3M19FdmVudHMuU0hPVF9GSVJFRCl7XHJcbiAgICAgICAgICAgIC8vIFNob3Qgd2FzIGZpcmVkLiBHbyBjaGVjayBpdCBvdXQgaWYgaXQgd2FzIGNsb3NlIHRvIHVzXHJcbiAgICAgICAgICAgIGlmKHRoaXMub3duZXIucG9zaXRpb24uZGlzdGFuY2VUbyhldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpKSA8IGV2ZW50LmRhdGEuZ2V0KFwidm9sdW1lXCIpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucmV0T2JqID0ge3RhcmdldDogZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKX07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkFMRVJUKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmF3YXlGcm9tR3VhcmRQb3NpdGlvbil7XHJcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIGJhY2sgaG9tZVxyXG4gICAgICAgICAgICBpZih0aGlzLnJvdXRlLmlzRG9uZSgpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXdheUZyb21HdWFyZFBvc2l0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnBhdGhmaW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLm1vdmVPblBhdGgodGhpcy5wYXJlbnQuc3BlZWQgKiBkZWx0YVQsIHRoaXMucm91dGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyh0aGlzLnJvdXRlLmdldE1vdmVEaXJlY3Rpb24odGhpcy5vd25lcikpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKSAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoRW5lbXlTdGF0ZXMuQVRUQUNLSU5HKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldE9iajtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcclxuaW1wb3J0IHsgaHczX0V2ZW50cywgaHczX05hbWVzIH0gZnJvbSBcIi4uLy4uL2h3M19jb25zdGFudHNcIjtcclxuaW1wb3J0IEVuZW15QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vRW5lbXlBSVwiO1xyXG5pbXBvcnQgRW5lbXlTdGF0ZSBmcm9tIFwiLi9FbmVteVN0YXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRyb2wgZXh0ZW5kcyBFbmVteVN0YXRlIHtcclxuXHJcbiAgICAvLyBUaGUgcm91dGUgdGhpcyBBSSB0YWtlcyB3aGVuIHBhdHJvbGxpbmdcclxuICAgIHByb3RlY3RlZCBwYXRyb2xSb3V0ZTogQXJyYXk8VmVjMj47XHJcblxyXG4gICAgLy8gVGhlIGN1cnJlbnQgcGF0cm9sUm91dGUgaW5kZXhcclxuICAgIHByb3RlY3RlZCByb3V0ZUluZGV4OiBudW1iZXI7XHJcblxyXG4gICAgLy8gVGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRQYXRoOiBOYXZpZ2F0aW9uUGF0aDtcclxuXHJcbiAgICAvLyBBIHJldHVybiBvYmplY3QgZm9yIGV4aXRpbmcgdGhpcyBzdGF0ZVxyXG4gICAgcHJvdGVjdGVkIHJldE9iajogUmVjb3JkPHN0cmluZywgYW55PjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEVuZW15QUksIG93bmVyOiBHYW1lTm9kZSwgcGF0cm9sUm91dGU6IEFycmF5PFZlYzI+KXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXRyb2xSb3V0ZSA9IHBhdHJvbFJvdXRlO1xyXG4gICAgICAgIHRoaXMucm91dGVJbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZ2V0TmV4dFBhdGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gaHczX0V2ZW50cy5TSE9UX0ZJUkVEKXtcclxuICAgICAgICAgICAgLy8gU2hvdCB3YXMgZmlyZWQuIEdvIGNoZWNrIGl0IG91dCBpZiBpdCB3YXMgY2xvc2UgdG8gdXNcclxuICAgICAgICAgICAgaWYodGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVRvKGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIikpIDwgZXZlbnQuZGF0YS5nZXQoXCJ2b2x1bWVcIikpe1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvdCB3YXMgY2xvc2UgZW5vdWdoIHRvIGhlYXIsIGdvIHRvIHRoZSBhbGVydCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXRPYmogPSB7dGFyZ2V0OiBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoRW5lbXlTdGF0ZXMuQUxFUlQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gZW5lbXkgaW4gdGhlIHBhdHJvbCBzdGF0ZSBzaG91bGQgbW92ZSBhbG9uZyBpdHMgcm91dGUuXHJcbiAgICAgKiBUaGUgcm91dGUgaXMgZ2l2ZW4gdG8gdGhpcyBzdGF0ZSBpbiBpdHMgY29uc3RydWN0b3IuXHJcbiAgICAgKiBcclxuICAgICAqIFlvdSBtdXN0IGFkZCBpbiByb3V0aW5nIHNvIHRoYXQgdGhlIGVuZW15IHdpbGwgbW92ZSBhbG9uZyBpdHMgcGF0cm9sIHJvdXRlIHdoaWxlIGluIHRoaXMgc3RhdGUuXHJcbiAgICAgKiBUaGUgcGF0cm9sIHJvdXRlIChpbiB0aGlzIGNhc2UpIGlzIGEgc2VyaWVzIG9mIHBvc2l0aW9ucyBpbiB0aGUgd29ybGQgdGhlIGVuZW15IHNob3VsZCBtb3ZlIGJldHdlZW4uXHJcbiAgICAgKiBcclxuICAgICAqIFlvdSBjYW4gYWxzbyBtb2RpZnkgdGhlIG9uRW50ZXIgbWV0aG9kIGlmIHlvdSB3aXNoIHRvLlxyXG4gICAgICogXHJcbiAgICAgKiBGb3IgaW5zcGlyYXRpb24sIGNoZWNrIG91dCB0aGUgR3VhcmQgc3RhdGUsIG9yIGxvb2sgYXQgdGhlIE5hdmlnYXRpb25QYXRoIGNsYXNzIG9yIHRoZSBHYW1lTm9kZSBjbGFzc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZighdGhpcy5jdXJyZW50UGF0aC5pc0RvbmUoKSl7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIubW92ZU9uUGF0aCh0aGlzLnBhcmVudC5zcGVlZCAqIGRlbHRhVCwgdGhpcy5jdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIucm90YXRpb24gPSBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5jdXJyZW50UGF0aC5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMub3duZXIpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5nZXROZXh0UGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgZW5lbXkgc2VlcyB0aGUgcGxheWVyLCBzdGFydCBhdHRhY2tpbmdcclxuICAgICAgICBpZih0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5BVFRBQ0tJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0T2JqO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5leHRQYXRoKCk6IE5hdmlnYXRpb25QYXRoIHtcclxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmdldFBhdGgoaHczX05hbWVzLk5BVk1FU0gsIHRoaXMub3duZXIucG9zaXRpb24sIHRoaXMucGF0cm9sUm91dGVbdGhpcy5yb3V0ZUluZGV4XSk7XHJcbiAgICAgICAgdGhpcy5yb3V0ZUluZGV4ID0gKHRoaXMucm91dGVJbmRleCArIDEpJXRoaXMucGF0cm9sUm91dGUubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBJbnZlbnRvcnlNYW5hZ2VyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JbnZlbnRvcnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBIZWFsdGhwYWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9IZWFsdGhwYWNrXCI7XHJcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9JdGVtXCI7XHJcbmltcG9ydCBXZWFwb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuL0JhdHRsZXJBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyQ29udHJvbGxlciBpbXBsZW1lbnRzIEJhdHRsZXJBSSB7XHJcbiAgICAvLyBGaWVsZHMgZnJvbSBCYXR0bGVyQUlcclxuICAgIGhlYWx0aDogbnVtYmVyO1xyXG5cclxuICAgIC8vIFRoZSBhY3R1YWwgcGxheWVyIHNwcml0ZVxyXG4gICAgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xyXG5cclxuICAgIC8vIFRoZSBpbnZlbnRvcnkgb2YgdGhlIHBsYXllclxyXG4gICAgcHJpdmF0ZSBpbnZlbnRvcnk6IEludmVudG9yeU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIEEgbGlzdCBvZiBpdGVtcyBpbiB0aGUgZ2FtZSB3b3JsZCAqL1xyXG4gICAgcHJpdmF0ZSBpdGVtczogQXJyYXk8SXRlbT47XHJcblxyXG4gICAgLy8gTW92ZW1lbnRcclxuICAgIHByaXZhdGUgZGlyZWN0aW9uOiBWZWMyO1xyXG4gICAgcHJpdmF0ZSBzcGVlZDogbnVtYmVyO1xyXG5cclxuICAgIC8vIEF0dGFja2luZ1xyXG4gICAgcHJpdmF0ZSBsb29rRGlyZWN0aW9uOiBWZWMyO1xyXG5cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gR2V0IHJpZCBvZiBvdXIgcmVmZXJlbmNlIHRvIHRoZSBvd25lclxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm93bmVyO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5sb29rRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xyXG4gICAgICAgIHRoaXMuaGVhbHRoID0gNTtcclxuXHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG9wdGlvbnMuaXRlbXM7XHJcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkgPSBvcHRpb25zLmludmVudG9yeTtcclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBtb3ZlbWVudCBkaXJlY3Rpb25cclxuICAgICAgICBpZiAoSW5wdXQuaXNQcmVzc2VkKFwiZm9yd2FyZFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi55ID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnggPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoSW5wdXQuaXNQcmVzc2VkKFwiYmFja3dhcmRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24ueSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnggPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoSW5wdXQuaXNQcmVzc2VkKFwibGVmdFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi54ID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnkgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoSW5wdXQuaXNQcmVzc2VkKFwicmlnaHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24ueCA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIXRoaXMuZGlyZWN0aW9uLmlzWmVybygpKXtcclxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgcGxheWVyXHJcbiAgICAgICAgICAgIHRoaXMub3duZXIubW92ZSh0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemVkKCkuc2NhbGUodGhpcy5zcGVlZCAqIGRlbHRhVCkpO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFwiV0FMS1wiLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBQbGF5ZXIgaXMgaWRsZVxyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFwiSURMRVwiLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGxvb2sgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5sb29rRGlyZWN0aW9uID0gdGhpcy5vd25lci5wb3NpdGlvbi5kaXJUbyhJbnB1dC5nZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCkpO1xyXG5cclxuICAgICAgICAvLyBTaG9vdCBhIGJ1bGxldFxyXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGl0ZW1cclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmludmVudG9yeS5nZXRJdGVtKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGluIHRoZSBjdXJyZW50IHNsb3QsIHVzZSBpdFxyXG4gICAgICAgICAgICBpZihpdGVtKXtcclxuICAgICAgICAgICAgICAgIGl0ZW0udXNlKHRoaXMub3duZXIsIFwicGxheWVyXCIsIHRoaXMubG9va0RpcmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaXRlbSBpbnN0YW5jZW9mIEhlYWx0aHBhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHVzZWQgaGVhbHRocGFja1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52ZW50b3J5LnJlbW92ZUl0ZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgcGxheWVyXHJcbiAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyh0aGlzLmxvb2tEaXJlY3Rpb24pO1xyXG5cclxuICAgICAgICAvLyBJbnZlbnRvcnlcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNsb3QgY2hhbmdlXHJcbiAgICAgICAgaWYoSW5wdXQuaXNKdXN0UHJlc3NlZChcInNsb3QxXCIpKXtcclxuICAgICAgICAgICAgdGhpcy5pbnZlbnRvcnkuY2hhbmdlU2xvdCgwKTtcclxuICAgICAgICB9IGVsc2UgaWYoSW5wdXQuaXNKdXN0UHJlc3NlZChcInNsb3QyXCIpKXtcclxuICAgICAgICAgICAgdGhpcy5pbnZlbnRvcnkuY2hhbmdlU2xvdCgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoSW5wdXQuaXNKdXN0UHJlc3NlZChcInBpY2t1cFwiKSl7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFuIGl0ZW0gdG8gcGljayB1cFxyXG4gICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm93bmVyLmNvbGxpc2lvblNoYXBlLm92ZXJsYXBzKGl0ZW0uc3ByaXRlLmJvdW5kYXJ5KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb3ZlcmxhcCBpdCwgdHJ5IHRvIHBpY2sgaXQgdXBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmVudG9yeS5hZGRJdGVtKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihJbnB1dC5pc0p1c3RQcmVzc2VkKFwiZHJvcFwiKSl7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBkcm9wIG91ciBjdXJyZW50IGl0ZW1cclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmludmVudG9yeS5yZW1vdmVJdGVtKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihpdGVtKXtcclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgdWkgdG8gdGhlIGdhbWV3b3JsZFxyXG4gICAgICAgICAgICAgICAgaXRlbS5tb3ZlU3ByaXRlKHRoaXMub3duZXIucG9zaXRpb24sIFwicHJpbWFyeVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGl0ZW0gdG8gdGhlIGxpc3Qgb2YgaXRlbXNcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkYW1hZ2UoZGFtYWdlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaGVhbHRoIDw9IDApe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdhbWUgT3ZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgV2VhcG9uIGZyb20gXCIuL2l0ZW1zL1dlYXBvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmF0dGxlTWFuYWdlciB7XHJcbiAgICBwbGF5ZXI6IEJhdHRsZXJBSTtcclxuXHJcbiAgICBlbmVtaWVzOiBBcnJheTxCYXR0bGVyQUk+O1xyXG5cclxuICAgIGhhbmRsZUludGVyYWN0aW9uKGF0dGFja2VyVHlwZTogc3RyaW5nLCB3ZWFwb246IFdlYXBvbil7XHJcbiAgICAgICAgaWYoYXR0YWNrZXJUeXBlID09PSBcInBsYXllclwiKXtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aCBlbmVtaWVzXHJcbiAgICAgICAgICAgIGZvcihsZXQgZW5lbXkgb2YgdGhpcy5lbmVtaWVzKXtcclxuICAgICAgICAgICAgICAgIGlmKHdlYXBvbi5oaXRzKGVuZW15Lm93bmVyKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkuZGFtYWdlKHdlYXBvbi50eXBlLmRhbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9uIHdpdGggcGxheWVyXHJcbiAgICAgICAgICAgIGlmKHdlYXBvbi5oaXRzKHRoaXMucGxheWVyLm93bmVyKSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5kYW1hZ2Uod2VhcG9uLnR5cGUuZGFtYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRQbGF5ZXIocGxheWVyOiBCYXR0bGVyQUkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRFbmVtaWVzKGVuZW1pZXM6IEFycmF5PEJhdHRsZXJBST4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmVuZW1pZXMgPSBlbmVtaWVzO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vaXRlbXMvSXRlbVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52ZW50b3J5TWFuYWdlciB7XHJcblxyXG4gICAgcHJpdmF0ZSBwb3NpdGlvbjogVmVjMjtcclxuICAgIHByaXZhdGUgaXRlbXM6IEFycmF5PEl0ZW0+O1xyXG4gICAgcHJpdmF0ZSBpbnZlbnRvcnlTbG90czogQXJyYXk8U3ByaXRlPjtcclxuICAgIHByaXZhdGUgc2xvdFNpemU6IFZlYzI7XHJcbiAgICBwcml2YXRlIHBhZGRpbmc6IG51bWJlcjtcclxuICAgIHByaXZhdGUgY3VycmVudFNsb3Q6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc2xvdExheWVyOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGl0ZW1MYXllcjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBzZWxlY3RlZFNsb3Q6IFJlY3Q7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBzaXplOiBudW1iZXIsIGludmVudG9yeVNsb3Q6IHN0cmluZywgcG9zaXRpb246IFZlYzIsIHBhZGRpbmc6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheShzaXplKTtcclxuICAgICAgICB0aGlzLmludmVudG9yeVNsb3RzID0gbmV3IEFycmF5KHNpemUpO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNsb3QgPSAwO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGF5ZXJzXHJcbiAgICAgICAgdGhpcy5zbG90TGF5ZXIgPSBcInNsb3RzXCI7XHJcbiAgICAgICAgc2NlbmUuYWRkVUlMYXllcih0aGlzLnNsb3RMYXllcikuc2V0RGVwdGgoMTAwKTtcclxuICAgICAgICB0aGlzLml0ZW1MYXllciA9IFwiaXRlbXNcIjtcclxuICAgICAgICBzY2VuZS5hZGRVSUxheWVyKHRoaXMuaXRlbUxheWVyKS5zZXREZXB0aCgxMDEpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGludmVudG9yeSBzbG90c1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xyXG4gICAgICAgICAgICB0aGlzLmludmVudG9yeVNsb3RzW2ldID0gc2NlbmUuYWRkLnNwcml0ZShpbnZlbnRvcnlTbG90LCB0aGlzLnNsb3RMYXllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNsb3RTaXplID0gdGhpcy5pbnZlbnRvcnlTbG90c1swXS5zaXplLmNsb25lKCk7XHJcblxyXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBpbnZlbnRvcnkgc2xvdHNcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcclxuICAgICAgICAgICAgdGhpcy5pbnZlbnRvcnlTbG90c1tpXS5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCArIGkqKHRoaXMuc2xvdFNpemUueCArIHRoaXMucGFkZGluZyksIHBvc2l0aW9uLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgcmVjdCBmb3IgdGhlIHNlbGVjdGVkIHNsb3RcclxuICAgICAgICB0aGlzLnNlbGVjdGVkU2xvdCA9IDxSZWN0PnNjZW5lLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLlJFQ1QsIFwic2xvdHNcIiwge3Bvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLmNsb25lKCksIHNpemU6IHRoaXMuc2xvdFNpemUuY2xvbmUoKS5pbmMoLTIpfSk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFNsb3QuY29sb3IgPSBDb2xvci5XSElURTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkU2xvdC5jb2xvci5hID0gMC4yO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEl0ZW0oKTogSXRlbSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50U2xvdF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2xvdFxyXG4gICAgICovXHJcbiAgICBjaGFuZ2VTbG90KHNsb3Q6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNsb3QgPSBzbG90O1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTbG90LnBvc2l0aW9uLmNvcHkodGhpcy5pbnZlbnRvcnlTbG90c1tzbG90XS5wb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2xvdFxyXG4gICAgICovXHJcbiAgICBnZXRTbG90KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNsb3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzbG90XHJcbiAgICAgKi9cclxuICAgIGFkZEl0ZW0oaXRlbTogSXRlbSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKCF0aGlzLml0ZW1zW3RoaXMuY3VycmVudFNsb3RdKXtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBpdGVtIHRvIHRoZSBpbnZlbnRvcnlcclxuICAgICAgICAgICAgdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRTbG90XSA9IGl0ZW07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGd1aVxyXG4gICAgICAgICAgICBpdGVtLm1vdmVTcHJpdGUobmV3IFZlYzIodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5jdXJyZW50U2xvdCoodGhpcy5zbG90U2l6ZS54ICsgdGhpcy5wYWRkaW5nKSwgdGhpcy5wb3NpdGlvbi55KSwgdGhpcy5pdGVtTGF5ZXIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZhaWxlZCB0byBhZGQgaXRlbSwgc29tZXRoaW5nIHdhcyBhbHJlYWR5IGluIHRoZSBzbG90XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyBhbiBpdGVtIGZyb20gdGhlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2xvdCwgaWYgcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlSXRlbSgpOiBJdGVtIHtcclxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50U2xvdF07XHJcblxyXG4gICAgICAgIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50U2xvdF0gPSBudWxsO1xyXG5cclxuICAgICAgICBpZihpdGVtKXtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi8uLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vSXRlbVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhbHRocGFjayBleHRlbmRzIEl0ZW0ge1xyXG4gICAgXHJcbiAgICB1c2UodXNlcjogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAoPEJhdHRsZXJBST51c2VyLl9haSkuaGVhbHRoICs9IDE7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgSXRlbSB7XHJcbiAgICAvKiogVGhlIHNwcml0ZSB0aGF0IHJlcHJlc2VudHMgdGhpcyB3ZWFwb24gaW4gdGhlIHdvcmxkIG9yIGluIGFuIGludmVudG9yeSAqL1xyXG4gICAgc3ByaXRlOiBTcHJpdGU7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlOiBTcHJpdGUpe1xyXG4gICAgICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG4gICAgfVxyXG5cclxuICAgIG1vdmVTcHJpdGUocG9zaXRpb246IFZlYzIsIGxheWVyPzogc3RyaW5nKXtcclxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGxheWVyIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmKGxheWVyKXtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRMYXllciA9IHRoaXMuc3ByaXRlLmdldExheWVyKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRMYXllci5yZW1vdmVOb2RlKHRoaXMuc3ByaXRlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0xheWVyID0gdGhpcy5zcHJpdGUuZ2V0U2NlbmUoKS5nZXRMYXllcihsYXllcik7XHJcbiAgICAgICAgICAgIG5ld0xheWVyLmFkZE5vZGUodGhpcy5zcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5zZXRMYXllcihuZXdMYXllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb3ZlIHRoZSBzcHJpdGVcclxuICAgICAgICB0aGlzLnNwcml0ZS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBhYnN0cmFjdCB1c2UodXNlcjogR2FtZU5vZGUsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcclxuaW1wb3J0IHsgaHczX0V2ZW50cyB9IGZyb20gXCIuLi8uLi9odzNfY29uc3RhbnRzXCI7XHJcbmltcG9ydCBCYXR0bGVNYW5hZ2VyIGZyb20gXCIuLi9CYXR0bGVNYW5hZ2VyXCI7XHJcbmltcG9ydCBJdGVtIGZyb20gXCIuL0l0ZW1cIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4vV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VhcG9uIGV4dGVuZHMgSXRlbSB7XHJcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyB3ZWFwb24gKi9cclxuICAgIHR5cGU6IFdlYXBvblR5cGU7XHJcblxyXG4gICAgLyoqIEEgbGlzdCBvZiBhc3NldHMgdGhpcyB3ZWFwb24gbmVlZHMgdG8gYmUgYW5pbWF0ZWQgKi9cclxuICAgIGFzc2V0czogQXJyYXk8YW55PjtcclxuXHJcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciB0byBob29rIGludG8gdGhlIEV2ZW50UXVldWUgKi9cclxuICAgIGVtaXR0ZXI6IEVtaXR0ZXJcclxuXHJcbiAgICAvKiogVGhlIGJhdHRsZSBtYW5hZ2VyICovXHJcbiAgICBiYXR0bGVNYW5hZ2VyOiBCYXR0bGVNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgY29vbGRvd24gdGltZXIgZm9yIHRoaXMgd2VhcG9uJ3MgdXNlICovXHJcbiAgICBjb29sZG93blRpbWVyOiBUaW1lcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSwgdHlwZTogV2VhcG9uVHlwZSwgYmF0dGxlTWFuYWdlcjogQmF0dGxlTWFuYWdlcil7XHJcbiAgICAgICAgc3VwZXIoc3ByaXRlKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB3ZWFwb24gdHlwZVxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHNwcml0ZSBvZiB0aGlzIHdlYXBvblxyXG4gICAgICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG5cclxuICAgICAgICAvLyBSZWx5IG9uIHRoZSB3ZWFwb24gdHlwZSB0byBjcmVhdGUgYW55IG5lY2Vzc2FyeSBhc3NldHNcclxuICAgICAgICB0aGlzLmFzc2V0cyA9IHRoaXMudHlwZS5jcmVhdGVSZXF1aXJlZEFzc2V0cyh0aGlzLnNwcml0ZS5nZXRTY2VuZSgpKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGVtaXR0ZXJcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAgICAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBiYXR0bGVyIG1hbmFnZXJcclxuICAgICAgICB0aGlzLmJhdHRsZU1hbmFnZXIgPSBiYXR0bGVNYW5hZ2VyO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGNvb2xkb3duIHRpbWVyXHJcbiAgICAgICAgdGhpcy5jb29sZG93blRpbWVyID0gbmV3IFRpbWVyKHR5cGUuY29vbGRvd24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHRoaXMgd2VhcG9uIGluIHRoZSBzcGVjaWZpZWQgZGlyZWN0aW9uLlxyXG4gICAgICogVGhpcyBvbmx5IHdvcmtzIGlmIHRoZSBjb29sZG93biB0aW1lciBoYXMgZW5kZWRcclxuICAgICAqL1xyXG4gICAgdXNlKHVzZXI6IEdhbWVOb2RlLCB1c2VyVHlwZTogc3RyaW5nLCBkaXJlY3Rpb246IFZlYzIpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBJZiB0aGUgY29vbGRvd24gdGltZXIgaXMgc3RpbGwgcnVubmluZywgd2UgY2FuJ3QgdXNlIHRoZSB3ZWFwb25cclxuICAgICAgICBpZighdGhpcy5jb29sZG93blRpbWVyLmlzU3RvcHBlZCgpKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBhIHR5cGUgc3BlY2lmaWMgd2VhcG9uIGFuaW1hdGlvblxyXG4gICAgICAgIHRoaXMudHlwZS5kb0FuaW1hdGlvbih1c2VyLCBkaXJlY3Rpb24sIC4uLnRoaXMuYXNzZXRzKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgZGFtYWdlXHJcbiAgICAgICAgdGhpcy5iYXR0bGVNYW5hZ2VyLmhhbmRsZUludGVyYWN0aW9uKHVzZXJUeXBlLCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBvdXQgYW4gZXZlbnQgdG8gYWxlcnQgZW5lbWllc1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoaHczX0V2ZW50cy5TSE9UX0ZJUkVELCB7cG9zaXRpb246IHVzZXIucG9zaXRpb24uY2xvbmUoKSwgdm9sdW1lOiB0aGlzLnR5cGUudXNlVm9sdW1lfSk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZXNldCB0aGUgY29vbGRvd24gdGltZXJcclxuICAgICAgICB0aGlzLmNvb2xkb3duVGltZXIuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNoZWNrIGZvciB3aGV0aGVyIG9yIG5vdCB0aGlzIHdlYXBvbiBoaXQgYSBub2RlXHJcbiAgICAgKi9cclxuICAgIGhpdHMobm9kZTogR2FtZU5vZGUpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmhpdHMobm9kZSwgLi4udGhpcy5hc3NldHMpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlLCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi9XZWFwb25UeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXNlckd1biBleHRlbmRzIFdlYXBvblR5cGUge1xyXG5cclxuICAgIGNvbG9yOiBDb2xvcjtcclxuXHJcbiAgICBpbml0aWFsaXplKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRhbWFnZSA9IG9wdGlvbnMuZGFtYWdlO1xyXG4gICAgICAgIHRoaXMuY29vbGRvd24gPSBvcHRpb25zLmNvb2xkb3duO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBDb2xvci5mcm9tU3RyaW5nSGV4KG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHRpb25zLmRpc3BsYXlOYW1lO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlS2V5ID0gb3B0aW9ucy5zcHJpdGVLZXk7XHJcbiAgICAgICAgdGhpcy51c2VWb2x1bWUgPSBvcHRpb25zLnVzZVZvbHVtZTtcclxuICAgIH1cclxuXHJcbiAgICBkb0FuaW1hdGlvbihzaG9vdGVyOiBHYW1lTm9kZSwgZGlyZWN0aW9uOiBWZWMyLCBsaW5lOiBMaW5lKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gc2hvb3Rlci5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgICAgIGxldCBlbmQgPSBzaG9vdGVyLnBvc2l0aW9uLmNsb25lKCkuYWRkKGRpcmVjdGlvbi5zY2FsZWQoOTAwKSk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gZW5kLmNsb25lKCkuc3ViKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihzdGFydC54LCBlbmQueCk7XHJcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBlbmQueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBlbmQueSk7XHJcbiAgICAgICAgbGV0IG1heFkgPSBNYXRoLm1heChzdGFydC55LCBlbmQueSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHdhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnNob290ZXIuZ2V0U2NlbmUoKS5nZXRMYXllcihcIldhbGxcIikuZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWluWCwgbWluWSkpO1xyXG5cdFx0bGV0IG1heEluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWF4WCwgbWF4WSkpO1xyXG5cclxuICAgICAgICBsZXQgdGlsZVNpemUgPSB3YWxscy5nZXRUaWxlU2l6ZSgpO1xyXG5cclxuICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XHJcbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gbWluSW5kZXgueTsgcm93IDw9IG1heEluZGV4Lnk7IHJvdysrKXtcclxuICAgICAgICAgICAgICAgIGlmKHdhbGxzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLngvMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkvMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlkZXIgPSBuZXcgQUFCQih0aWxlUG9zLCB0aWxlU2l6ZS5zY2FsZWQoMS8yKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb2xsaWRlci5pbnRlcnNlY3RTZWdtZW50KHN0YXJ0LCBkZWx0YSwgVmVjMi5aRVJPKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGl0ICE9PSBudWxsICYmIHN0YXJ0LmRpc3RhbmNlU3FUbyhoaXQucG9zKSA8IHN0YXJ0LmRpc3RhbmNlU3FUbyhlbmQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBoaXRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGhpdC5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaW5lLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgbGluZS5lbmQgPSBlbmQ7XHJcblxyXG4gICAgICAgIGxpbmUudHdlZW5zLnBsYXkoXCJmYWRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVJlcXVpcmVkQXNzZXRzKHNjZW5lOiBTY2VuZSk6IFtMaW5lXSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSA8TGluZT5zY2VuZS5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcInByaW1hcnlcIiwge3N0YXJ0OiBuZXcgVmVjMigtMSwgMSksIGVuZDogbmV3IFZlYzIoLTEsIC0xKX0pO1xyXG4gICAgICAgIGxpbmUuY29sb3IgPSB0aGlzLmNvbG9yO1xyXG5cclxuICAgICAgICBsaW5lLnR3ZWVucy5hZGQoXCJmYWRlXCIsIHtcclxuICAgICAgICAgICAgc3RhcnREZWxheTogMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcclxuICAgICAgICAgICAgZWZmZWN0czogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtsaW5lXTtcclxuICAgIH1cclxuXHJcbiAgICBoaXRzKG5vZGU6IEdhbWVOb2RlLCBsaW5lOiBMaW5lKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaW50ZXJzZWN0U2VnbWVudChsaW5lLnN0YXJ0LCBsaW5lLmVuZC5jbG9uZSgpLnN1YihsaW5lLnN0YXJ0KSkgIT09IG51bGw7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUsIHsgVHdlZW5hYmxlUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IExpbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcbmltcG9ydCBXZWFwb25UeXBlIGZyb20gXCIuL1dlYXBvblR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbWlBdXRvR3VuIGV4dGVuZHMgV2VhcG9uVHlwZSB7XHJcblxyXG4gICAgY29sb3I6IENvbG9yO1xyXG5cclxuICAgIGluaXRpYWxpemUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGFtYWdlID0gb3B0aW9ucy5kYW1hZ2U7XHJcbiAgICAgICAgdGhpcy5jb29sZG93biA9IG9wdGlvbnMuY29vbGRvd247XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLmZyb21TdHJpbmdIZXgob3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IG9wdGlvbnMuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVLZXkgPSBvcHRpb25zLnNwcml0ZUtleTtcclxuICAgICAgICB0aGlzLnVzZVZvbHVtZSA9IG9wdGlvbnMudXNlVm9sdW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGRvQW5pbWF0aW9uKHNob290ZXI6IEdhbWVOb2RlLCBkaXJlY3Rpb246IFZlYzIsIGxpbmU6IExpbmUpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBzaG9vdGVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGVuZCA9IHNob290ZXIucG9zaXRpb24uY2xvbmUoKS5hZGQoZGlyZWN0aW9uLnNjYWxlZCg5MDApKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSBlbmQuY2xvbmUoKS5zdWIoc3RhcnQpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHRpbGVtYXAgcmVnaW9uIHVudGlsIHdlIGZpbmQgYSBjb2xsaXNpb25cclxuICAgICAgICBsZXQgbWluWCA9IE1hdGgubWluKHN0YXJ0LngsIGVuZC54KTtcclxuICAgICAgICBsZXQgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIGVuZC54KTtcclxuICAgICAgICBsZXQgbWluWSA9IE1hdGgubWluKHN0YXJ0LnksIGVuZC55KTtcclxuICAgICAgICBsZXQgbWF4WSA9IE1hdGgubWF4KHN0YXJ0LnksIGVuZC55KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3YWxsIHRpbGVtYXBcclxuICAgICAgICBsZXQgd2FsbHMgPSA8T3J0aG9nb25hbFRpbGVtYXA+c2hvb3Rlci5nZXRTY2VuZSgpLmdldExheWVyKFwiV2FsbFwiKS5nZXRJdGVtcygpWzBdO1xyXG5cclxuICAgICAgICBsZXQgbWluSW5kZXggPSB3YWxscy5nZXRDb2xSb3dBdChuZXcgVmVjMihtaW5YLCBtaW5ZKSk7XHJcblx0XHRsZXQgbWF4SW5kZXggPSB3YWxscy5nZXRDb2xSb3dBdChuZXcgVmVjMihtYXhYLCBtYXhZKSk7XHJcblxyXG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHdhbGxzLmdldFRpbGVTaXplKCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgY29sID0gbWluSW5kZXgueDsgY29sIDw9IG1heEluZGV4Lng7IGNvbCsrKXtcclxuICAgICAgICAgICAgZm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xyXG4gICAgICAgICAgICAgICAgaWYod2FsbHMuaXNUaWxlQ29sbGlkYWJsZShjb2wsIHJvdykpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGVQb3MgPSBuZXcgVmVjMihjb2wgKiB0aWxlU2l6ZS54ICsgdGlsZVNpemUueC8yLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueS8yKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xsaWRlciA9IG5ldyBBQUJCKHRpbGVQb3MsIHRpbGVTaXplLnNjYWxlZCgxLzIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhpdCA9IGNvbGxpZGVyLmludGVyc2VjdFNlZ21lbnQoc3RhcnQsIGRlbHRhLCBWZWMyLlpFUk8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihoaXQgIT09IG51bGwgJiYgc3RhcnQuZGlzdGFuY2VTcVRvKGhpdC5wb3MpIDwgc3RhcnQuZGlzdGFuY2VTcVRvKGVuZCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIGhpdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaGl0LnBvcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmUuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICBsaW5lLmVuZCA9IGVuZDtcclxuICAgICAgICBsaW5lLnR3ZWVucy5wbGF5KFwiZmFkZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBbTGluZV0ge1xyXG4gICAgICAgIGxldCBsaW5lID0gPExpbmU+c2NlbmUuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJwcmltYXJ5XCIsIHtzdGFydDogbmV3IFZlYzIoLTEsIDEpLCBlbmQ6IG5ldyBWZWMyKC0xLCAtMSl9KTtcclxuICAgICAgICBsaW5lLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICBsaW5lLnR3ZWVucy5hZGQoXCJmYWRlXCIsIHtcclxuICAgICAgICAgICAgc3RhcnREZWxheTogMCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcclxuICAgICAgICAgICAgZWZmZWN0czogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIG9uRW5kQ2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxpbmUuc3RhcnQgPSBuZXcgVmVjMigtMSwgMSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lLmVuZCA9IG5ldyBWZWMyKC0xLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtsaW5lXTtcclxuICAgIH1cclxuXHJcbiAgICBoaXRzKG5vZGU6IEdhbWVOb2RlLCBsaW5lOiBMaW5lKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaW50ZXJzZWN0U2VnbWVudChsaW5lLnN0YXJ0LCBsaW5lLmVuZC5jbG9uZSgpLnN1YihsaW5lLnN0YXJ0KSkgIT09IG51bGw7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi9XZWFwb25UeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGljZSBleHRlbmRzIFdlYXBvblR5cGUge1xyXG5cclxuICAgIGluaXRpYWxpemUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGFtYWdlID0gb3B0aW9ucy5kYW1hZ2U7XHJcbiAgICAgICAgdGhpcy5jb29sZG93biA9IG9wdGlvbnMuY29vbGRvd247XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IG9wdGlvbnMuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVLZXkgPSBvcHRpb25zLnNwcml0ZUtleTtcclxuICAgICAgICB0aGlzLnVzZVZvbHVtZSA9IG9wdGlvbnMudXNlVm9sdW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGRvQW5pbWF0aW9uKGF0dGFja2VyOiBHYW1lTm9kZSwgZGlyZWN0aW9uOiBWZWMyLCBzbGljZVNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBSb3RhdGUgdGhpcyB3aXRoIHRoZSBnYW1lIG5vZGVcclxuICAgICAgICBzbGljZVNwcml0ZS5yb3RhdGlvbiA9IGF0dGFja2VyLnJvdGF0aW9uO1xyXG5cclxuICAgICAgICAvLyBNb3ZlIHRoZSBzbGljZSBvdXQgZnJvbSB0aGUgcGxheWVyXHJcbiAgICAgICAgc2xpY2VTcHJpdGUucG9zaXRpb24gPSBhdHRhY2tlci5wb3NpdGlvbi5jbG9uZSgpLmFkZChkaXJlY3Rpb24uc2NhbGVkKDE2KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUGxheSB0aGUgc2xpY2UgYW5pbWF0aW9uIHcvbyBsb29wLCBidXQgcXVldWUgdGhlIG5vcm1hbCBhbmltYXRpb25cclxuICAgICAgICBzbGljZVNwcml0ZS5hbmltYXRpb24ucGxheShcIlNMSUNFXCIpO1xyXG4gICAgICAgIHNsaWNlU3ByaXRlLmFuaW1hdGlvbi5xdWV1ZShcIk5PUk1BTFwiLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBbQW5pbWF0ZWRTcHJpdGVdIHtcclxuICAgICAgICBsZXQgc2xpY2UgPSBzY2VuZS5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJzbGljZVwiLCBcInByaW1hcnlcIik7XHJcbiAgICAgICAgc2xpY2UuYW5pbWF0aW9uLnBsYXkoXCJOT1JNQUxcIiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBbc2xpY2VdO1xyXG4gICAgfVxyXG5cclxuICAgIGhpdHMobm9kZTogR2FtZU5vZGUsIHNsaWNlU3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBzbGljZVNwcml0ZS5ib3VuZGFyeS5vdmVybGFwcyhub2RlLmNvbGxpc2lvblNoYXBlKTtcclxuICAgIH1cclxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgV2VhcG9uVHlwZSB7XHJcbiAgICAvKiogVGhlIGtleSBmb3IgdGhpcyBzcHJpdGUgaW1hZ2UgKi9cclxuICAgIHNwcml0ZUtleTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBIb3cgbXVjaCBkYW1hZ2UgdGhpcyB3ZWFwb24gZG9lcyAqL1xyXG4gICAgZGFtYWdlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIERpc3BsYXkgbmFtZSAqL1xyXG4gICAgZGlzcGxheU5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKiogVGhlIHVzZSBjb29sZG93biBvZiB0aGUgd2VhcG9uICovXHJcbiAgICBjb29sZG93bjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBIb3cgbG91ZCBpdCBpcyB0byB1c2UgdGhpcyB3ZWFwb24gKi9cclxuICAgIHVzZVZvbHVtZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyB3ZWFwb24gdHlwZSB3aXRoIGRhdGFcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaW5pdGlhbGl6ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbmltYXRpb24gdG8gZG8gd2hlbiB0aGlzIHdlYXBvbiBpcyB1c2VkXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGRvQW5pbWF0aW9uKC4uLmFyZ3M6IGFueSk6IHZvaWQ7XHJcblxyXG4gICAgYWJzdHJhY3QgY3JlYXRlUmVxdWlyZWRBc3NldHMoc2NlbmU6IFNjZW5lKTogQXJyYXk8YW55PjtcclxuXHJcbiAgICBhYnN0cmFjdCBoaXRzKG5vZGU6IEdhbWVOb2RlLCAuLi5hcmdzOiBhbnkpOiBib29sZWFuO1xyXG59IiwiaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IExhc2VyR3VuIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25UeXBlcy9MYXNlckd1blwiO1xyXG5pbXBvcnQgU2VtaUF1dG9HdW4gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1NlbWlBdXRvR3VuXCI7XHJcbmltcG9ydCBTbGljZSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvV2VhcG9uVHlwZXMvU2xpY2VcIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1dlYXBvblR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYXBvblRlbXBsYXRlUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxXZWFwb25Db25zdHJ1Y3Rvcj4ge1xyXG4gICAgXHJcbiAgICBwdWJsaWMgcHJlbG9hZCgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBybSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHNwcml0ZXNcclxuICAgICAgICBybS5pbWFnZShcInBpc3RvbFwiLCBcImh3M19hc3NldHMvc3ByaXRlcy9waXN0b2wucG5nXCIpO1xyXG4gICAgICAgIHJtLmltYWdlKFwia25pZmVcIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXMva25pZmUucG5nXCIpO1xyXG4gICAgICAgIHJtLmltYWdlKFwibGFzZXJndW5cIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXMvbGFzZXJndW4ucG5nXCIpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHNwcml0ZXNoZWV0c1xyXG4gICAgICAgIHJtLnNwcml0ZXNoZWV0KFwic2xpY2VcIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXNoZWV0cy9zbGljZS5qc29uXCIpO1xyXG5cclxuICAgICAgICAvLyBSZWdpc3RlciBkZWZhdWx0IHR5cGVzXHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlckl0ZW0oXCJzbGljZVwiLCBTbGljZSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKFwic2VtaUF1dG9HdW5cIiwgU2VtaUF1dG9HdW4pO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKFwibGFzZXJHdW5cIiwgTGFzZXJHdW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdlIGRvbid0IG5lZWQgdGhpcyBmb3IgdGhpcyBhc3NpZ25tZW50XHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge31cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IFdlYXBvbkNvbnN0cnVjdG9yKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hZGQoa2V5LCBjb25zdHIpO1xyXG4gICAgfVxyXG59XHJcblxyXG50eXBlIFdlYXBvbkNvbnN0cnVjdG9yID0gbmV3ICguLi5hcmdzOiBhbnkpID0+IFdlYXBvblR5cGU7IiwiaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XHJcbmltcG9ydCBXZWFwb25UeXBlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9pdGVtcy9XZWFwb25UeXBlcy9XZWFwb25UeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFwb25UeXBlUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxXZWFwb25UeXBlPiB7XHJcbiAgICBcclxuICAgIHB1YmxpYyBwcmVsb2FkKCk6IHZvaWQge31cclxuXHJcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRoaXMgZm9yIHRoaXMgYXNzaWdubWVudFxyXG4gICAgcHVibGljIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHt9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgdHlwZTogV2VhcG9uVHlwZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWRkKGtleSwgdHlwZSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU92ZXIgZXh0ZW5kcyBTY2VuZSB7XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpIHtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoXCJwcmltYXJ5XCIpO1xyXG5cclxuICAgICAgICBjb25zdCBnYW1lT3ZlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJwcmltYXJ5XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSwgdGV4dDogXCJHYW1lIE92ZXJcIn0pO1xyXG4gICAgICAgIGdhbWVPdmVyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL0xheWVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IGh3M19zY2VuZSBmcm9tIFwiLi9odzNfc2NlbmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5NZW51IGV4dGVuZHMgU2NlbmUge1xyXG4gICAgLy8gTGF5ZXJzLCBmb3IgbXVsdGlwbGUgbWFpbiBtZW51IHNjcmVlbnNcclxuICAgIHByaXZhdGUgbWFpbk1lbnU6IExheWVyO1xyXG4gICAgcHJpdmF0ZSBhYm91dDogTGF5ZXI7XHJcbiAgICBwcml2YXRlIGNvbnRyb2xzOiBMYXllcjtcclxuXHJcbiAgICBsb2FkU2NlbmUoKXt9XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpe1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudmlld3BvcnQuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBtYWluIG1lbnVcclxuICAgICAgICB0aGlzLm1haW5NZW51ID0gdGhpcy5hZGRVSUxheWVyKFwibWFpbk1lbnVcIik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBwbGF5IGJ1dHRvbiwgYW5kIGdpdmUgaXQgYW4gZXZlbnQgdG8gZW1pdCBvbiBwcmVzc1xyXG4gICAgICAgIGNvbnN0IHBsYXkgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLCB0ZXh0OiBcIlBsYXlcIn0pO1xyXG4gICAgICAgIHBsYXkuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICAgICAgcGxheS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgcGxheS5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIHBsYXkuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgcGxheS5vbkNsaWNrRXZlbnRJZCA9IFwicGxheVwiO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29udHJvbCBidXR0b25cclxuICAgICAgICBjb25zdCBjb250cm9scyA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IFwiQ29udHJvbHNcIn0pO1xyXG4gICAgICAgIGNvbnRyb2xzLnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgICAgIGNvbnRyb2xzLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBjb250cm9scy5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIGNvbnRyb2xzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGNvbnRyb2xzLm9uQ2xpY2tFdmVudElkID0gXCJjb250cm9sc1wiO1xyXG5cclxuICAgICAgICAvLyBBZGQgZXZlbnQgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgYWJvdXQgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAxMDApLCB0ZXh0OiBcIkFib3V0XCJ9KTtcclxuICAgICAgICBhYm91dC5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBhYm91dC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgYWJvdXQuYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgICAgICBhYm91dC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBhYm91dC5vbkNsaWNrRXZlbnRJZCA9IFwiYWJvdXRcIjtcclxuXHJcbiAgICAgICAgLyogIyMjIyMjIyMjIyBDT05UUk9MUyBTQ1JFRU4gIyMjIyMjIyMjIyAqL1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLmFkZFVJTGF5ZXIoXCJjb250cm9sc1wiKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAyNTApLCB0ZXh0OiBcIkNvbnRyb2xzXCJ9KTtcclxuICAgICAgICBjb250cm9sc0hlYWRlci50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNUZXh0MSA9IFwiV0FTRCB0byBtb3ZlXCI7XHJcbiAgICAgICAgY29uc3QgY29udHJvbHNUZXh0MiA9IFwiUSB0byBkcm9wIGFuIGl0ZW1cIjtcclxuICAgICAgICBjb25zdCBjb250cm9sc1RleHQzID0gXCJFIHRvIHBpY2sgdXAgYW4gaXRlbVwiO1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzVGV4dDQgPSBcIkNsaWNrIHRvIHVzZSBjdXJyZW50IGl0ZW1cIjtcclxuICAgICAgICBjb25zdCBjb250cm9sc1RleHQ1ID0gXCIxJjIgdG8gY2hhbmdlIGl0ZW1zXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzTGluZTEgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLCB0ZXh0OiBjb250cm9sc1RleHQxfSk7XHJcbiAgICAgICAgY29uc3QgY29udHJvbHNMaW5lMiA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDUwKSwgdGV4dDogY29udHJvbHNUZXh0Mn0pO1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzTGluZTMgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkpLCB0ZXh0OiBjb250cm9sc1RleHQzfSk7XHJcbiAgICAgICAgY29uc3QgY29udHJvbHNMaW5lNCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDUwKSwgdGV4dDogY29udHJvbHNUZXh0NH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzTGluZTUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAxMDApLCB0ZXh0OiBjb250cm9sc1RleHQ1fSk7XHJcblxyXG4gICAgICAgIGNvbnRyb2xzTGluZTEudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICAgICAgY29udHJvbHNMaW5lMi50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuICAgICAgICBjb250cm9sc0xpbmUzLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIGNvbnRyb2xzTGluZTQudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICAgICAgY29udHJvbHNMaW5lNS50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNCYWNrID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImNvbnRyb2xzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMjUwKSwgdGV4dDogXCJCYWNrXCJ9KTtcclxuICAgICAgICBjb250cm9sc0JhY2suc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICAgICAgY29udHJvbHNCYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBjb250cm9sc0JhY2suYm9yZGVyQ29sb3IgPSBDb2xvci5XSElURTtcclxuICAgICAgICBjb250cm9sc0JhY2suYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29udHJvbHNCYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtZW51XCI7XHJcblxyXG4gICAgICAgIC8qICMjIyMjIyMjIyMgQUJPVVQgU0NSRUVOICMjIyMjIyMjIyMgKi9cclxuICAgICAgICB0aGlzLmFib3V0ID0gdGhpcy5hZGRVSUxheWVyKFwiYWJvdXRcIik7XHJcbiAgICAgICAgdGhpcy5hYm91dC5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFib3V0SGVhZGVyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImFib3V0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSwgdGV4dDogXCJBYm91dFwifSk7XHJcbiAgICAgICAgYWJvdXRIZWFkZXIudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHQxID0gXCJUaGlzIGdhbWUgd2FzIGNyZWF0ZWQgYnkgQWxleCBGZW5nLCBKb2UgV2VhdmVyLCBhbmQgUmljaGFyZCBNY0tlbm5hXCI7XHJcbiAgICAgICAgY29uc3QgdGV4dDIgPSBcInVzaW5nIHRoZSBXb2xmaWUyRCBnYW1lIGVuZ2luZSwgYSBUeXBlU2NyaXB0IGdhbWUgZW5naW5lIGNyZWF0ZWQgYnlcIjtcclxuICAgICAgICBjb25zdCB0ZXh0MyA9IFwiSm9lIFdlYXZlciBhbmQgUmljaGFyZCBNY0tlbm5hLlwiO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5lMSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDUwKSwgdGV4dDogdGV4dDF9KTtcclxuICAgICAgICBjb25zdCBsaW5lMiA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IHRleHQyfSk7XHJcbiAgICAgICAgY29uc3QgbGluZTMgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiYWJvdXRcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyA1MCksIHRleHQ6IHRleHQzfSk7XHJcblxyXG4gICAgICAgIGxpbmUxLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIGxpbmUyLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIGxpbmUzLnRleHRDb2xvciA9IENvbG9yLldISVRFO1xyXG5cclxuICAgICAgICBjb25zdCBhYm91dEJhY2sgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiYWJvdXRcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAyNTApLCB0ZXh0OiBcIkJhY2tcIn0pO1xyXG4gICAgICAgIGFib3V0QmFjay5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBhYm91dEJhY2suYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGFib3V0QmFjay5ib3JkZXJDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgICAgIGFib3V0QmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBhYm91dEJhY2sub25DbGlja0V2ZW50SWQgPSBcIm1lbnVcIjtcclxuXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBidXR0b24gZXZlbnRzXHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJwbGF5XCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiYWJvdXRcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJtZW51XCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY29udHJvbHNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2NlbmUoKXtcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcInBsYXlcIil7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2NlbmVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBoeXNpY3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBOYW1lczogW1wiZ3JvdW5kXCIsIFwicGxheWVyXCIsIFwiZW5lbXlcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoaHczX3NjZW5lLCB7fSwgc2NlbmVPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJjb250cm9sc1wiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbk1lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImFib3V0XCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hYm91dC5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluTWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibWVudVwiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbk1lbnUuc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWJvdXQuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgUGxheWVyQ29udHJvbGxlciBmcm9tIFwiLi4vQUkvUGxheWVyQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xyXG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xyXG5pbXBvcnQge2h3M19OYW1lc30gZnJvbSBcIi4uL2h3M19jb25zdGFudHNcIjtcclxuaW1wb3J0IEVuZW15QUkgZnJvbSBcIi4uL0FJL0VuZW15QUlcIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblR5cGVzL1dlYXBvblR5cGVcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vLi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWFwb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL2l0ZW1zL1dlYXBvblwiO1xyXG5pbXBvcnQgSGVhbHRocGFjayBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvSGVhbHRocGFja1wiO1xyXG5pbXBvcnQgSW52ZW50b3J5TWFuYWdlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSW52ZW50b3J5TWFuYWdlclwiO1xyXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvaXRlbXMvSXRlbVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBCYXR0bGVNYW5hZ2VyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVNYW5hZ2VyXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uL0FJL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgR2FtZU92ZXIgZnJvbSBcIi4vR2FtZU92ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGh3M19zY2VuZSBleHRlbmRzIFNjZW5lIHtcclxuICAgIC8vIFRoZSBwbGF5ZXJcclxuICAgIHByaXZhdGUgcGxheWVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvLyBBIGxpc3Qgb2YgZW5lbWllc1xyXG4gICAgcHJpdmF0ZSBlbmVtaWVzOiBBcnJheTxBbmltYXRlZFNwcml0ZT47XHJcblxyXG4gICAgLy8gVGhlIHdhbGwgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgdG8gdXNlIGZvciBidWxsZXQgdmlzdWFsaXphdGlvblxyXG4gICAgcHJpdmF0ZSB3YWxsczogT3J0aG9nb25hbFRpbGVtYXA7XHJcblxyXG4gICAgLy8gVGhlIHBvc2l0aW9uIGdyYXBoIGZvciB0aGUgbmF2bWVzaFxyXG4gICAgcHJpdmF0ZSBncmFwaDogUG9zaXRpb25HcmFwaDtcclxuXHJcbiAgICAvLyBBIGxpc3Qgb2YgaXRlbXMgaW4gdGhlIHNjZW5lXHJcbiAgICBwcml2YXRlIGl0ZW1zOiBBcnJheTxJdGVtPjtcclxuXHJcbiAgICAvLyBUaGUgYmF0dGxlIG1hbmFnZXIgZm9yIHRoZSBzY2VuZVxyXG4gICAgcHJpdmF0ZSBiYXR0bGVNYW5hZ2VyOiBCYXR0bGVNYW5hZ2VyO1xyXG5cclxuICAgIC8vIFBsYXllciBoZWFsdGhcclxuICAgIHByaXZhdGUgaGVhbHRoRGlzcGxheTogTGFiZWw7XHJcblxyXG4gICAgbG9hZFNjZW5lKCl7XHJcbiAgICAgICAgLy8gTG9hZCB0aGUgcGxheWVyIGFuZCBlbmVteSBzcHJpdGVzaGVldHNcclxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJwbGF5ZXJcIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXNoZWV0cy9wbGF5ZXIuanNvblwiKTtcclxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJlbmVteVwiLCBcImh3M19hc3NldHMvc3ByaXRlc2hlZXRzL2VuZW15Lmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwic2xpY2VcIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXNoZWV0cy9zbGljZS5qc29uXCIpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgLy8gSE9NRVdPUksgMyAtIFRPRE9cclxuICAgICAgICAvLyBDaGFuZ2UgdGhpcyBmaWxlIHRvIGJlIHlvdXIgb3duIHRpbGVtYXBcclxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImxldmVsXCIsIFwiaHczX2Fzc2V0cy90aWxlbWFwcy9hbGV4LWZlbmctaHczLmpzb25cIik7XHJcblxyXG4gICAgICAgIC8vIExvYWQgdGhlIHNjZW5lIGluZm9cclxuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwid2VhcG9uRGF0YVwiLCBcImh3M19hc3NldHMvZGF0YS93ZWFwb25EYXRhLmpzb25cIik7XHJcblxyXG4gICAgICAgIC8vIExvYWQgdGhlIG5hdiBtZXNoXHJcbiAgICAgICAgdGhpcy5sb2FkLm9iamVjdChcIm5hdm1lc2hcIiwgXCJodzNfYXNzZXRzL2RhdGEvbmF2bWVzaC5qc29uXCIpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIGluIHRoZSBlbmVteSBpbmZvXHJcbiAgICAgICAgdGhpcy5sb2FkLm9iamVjdChcImVuZW15RGF0YVwiLCBcImh3M19hc3NldHMvZGF0YS9lbmVteS5qc29uXCIpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIGluIGl0ZW0gaW5mb1xyXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJpdGVtRGF0YVwiLCBcImh3M19hc3NldHMvZGF0YS9pdGVtcy5qc29uXCIpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHRoZSBoZWFsdGhwYWNrIHNwcml0ZVxyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcImhlYWx0aHBhY2tcIiwgXCJodzNfYXNzZXRzL3Nwcml0ZXMvaGVhbHRocGFjay5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaW52ZW50b3J5U2xvdFwiLCBcImh3M19hc3NldHMvc3ByaXRlcy9pbnZlbnRvcnkucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcImtuaWZlXCIsIFwiaHczX2Fzc2V0cy9zcHJpdGVzL2tuaWZlLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJsYXNlcmd1blwiLCBcImh3M19hc3NldHMvc3ByaXRlcy9sYXNlcmd1bi5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwicGlzdG9sXCIsIFwiaHczX2Fzc2V0cy9zcHJpdGVzL3Bpc3RvbC5wbmdcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpe1xyXG4gICAgICAgIC8vIEFkZCBpbiB0aGUgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlbWFwTGF5ZXJzID0gdGhpcy5hZGQudGlsZW1hcChcImxldmVsXCIpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHdhbGwgbGF5ZXJcclxuICAgICAgICAvLyBIT01FV09SSyAzIC0gVE9ET1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIE1vZGlmeSB0aGlzIGxpbmUgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgVGhpcyBsaW5lIGlzIGp1c3QgZ2V0dGluZyB0aGUgd2FsbCBsYXllciBvZiB5b3VyIHRpbGVtYXAgdG8gdXNlIGZvciBzb21lIGNhbGN1bGF0aW9ucy5cclxuICAgICAgICAgICAgTWFrZSBzdXJlIGl0IGlzIHN0aWxsIGRvaW5nIHNvLlxyXG5cclxuICAgICAgICAgICAgV2hhdCB0aGUgbGluZSBpcyBzYXlpbmcgaXMgdG8gZ2V0IHRoZSBmaXJzdCBsZXZlbCBmcm9tIHRoZSBib3R0b20gKHRpbGVtYXBMYXllcnNbMV0pLFxyXG4gICAgICAgICAgICB3aGljaCBpbiBteSBjYXNlIHdhcyB0aGUgV2FsbHMgbGF5ZXIuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRpbGVtYXBMYXllcnNbMV0uZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB2aWV3cG9ydCBib3VuZHMgdG8gdGhlIHRpbGVtYXBcclxuICAgICAgICBsZXQgdGlsZW1hcFNpemU6IFZlYzIgPSB0aGlzLndhbGxzLnNpemU7IFxyXG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIHRpbGVtYXBTaXplLngsIHRpbGVtYXBTaXplLnkpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZExheWVyKFwicHJpbWFyeVwiLCAxMCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgYmF0dGxlIG1hbmFnZXJcclxuICAgICAgICB0aGlzLmJhdHRsZU1hbmFnZXIgPSBuZXcgQmF0dGxlTWFuYWdlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmluaXRpYWxpemVXZWFwb25zKCk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGl0ZW1zIGFycmF5IC0gdGhpcyByZXByZXNlbnRzIGl0ZW1zIHRoYXQgYXJlIGluIHRoZSBnYW1lIHdvcmxkXHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVBsYXllcigpO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHRoZSB2aWV3cG9ydCBmb2xsb3cgdGhlIHBsYXllclxyXG4gICAgICAgIHRoaXMudmlld3BvcnQuZm9sbG93KHRoaXMucGxheWVyKTtcclxuXHJcbiAgICAgICAgLy8gWm9vbSBpbiB0byBhIHJlYXNvbmFibGUgbGV2ZWxcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LmVuYWJsZVpvb20oKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFpvb21MZXZlbCg0KTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuYXZtZXNoXHJcbiAgICAgICAgdGhpcy5jcmVhdGVOYXZtZXNoKCk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIGVuZW1pZXNcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVFbmVtaWVzKCk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgdGhlIHBsYXllciBhbmQgZW5lbWllcyB0byB0aGUgYmF0dGxlIG1hbmFnZXJcclxuICAgICAgICB0aGlzLmJhdHRsZU1hbmFnZXIuc2V0UGxheWVyKDxCYXR0bGVyQUk+dGhpcy5wbGF5ZXIuX2FpKTtcclxuICAgICAgICB0aGlzLmJhdHRsZU1hbmFnZXIuc2V0RW5lbWllcyh0aGlzLmVuZW1pZXMubWFwKGVuZW15ID0+IDxCYXR0bGVyQUk+ZW5lbXkuX2FpKSk7XHJcblxyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byByZWxldmFudCBldmVudHNcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImhlYWx0aHBhY2tcIik7XHJcblxyXG4gICAgICAgIC8vIFNwYXduIGl0ZW1zIGludG8gdGhlIHdvcmxkXHJcbiAgICAgICAgdGhpcy5zcGF3bkl0ZW1zKCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIFVJIGZvciBoZWFsdGhcclxuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoXCJoZWFsdGhcIik7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhbHRoRGlzcGxheSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWFsdGhcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMigyMDAsIDE2KSwgdGV4dDogXCJIZWFsdGg6IFwiICsgKDxCYXR0bGVyQUk+dGhpcy5wbGF5ZXIuX2FpKS5oZWFsdGh9KTtcclxuICAgICAgICB0aGlzLmhlYWx0aERpc3BsYXkudGV4dENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LmlzVHlwZShcImhlYWx0aHBhY2tcIikpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIZWFsdGhwYWNrKGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaGVhbHRoID0gKDxCYXR0bGVyQUk+dGhpcy5wbGF5ZXIuX2FpKS5oZWFsdGg7XHJcblxyXG4gICAgICAgIGlmKGhlYWx0aCA9PT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoR2FtZU92ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGhlYWx0aCBndWlcclxuICAgICAgICB0aGlzLmhlYWx0aERpc3BsYXkudGV4dCA9IFwiSGVhbHRoOiBcIiArIGhlYWx0aDtcclxuXHJcbiAgICAgICAgLy8gRGVidWcgbW9kZSBncmFwaFxyXG4gICAgICAgIGlmKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJnXCIpKXtcclxuICAgICAgICAgICAgdGhpcy5nZXRMYXllcihcImdyYXBoXCIpLnNldEhpZGRlbighdGhpcy5nZXRMYXllcihcImdyYXBoXCIpLmlzSGlkZGVuKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIT01FV09SSyAzIC0gVE9ET1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNwYXducyBpbiBhbGwgb2YgdGhlIGl0ZW1zIGluIFwiaXRlbXMuanNvblwiXHJcbiAgICAgKiBcclxuICAgICAqIFlvdSBzaG91bGRuJ3QgaGF2ZSB0byBwdXQgYW55IG5ldyBjb2RlIGhlcmUsIGhvd2V2ZXIsIHlvdSB3aWxsIGhhdmUgdG8gbW9kaWZ5IGl0ZW1zLmpzb24uXHJcbiAgICAgKiBcclxuICAgICAqIE1ha2Ugc3VyZSB5b3UgYXJlIHNwYXduaW5nIGluIDUgcGlzdG9scyBhbmQgNSBsYXNlciBndW5zIHNvbWV3aGVyZSAoYWNjZXNzaWJsZSkgaW4geW91ciB3b3JsZC5cclxuICAgICAqIFxyXG4gICAgICogWW91J2xsIG5vdGljZSB0aGF0IHJpZ2h0IG5vdywgc29tZSBoZWFsdGhwYWNrcyBhcmUgYWxzbyBzcGF3bmluZyBpbi4gVGhlc2UgYWxzbyBkcm9wIGZyb20gZ3VhcmRzLlxyXG4gICAgICogRmVlbCBmcmVlIHRvIHNwYXduIHNvbWUgaGVhbHRocGFja3MgaWYgeW91IHdhbnQsIG9yIHlvdSBjYW4ganVzdCBsZXQgdGhlIHBsYXllciBzdWZmZXIgPjopXHJcbiAgICAgKi9cclxuICAgIHNwYXduSXRlbXMoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBpdGVtIGRhdGFcclxuICAgICAgICBsZXQgaXRlbURhdGEgPSB0aGlzLmxvYWQuZ2V0T2JqZWN0KFwiaXRlbURhdGFcIik7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaXRlbSBvZiBpdGVtRGF0YS5pdGVtcyl7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0udHlwZSA9PT0gXCJoZWFsdGhwYWNrXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgaGVhbHRocGFja1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIZWFsdGhwYWNrKG5ldyBWZWMyKGl0ZW0ucG9zaXRpb25bMF0sIGl0ZW0ucG9zaXRpb25bMV0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB3ZWFwb24gPSB0aGlzLmNyZWF0ZVdlYXBvbihpdGVtLndlYXBvblR5cGUpO1xyXG4gICAgICAgICAgICAgICAgd2VhcG9uLm1vdmVTcHJpdGUobmV3IFZlYzIoaXRlbS5wb3NpdGlvblswXSwgaXRlbS5wb3NpdGlvblsxXSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHdlYXBvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyB3ZWFwb25cclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB3ZWFwb25UeXBlIG9mIHRoZSB3ZWFwb24sIGFzIGEgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVdlYXBvbih0eXBlOiBzdHJpbmcpOiBXZWFwb24ge1xyXG4gICAgICAgIGxldCB3ZWFwb25UeXBlID0gPFdlYXBvblR5cGU+UmVnaXN0cnlNYW5hZ2VyLmdldFJlZ2lzdHJ5KFwid2VhcG9uVHlwZXNcIikuZ2V0KHR5cGUpO1xyXG4gICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmFkZC5zcHJpdGUod2VhcG9uVHlwZS5zcHJpdGVLZXksIFwicHJpbWFyeVwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBXZWFwb24oc3ByaXRlLCB3ZWFwb25UeXBlLCB0aGlzLmJhdHRsZU1hbmFnZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGhlYWx0aHBhY2sgYXQgYSBjZXJ0YWluIHBvc2l0aW9uIGluIHRoZSB3b3JsZFxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVIZWFsdGhwYWNrKHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZShcImhlYWx0aHBhY2tcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgIGxldCBoZWFsdGhwYWNrID0gbmV3IEhlYWx0aHBhY2soc3ByaXRlKVxyXG4gICAgICAgIGhlYWx0aHBhY2subW92ZVNwcml0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGhlYWx0aHBhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhPTUVXT1JLIDMgLSBUT0RPXHJcbiAgICAvKipcclxuICAgICAqIFlvdSdsbCB3YW50IHRvIGhhdmUgYSBuZXcgd2VhcG9uIHR5cGUgYXZhaWxhYmxlIGluIHlvdXIgcHJvZ3JhbSAtIGEgbGFzZXIgZ3VuLlxyXG4gICAgICogQ2FyZWZ1bGx5IGxvb2sgdGhyb3VnaCB0aGUgY29kZSBmb3IgaG93IHRoZSBvdGhlciB3ZWFwb24gdHlwZXMgKGtuaWZlIGFuZCBwaXN0b2wpXHJcbiAgICAgKiBhcmUgY3JlYXRlZC4gVGhleSdyZSBiYXNlZCBvZiB0aGUgdGVtcGxhdGVzIFNsaWNlIGFuZCBTZW1pQXV0b0d1bi4gWW91IHNob3VsZCB1c2VcclxuICAgICAqIHRoZSBTZW1pQXV0b0d1biB0ZW1wbGF0ZSBmb3IgeW91ciBsYXNlciBndW4uXHJcbiAgICAgKiBcclxuICAgICAqIFRoZSBsYXNlciBndW4gc2hvdWxkIGhhdmUgYSBncmVlbiBiZWFtLCBhbmQgc2hvdWxkIGJlIGNvbnNpZGVyYWJseSBtb3JlIHBvd2VyZnVsIHRoYW5cclxuICAgICAqIGEgcGlzdG9sLiBZb3UgY2FuIGRlY2lkZSBqdXN0IGhvdyBwb3dlcmZ1bCBpdCBpcy5cclxuICAgICAqIFxyXG4gICAgICogTG9vayBpbiB3ZWFwb25EYXRhLmpzb24gZm9yIHNvbWUgaW5zaWdodCBvbiB3aGF0IHRvIGRvIGhlcmUuXHJcbiAgICAgKiBcclxuICAgICAqIExvYWRzIGluIGFsbCB3ZWFwb25zIGZyb20gZmlsZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplV2VhcG9ucygpOiB2b2lke1xyXG4gICAgICAgIGxldCB3ZWFwb25EYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcIndlYXBvbkRhdGFcIik7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB3ZWFwb25EYXRhLm51bVdlYXBvbnM7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCB3ZWFwb24gPSB3ZWFwb25EYXRhLndlYXBvbnNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwcm90b3R5cGVcclxuICAgICAgICAgICAgbGV0IGNvbnN0ciA9IFJlZ2lzdHJ5TWFuYWdlci5nZXRSZWdpc3RyeShcIndlYXBvblRlbXBsYXRlc1wiKS5nZXQod2VhcG9uLndlYXBvblR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd2VhcG9uIHR5cGVcclxuICAgICAgICAgICAgbGV0IHdlYXBvblR5cGUgPSBuZXcgY29uc3RyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB3ZWFwb24gdHlwZVxyXG4gICAgICAgICAgICB3ZWFwb25UeXBlLmluaXRpYWxpemUod2VhcG9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSB3ZWFwb24gdHlwZVxyXG4gICAgICAgICAgICBSZWdpc3RyeU1hbmFnZXIuZ2V0UmVnaXN0cnkoXCJ3ZWFwb25UeXBlc1wiKS5yZWdpc3Rlckl0ZW0od2VhcG9uLm5hbWUsIHdlYXBvblR5cGUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpemVQbGF5ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbnZlbnRvcnlcclxuICAgICAgICBsZXQgaW52ZW50b3J5ID0gbmV3IEludmVudG9yeU1hbmFnZXIodGhpcywgMiwgXCJpbnZlbnRvcnlTbG90XCIsIG5ldyBWZWMyKDE2LCAxNiksIDQpO1xyXG4gICAgICAgIGxldCBzdGFydGluZ1dlYXBvbiA9IHRoaXMuY3JlYXRlV2VhcG9uKFwia25pZmVcIik7XHJcbiAgICAgICAgaW52ZW50b3J5LmFkZEl0ZW0oc3RhcnRpbmdXZWFwb24pO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxyXG4gICAgICAgIHRoaXMucGxheWVyID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJwbGF5ZXJcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnBvc2l0aW9uLnNldCgyKjE2LCA2MioxNik7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDUsIDUpKSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYWRkQUkoUGxheWVyQ29udHJvbGxlcixcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGludmVudG9yeTogaW52ZW50b3J5LFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnNldEdyb3VwKFwicGxheWVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhPTUVXT1JLIDMgLSBUT0RPXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgbmF2bWVzaCBmb3IgdGhlIGdhbWUgd29ybGQuXHJcbiAgICAgKiBcclxuICAgICAqIEl0IHJlYWRzIGluIGluZm9ybWF0aW9uIGluIHRoZSBuYXZtZXNoLmpzb24gZmlsZS5cclxuICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIG5hdm1lc2guanNvbiBmaWxlIGlzIGFzIGZvbGxvd3NcclxuICAgICAqIFxyXG4gICAgICoge1xyXG4gICAgICogIC8vIEFuIGFycmF5IG9mIHBvc2l0aW9ucyBvbiB0aGUgdGlsZW1hcC4gWW91IGNhbiBzZWUgdGhlIHBvc2l0aW9uIG9mIHlvdXIgbW91c2UgaW4gW3JvdywgY29sXVxyXG4gICAgICogIC8vIHdoaWxlIGVkaXRpbmcgYSBtYXAgaW4gVGlsZWQsIGFuZCBjYW4ganVzdCBtdWx0aXBseSB0aG9zZSB2YWx1ZXMgYnkgdGhlIHRpbGUgc2l6ZSwgMTZ4MTZcclxuICAgICAqICAgICAgXCJub2Rlc1wiOiBbWzEwMCwgMjAwXSwgWzUwLCA0MDBdLCAuLi5dXHJcbiAgICAgKiBcclxuICAgICAqICAvLyBBbiBhcnJheSBvZiBlZGdlcyBiZXR3ZWVuIG5vZGVzLiBUaGUgbnVtYmVycyBoZXJlIGNvcnJlc3BvbmQgdG8gaW5kaWNlcyBpbiB0aGUgXCJub2Rlc1wiIGFycmF5IGFib3ZlLlxyXG4gICAgICogIC8vIE5vdGUgdGhhdCBlZGdlcyBhcmUgbm90IGRpcmVjdGVkIGhlcmUuIEFuIGVkZ2UgWzAsIDFdIGZvZXMgaW4gYm90aCBkaXJlY3Rpb25zLlxyXG4gICAgICogICAgICBcImVkZ2VzXCI6IFtbMCwgMV0sIFsyLCA0XSwgLi4uXVxyXG4gICAgICogfVxyXG4gICAgICogXHJcbiAgICAgKiBZb3VyIGpvYiBoZXJlIGlzIHRvIG1ha2UgYSBuZXcgZ3JhcGggdG8gc2VydmUgYXMgdGhlIG5hdm1lc2guIFlvdXIgZ3JhcGggc2hvdWxkIGJlIGRlc2lnbmVkXHJcbiAgICAgKiBmb3IgeW91ciB0aWxlbWFwLCBhbmQgbm8gZWRnZXMgc2hvdWxkIGdvIHRocm91Z2ggd2FsbHMuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZU5hdm1lc2goKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQWRkIGEgbGF5ZXIgdG8gZGlzcGxheSB0aGUgZ3JhcGhcclxuICAgICAgICBsZXQgZ0xheWVyID0gdGhpcy5hZGRMYXllcihcImdyYXBoXCIpO1xyXG4gICAgICAgIGdMYXllci5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIGxldCBuYXZtZXNoRGF0YSA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJuYXZtZXNoXCIpO1xyXG5cclxuICAgICAgICAgLy8gQ3JlYXRlIHRoZSBncmFwaFxyXG4gICAgICAgIHRoaXMuZ3JhcGggPSBuZXcgUG9zaXRpb25HcmFwaCgpO1xyXG5cclxuICAgICAgICAvLyBBZGQgYWxsIG5vZGVzIHRvIG91ciBncmFwaFxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiBuYXZtZXNoRGF0YS5ub2Rlcyl7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkUG9zaXRpb25lZE5vZGUobmV3IFZlYzIobm9kZVswXSwgbm9kZVsxXSkpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLlBPSU5ULCBcImdyYXBoXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIobm9kZVswXSwgbm9kZVsxXSl9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGFsbCBlZGdlcyB0byBvdXIgZ3JhcGhcclxuICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgbmF2bWVzaERhdGEuZWRnZXMpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoLmFkZEVkZ2UoZWRnZVswXSwgZWRnZVsxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJncmFwaFwiLCB7c3RhcnQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGVkZ2VbMF0pLCBlbmQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGVkZ2VbMV0pfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGlzIGdyYXBoIGFzIGEgbmF2aWdhYmxlIGVudGl0eVxyXG4gICAgICAgIGxldCBuYXZtZXNoID0gbmV3IE5hdm1lc2godGhpcy5ncmFwaCk7XHJcbiAgICAgICAgdGhpcy5uYXZNYW5hZ2VyLmFkZE5hdmlnYWJsZUVudGl0eShodzNfTmFtZXMuTkFWTUVTSCwgbmF2bWVzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSE9NRVdPUksgMyAtIFRPRE9cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFsbCBlbmVtaWVzIGZyb20gdGhlIGVuZW15Lmpzb24gZmlsZS5cclxuICAgICAqIFlvdSBzaG91bGRuJ3QgaGF2ZSB0byBtb2RpZnkgYW55IGNvZGUgaGVyZSwgYnV0IHlvdSBzaG91bGQgZWRpdCBlbmVteS5qc29uIHRvXHJcbiAgICAgKiBtYWtlIHN1cmUgbW9yZSBlbmVtaWVzIGFyZSBzcGF3bmVkIGludG8gdGhlIHdvcmxkLlxyXG4gICAgICogXHJcbiAgICAgKiBQYXRyb2xsaW5nIGVuZW1pZXMgYXJlIGdpdmVuIHBhdHJvbCByb3V0ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgbmF2bWVzaC4gVGhlIG51bWJlcnMgaW4gdGhlaXIgcm91dGUgY29ycmVzcG9uZFxyXG4gICAgICogdG8gaW5kaWNlcyBpbiB0aGUgbmF2bWVzaC5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZUVuZW1pZXMoKXtcclxuICAgICAgICAvLyBHZXQgdGhlIGVuZW15IGRhdGFcclxuICAgICAgICBjb25zdCBlbmVteURhdGEgPSB0aGlzLmxvYWQuZ2V0T2JqZWN0KFwiZW5lbXlEYXRhXCIpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gZW5lbWllcyBhcnJheVxyXG4gICAgICAgIHRoaXMuZW5lbWllcyA9IG5ldyBBcnJheShlbmVteURhdGEubnVtRW5lbWllcyk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGVuZW1pZXNcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZW5lbXlEYXRhLm51bUVuZW1pZXM7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZW5lbXlEYXRhLmVuZW1pZXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW5lbXlcclxuICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJlbmVteVwiLCBcInByaW1hcnlcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5wb3NpdGlvbi5zZXQoZGF0YS5wb3NpdGlvblswXSwgZGF0YS5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5hbmltYXRpb24ucGxheShcIklETEVcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSBwaHlzaWNzXHJcbiAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoNSwgNSkpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGRhdGEucm91dGUpe1xyXG4gICAgICAgICAgICAgICAgZGF0YS5yb3V0ZSA9IGRhdGEucm91dGUubWFwKChpbmRleDogbnVtYmVyKSA9PiB0aGlzLmdyYXBoLmdldE5vZGVQb3NpdGlvbihpbmRleCkpOyAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZGF0YS5ndWFyZFBvc2l0aW9uKXtcclxuICAgICAgICAgICAgICAgIGRhdGEuZ3VhcmRQb3NpdGlvbiA9IG5ldyBWZWMyKGRhdGEuZ3VhcmRQb3NpdGlvblswXSwgZGF0YS5ndWFyZFBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGVuZW15T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRNb2RlOiBkYXRhLm1vZGUsXHJcbiAgICAgICAgICAgICAgICBwYXRyb2xSb3V0ZTogZGF0YS5yb3V0ZSwgICAgICAgICAgICAvLyBUaGlzIG9ubHkgbWF0dGVycyBpZiB0aGV5J3JlIGEgcGF0cm9sbGVyXHJcbiAgICAgICAgICAgICAgICBndWFyZFBvc2l0aW9uOiBkYXRhLmd1YXJkUG9zaXRpb24sICAvLyBUaGlzIG9ubHkgbWF0dGVycyBpZiB0aGUncmUgYSBndWFyZFxyXG4gICAgICAgICAgICAgICAgaGVhbHRoOiBkYXRhLmhlYWx0aCxcclxuICAgICAgICAgICAgICAgIHBsYXllcjogdGhpcy5wbGF5ZXIsXHJcbiAgICAgICAgICAgICAgICB3ZWFwb246IHRoaXMuY3JlYXRlV2VhcG9uKFwid2Vha19waXN0b2xcIilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZEFJKEVuZW15QUksIGVuZW15T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5zZXRHcm91cChcImVuZW15XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImV4cG9ydCBlbnVtIGh3M19OYW1lcyB7XHJcbiAgICBOQVZNRVNIID0gXCJuYXZtZXNoXCJcclxufVxyXG5cclxuZXhwb3J0IGVudW0gaHczX0V2ZW50cyB7XHJcbiAgICBTSE9UX0ZJUkVEID0gXCJTSE9UX0ZJUkVEXCJcclxufSIsImltcG9ydCBHYW1lIGZyb20gXCIuL1dvbGZpZTJEL0xvb3AvR2FtZVwiO1xyXG5pbXBvcnQgaHczX3NjZW5lIGZyb20gXCIuL2h3My9TY2VuZXMvaHczX3NjZW5lXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5IGZyb20gXCIuL2h3My9SZWdpc3RyeS9XZWFwb25SZWdpc3RyeVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZVJlZ2lzdHJ5IGZyb20gXCIuL2h3My9SZWdpc3RyeS9XZWFwb25UeXBlUmVnaXN0cnlcIjtcclxuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL2h3My9TY2VuZXMvTWFpbk1lbnVcIjtcclxuXHJcbi8vIFRoZSBtYWluIGZ1bmN0aW9uIGlzIHlvdXIgZW50cnlwb2ludCBpbnRvIFdvbGZpZTJELiBTcGVjaWZ5IHlvdXIgZmlyc3Qgc2NlbmUgYW5kIGFueSBvcHRpb25zIGhlcmUuXHJcbihmdW5jdGlvbiBtYWluKCl7XHJcbiAgICAvLyBSdW4gYW55IHRlc3RzXHJcbiAgICBydW5UZXN0cygpO1xyXG5cclxuICAgIC8vIFNldCB1cCBvcHRpb25zIGZvciBvdXIgZ2FtZVxyXG4gICAgbGV0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgY2FudmFzU2l6ZToge3g6IDEyMDAsIHk6IDgwMH0sICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBnYW1lXHJcbiAgICAgICAgY2xlYXJDb2xvcjoge3I6IDAuMSwgZzogMC4xLCBiOiAwLjF9LCAgIC8vIFRoZSBjb2xvciB0aGUgZ2FtZSBjbGVhcnMgdG9cclxuICAgICAgICBpbnB1dHM6IFtcclxuICAgICAgICAgICAge25hbWU6IFwiZm9yd2FyZFwiLCBrZXlzOiBbXCJ3XCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwiYmFja3dhcmRcIiwga2V5czogW1wic1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImxlZnRcIiwga2V5czogW1wiYVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInJpZ2h0XCIsIGtleXM6IFtcImRcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJwaWNrdXBcIiwga2V5czogW1wiZVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImRyb3BcIiwga2V5czogW1wicVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInNsb3QxXCIsIGtleXM6IFtcIjFcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJzbG90MlwiLCBrZXlzOiBbXCIyXCJdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgdXNlV2ViR0w6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGdhbWUgd2Ugd2FudCB0byB1c2Ugd2ViZ2xcclxuICAgICAgICBzaG93RGVidWc6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHNob3cgZGVidWcgbWVzc2FnZXMuIFlvdSBjYW4gY2hhbmdlIHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB1cCBjdXN0b20gcmVnaXN0cmllc1xyXG4gICAgbGV0IHdlYXBvblRlbXBsYXRlUmVnaXN0cnkgPSBuZXcgV2VhcG9uVGVtcGxhdGVSZWdpc3RyeSgpO1xyXG4gICAgUmVnaXN0cnlNYW5hZ2VyLmFkZEN1c3RvbVJlZ2lzdHJ5KFwid2VhcG9uVGVtcGxhdGVzXCIsIHdlYXBvblRlbXBsYXRlUmVnaXN0cnkpO1xyXG4gICAgXHJcbiAgICBsZXQgd2VhcG9uVHlwZVJlZ2lzdHJ5ID0gbmV3IFdlYXBvblR5cGVSZWdpc3RyeSgpO1xyXG4gICAgUmVnaXN0cnlNYW5hZ2VyLmFkZEN1c3RvbVJlZ2lzdHJ5KFwid2VhcG9uVHlwZXNcIiwgd2VhcG9uVHlwZVJlZ2lzdHJ5KTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBnYW1lIHdpdGggdGhlIG9wdGlvbnMgc3BlY2lmaWVkXHJcbiAgICBjb25zdCBnYW1lID0gbmV3IEdhbWUob3B0aW9ucyk7XHJcblxyXG4gICAgLy8gU3RhcnQgb3VyIGdhbWVcclxuICAgIGdhbWUuc3RhcnQoTWFpbk1lbnUsIHt9KTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIHJ1blRlc3RzKCl7fTsiXX0=
